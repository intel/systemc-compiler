//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.21
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] sig;

//------------------------------------------------------------------------------
// Clocked THREAD: wait_in_record1 (test_wait_call.cpp:52:5) 

// Thread-local variables
logic wait_in_record1_PROC_STATE;
logic wait_in_record1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_in_record1_comb     // test_wait_call.cpp:52:5
    wait_in_record1_func;
end
function void wait_in_record1_func;
    wait_in_record1_PROC_STATE_next = wait_in_record1_PROC_STATE;
    
    case (wait_in_record1_PROC_STATE)
        0: begin
            // Call waitFunc() begin
            wait_in_record1_PROC_STATE_next = 1; return;    // test_wait_call.cpp:34:13;
            // Call waitFunc() end
        end
        1: begin
            // Call waitFunc() begin
            wait_in_record1_PROC_STATE_next = 1; return;    // test_wait_call.cpp:34:13;
            // Call waitFunc() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : wait_in_record1_ff
    if ( ~nrst ) begin
        wait_in_record1_PROC_STATE <= 0;    // test_wait_call.cpp:54:9;
    end
    else begin
        wait_in_record1_PROC_STATE <= wait_in_record1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_in_record2 (test_wait_call.cpp:63:5) 

// Thread-local variables
logic signed [31:0] par;
logic signed [31:0] par_next;
logic signed [31:0] sig_next;
logic wait_in_record2_PROC_STATE;
logic wait_in_record2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_in_record2_comb     // test_wait_call.cpp:63:5
    wait_in_record2_func;
end
function void wait_in_record2_func;
    integer TMP_0;
    integer i;
    integer TMP_2;
    par_next = par;
    sig_next = sig;
    wait_in_record2_PROC_STATE_next = wait_in_record2_PROC_STATE;
    
    case (wait_in_record2_PROC_STATE)
        0: begin
            par_next = 10;
            // Call waitFunc() begin
            par_next = par_next + 1;
            wait_in_record2_PROC_STATE_next = 1; return;    // test_wait_call.cpp:39:13;
            // Call waitFunc() end
        end
        1: begin
            // Call waitFunc() begin
            TMP_0 = par_next;
            // Call waitFunc() end
            i = TMP_0;
            sig_next = i;
            par_next = 10;
            // Call waitFunc() begin
            par_next = par_next + 1;
            wait_in_record2_PROC_STATE_next = 1; return;    // test_wait_call.cpp:39:13;
            // Call waitFunc() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : wait_in_record2_ff
    if ( ~nrst ) begin
        wait_in_record2_PROC_STATE <= 0;    // test_wait_call.cpp:65:9;
    end
    else begin
        par <= par_next;
        sig <= sig_next;
        wait_in_record2_PROC_STATE <= wait_in_record2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_in_record3 (test_wait_call.cpp:74:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic wait_in_record3_PROC_STATE;
logic wait_in_record3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_in_record3_comb     // test_wait_call.cpp:74:5
    wait_in_record3_func;
end
function void wait_in_record3_func;
    i_next = i0;
    wait_in_record3_PROC_STATE_next = wait_in_record3_PROC_STATE;
    
    case (wait_in_record3_PROC_STATE)
        0: begin
            i_next = sig;
            // Call waitFuncRef() begin
            i_next++;
            wait_in_record3_PROC_STATE_next = 1; return;    // test_wait_call.cpp:45:13;
            // Call waitFuncRef() end
        end
        1: begin
            // Call waitFuncRef() begin
            i_next--;
            // Call waitFuncRef() end
            i_next = sig;
            // Call waitFuncRef() begin
            i_next++;
            wait_in_record3_PROC_STATE_next = 1; return;    // test_wait_call.cpp:45:13;
            // Call waitFuncRef() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : wait_in_record3_ff
    if ( ~nrst ) begin
        wait_in_record3_PROC_STATE <= 0;    // test_wait_call.cpp:77:9;
    end
    else begin
        i0 <= i_next;
        wait_in_record3_PROC_STATE <= wait_in_record3_PROC_STATE_next;
    end
end

endmodule


