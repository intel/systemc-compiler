//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.37
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;

//------------------------------------------------------------------------------
// Clocked THREAD: resetProc (test_signal_reset.cpp:57:5) 

// Thread-local variables
logic [15:0] cntr;
logic [15:0] cntr_next;
logic rstn_next;

// Next-state combinational logic
always_comb begin : resetProc_comb     // test_signal_reset.cpp:57:5
    resetProc_func;
end
function void resetProc_func;
    cntr_next = cntr;
    rstn_next = rstn;
    cntr_next++;
    rstn_next = cntr_next != 10;
endfunction

// Synchronous register update
always_ff @(posedge clk) 
begin : resetProc_ff
    begin
        cntr <= cntr_next;
        rstn <= rstn_next;
    end
end


//------------------------------------------------------------------------------
// Child module instances

B b_mod
(
  .clk(clk),
  .rstn(rstn)
);

endmodule



//==============================================================================
//
// Module: B (test_signal_reset.cpp:47:5)
//
module B // "a_mod.b_mod"
(
    input logic clk,
    input logic rstn
);

// Variables generated for SystemC signals
logic signed [31:0] s;
logic signed [31:0] t;

//------------------------------------------------------------------------------
// Method process: methodProc (test_signal_reset.cpp:24:5) 

always_comb 
begin : methodProc     // test_signal_reset.cpp:24:5
    if (rstn)
    begin
        s = 0;
    end else begin
        s = 1;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: threadProc (test_signal_reset.cpp:33:5) 

// Thread-local variables
logic signed [31:0] t_next;

// Next-state combinational logic
always_comb begin : threadProc_comb     // test_signal_reset.cpp:33:5
    threadProc_func;
end
function void threadProc_func;
    t_next = t;
    t_next = 1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : threadProc_ff
    if ( ~rstn ) begin
        t <= 0;
    end
    else begin
        t <= t_next;
    end
end

endmodule


