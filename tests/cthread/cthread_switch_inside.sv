//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.15
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk,
    input logic a,
    output logic b,
    output logic c
);

// Variables generated for SystemC signals
logic rstn;
logic [2:0] s;
logic [2:0] t;

// Local parameters generated for C++ constants
localparam logic ONE = 1;
localparam logic ZERO = 0;

//------------------------------------------------------------------------------
// Clocked THREAD: switch_if1 (test_cthread_switch_inside.cpp:77:5) 

// Thread-local variables
logic signed [31:0] k;

// Next-state combinational logic
always_comb begin : switch_if1_comb     // test_cthread_switch_inside.cpp:77:5
    switch_if1_func;
end
function void switch_if1_func;
    integer i;
    if (|s)
    begin
        case (t)
        1 : begin
            i = 1;
        end
        2 : begin
            i = 2;
        end
        default : begin
            k = 3;
        end
        endcase
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_if1_ff
    if ( ~rstn ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_if2 (test_cthread_switch_inside.cpp:93:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic [1:0] switch_if2_PROC_STATE;
logic [1:0] switch_if2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_if2_comb     // test_cthread_switch_inside.cpp:93:5
    switch_if2_func;
end
function void switch_if2_func;
    i_next = i0;
    switch_if2_PROC_STATE_next = switch_if2_PROC_STATE;
    
    case (switch_if2_PROC_STATE)
        0: begin
            if (|s)
            begin
            end else begin
                case (t)
                1 : begin
                    i_next = 1;
                end
                2 : begin
                    i_next = 2;
                    switch_if2_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:102:37;
                end
                default : begin
                end
                endcase
            end
            switch_if2_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:106:13;
        end
        1: begin
            i_next++;
            switch_if2_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:106:13;
        end
        2: begin
            if (|s)
            begin
            end else begin
                case (t)
                1 : begin
                    i_next = 1;
                end
                2 : begin
                    i_next = 2;
                    switch_if2_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:102:37;
                end
                default : begin
                end
                endcase
            end
            switch_if2_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:106:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_if2_ff
    if ( ~rstn ) begin
        switch_if2_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:95:9;
    end
    else begin
        i0 <= i_next;
        switch_if2_PROC_STATE <= switch_if2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_if3 (test_cthread_switch_inside.cpp:110:5) 

// Thread-local variables
logic signed [31:0] m;
logic signed [31:0] m_next;
logic switch_if3_PROC_STATE;
logic switch_if3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_if3_comb     // test_cthread_switch_inside.cpp:110:5
    switch_if3_func;
end
function void switch_if3_func;
    integer i;
    m_next = m;
    switch_if3_PROC_STATE_next = switch_if3_PROC_STATE;
    
    case (switch_if3_PROC_STATE)
        0: begin
            m_next = s;
            switch_if3_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:117:13;
        end
        1: begin
            if (|s || |t)
            begin
                case (m_next)
                1 : begin  // Empty case without break
                    i = 2;
                end
                2 : begin
                    i = 2;
                end
                endcase
            end
            m_next = s;
            switch_if3_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:117:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_if3_ff
    if ( ~rstn ) begin
        switch_if3_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:112:9;
    end
    else begin
        m <= m_next;
        switch_if3_PROC_STATE <= switch_if3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_if4 (test_cthread_switch_inside.cpp:128:5) 

// Thread-local variables
logic signed [31:0] i1;
logic signed [31:0] i_next0;
logic [1:0] switch_if4_PROC_STATE;
logic [1:0] switch_if4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_if4_comb     // test_cthread_switch_inside.cpp:128:5
    switch_if4_func;
end
function void switch_if4_func;
    i_next0 = i1;
    switch_if4_PROC_STATE_next = switch_if4_PROC_STATE;
    
    case (switch_if4_PROC_STATE)
        0: begin
            if (|s)
            begin
                if (|t)
                begin
                    case (a)
                    1 : begin  // Empty case without break
                        i_next0 = 2;
                    end
                    default : begin
                        i_next0 = 2;
                    end
                    endcase
                    switch_if4_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:139:21;
                end
                case (i_next0)
                1 : begin
                    i_next0 = 2;
                end
                2 : begin
                    i_next0 = 3;
                end
                endcase
            end
            switch_if4_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:148:13;
        end
        1: begin
            case (i_next0)
            1 : begin
                i_next0 = 2;
            end
            2 : begin
                i_next0 = 3;
            end
            endcase
            switch_if4_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:148:13;
        end
        2: begin
            case (s)
            1 : begin
                i_next0 = 2;
            end
            endcase
            switch_if4_PROC_STATE_next = 3; return;    // test_cthread_switch_inside.cpp:154:13;
        end
        3: begin
            if (|s)
            begin
                if (|t)
                begin
                    case (a)
                    1 : begin  // Empty case without break
                        i_next0 = 2;
                    end
                    default : begin
                        i_next0 = 2;
                    end
                    endcase
                    switch_if4_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:139:21;
                end
                case (i_next0)
                1 : begin
                    i_next0 = 2;
                end
                2 : begin
                    i_next0 = 3;
                end
                endcase
            end
            switch_if4_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:148:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_if4_ff
    if ( ~rstn ) begin
        switch_if4_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:130:9;
    end
    else begin
        i1 <= i_next0;
        switch_if4_PROC_STATE <= switch_if4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_if5 (test_cthread_switch_inside.cpp:158:5) 

// Thread-local variables
logic signed [31:0] i2;
logic signed [31:0] i_next1;
logic [1:0] switch_if5_PROC_STATE;
logic [1:0] switch_if5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_if5_comb     // test_cthread_switch_inside.cpp:158:5
    switch_if5_func;
end
function void switch_if5_func;
    i_next1 = i2;
    switch_if5_PROC_STATE_next = switch_if5_PROC_STATE;
    
    case (switch_if5_PROC_STATE)
        0: begin
            if (|s)
            begin
            end else begin
                case (i_next1)
                1 : begin
                    i_next1 = 2;
                end
                2 : begin
                    i_next1 = 3;
                end
                default : begin
                    if (i_next1 < 3)
                    begin
                        i_next1++;
                        switch_if5_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:170:38;
                    end
                end
                endcase
                if (|t)
                begin
                    case (s)
                    1 : begin
                        i_next1 = 1;
                        switch_if5_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:178:35;
                    end
                    default : begin
                        i_next1 = 2;
                    end
                    endcase
                end
            end
            switch_if5_PROC_STATE_next = 3; return;    // test_cthread_switch_inside.cpp:185:13;
        end
        1: begin
            if (i_next1 < 3)
            begin
                i_next1++;
                switch_if5_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:170:38;
            end
            if (|t)
            begin
                case (s)
                1 : begin
                    i_next1 = 1;
                    switch_if5_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:178:35;
                end
                default : begin
                    i_next1 = 2;
                end
                endcase
            end
            switch_if5_PROC_STATE_next = 3; return;    // test_cthread_switch_inside.cpp:185:13;
        end
        2: begin
            if (|s)
            begin
                i_next1--;
            end
            i_next1 = 2;
            switch_if5_PROC_STATE_next = 3; return;    // test_cthread_switch_inside.cpp:185:13;
        end
        3: begin
            if (|s)
            begin
            end else begin
                case (i_next1)
                1 : begin
                    i_next1 = 2;
                end
                2 : begin
                    i_next1 = 3;
                end
                default : begin
                    if (i_next1 < 3)
                    begin
                        i_next1++;
                        switch_if5_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:170:38;
                    end
                end
                endcase
                if (|t)
                begin
                    case (s)
                    1 : begin
                        i_next1 = 1;
                        switch_if5_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:178:35;
                    end
                    default : begin
                        i_next1 = 2;
                    end
                    endcase
                end
            end
            switch_if5_PROC_STATE_next = 3; return;    // test_cthread_switch_inside.cpp:185:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_if5_ff
    if ( ~rstn ) begin
        i2 <= 0;
        switch_if5_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:160:9;
    end
    else begin
        i2 <= i_next1;
        switch_if5_PROC_STATE <= switch_if5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_if_comp1 (test_cthread_switch_inside.cpp:192:5) 

// Thread-local variables
logic signed [31:0] i3;
logic signed [31:0] i_next2;
logic arr[3];

// Next-state combinational logic
always_comb begin : switch_if_comp1_comb     // test_cthread_switch_inside.cpp:192:5
    switch_if_comp1_func;
end
function void switch_if_comp1_func;
    i_next2 = i3;
    if (ZERO || |s)
    begin
        case (i_next2)
        1 : begin
            i_next2 = 2;
        end
        2 : begin
            i_next2 = 3;
        end
        default : begin
        end
        endcase
        i_next2++;
    end
    if (ONE && |t)
    begin
        case (i_next2)
        1 : begin
            for (integer i = 0; i < 3; ++i)
            begin
                arr[i] = a;
            end
        end
        2 : begin
            i_next2 = 3;
        end
        endcase
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_if_comp1_ff
    if ( ~rstn ) begin
    end
    else begin
        i3 <= i_next2;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_if_comp2 (test_cthread_switch_inside.cpp:222:5) 

// Thread-local variables
logic signed [31:0] i4;
logic signed [31:0] i_next3;

// Next-state combinational logic
always_comb begin : switch_if_comp2_comb     // test_cthread_switch_inside.cpp:222:5
    switch_if_comp2_func;
end
function void switch_if_comp2_func;
    i_next3 = i4;
    case (i_next3)
    1 : begin
        if (ZERO || a)
        begin
            i_next3++;
        end
    end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_if_comp2_ff
    if ( ~rstn ) begin
    end
    else begin
        i4 <= i_next3;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_for1 (test_cthread_switch_inside.cpp:251:5) 

// Next-state combinational logic
always_comb begin : switch_for1_comb     // test_cthread_switch_inside.cpp:251:5
    switch_for1_func;
end
function void switch_for1_func;
    integer i;
    integer l;
    l = s;
    for (integer j = 0; j < 7; j++)
    begin
        case (l)
        1 : begin
            i = 1;
        end
        2 : begin
            i = 2;
        end
        endcase
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_for1_ff
    if ( ~rstn ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_for2 (test_cthread_switch_inside.cpp:266:5) 

// Thread-local variables
logic signed [31:0] j0;
logic signed [31:0] j_next;
logic switch_for2_PROC_STATE;
logic switch_for2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_for2_comb     // test_cthread_switch_inside.cpp:266:5
    switch_for2_func;
end
function void switch_for2_func;
    integer i;
    j_next = j0;
    switch_for2_PROC_STATE_next = switch_for2_PROC_STATE;
    
    case (switch_for2_PROC_STATE)
        0: begin
            j_next = 0;
            case (s)
            1 : begin
                i = 1;
            end
            2 : begin
                i = 2;
            end
            default : begin
            end
            endcase
            switch_for2_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:278:17;
        end
        1: begin
            case (t)
            1 : begin
                i = 1;
            end
            default : begin
                if (|s)
                begin
                    i = 2;
                end
            end
            endcase
            j_next++;
            if (j_next < 7)
            begin
                case (s)
                1 : begin
                    i = 1;
                end
                2 : begin
                    i = 2;
                end
                default : begin
                end
                endcase
                switch_for2_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:278:17;
            end
            j_next = 0;
            case (s)
            1 : begin
                i = 1;
            end
            2 : begin
                i = 2;
            end
            default : begin
            end
            endcase
            switch_for2_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:278:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_for2_ff
    if ( ~rstn ) begin
        switch_for2_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:268:9;
    end
    else begin
        j0 <= j_next;
        switch_for2_PROC_STATE <= switch_for2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_for3 (test_cthread_switch_inside.cpp:288:5) 

// Thread-local variables
logic signed [31:0] l0;
logic signed [31:0] l_next;
logic signed [31:0] j1;
logic signed [31:0] j_next0;
logic [1:0] switch_for3_PROC_STATE;
logic [1:0] switch_for3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_for3_comb     // test_cthread_switch_inside.cpp:288:5
    switch_for3_func;
end
function void switch_for3_func;
    integer i;
    j_next0 = j1;
    l_next = l0;
    switch_for3_PROC_STATE_next = switch_for3_PROC_STATE;
    
    case (switch_for3_PROC_STATE)
        0: begin
            j_next0 = 0;
            if (|t)
            begin
                case (s)
                1 : begin  // Empty case without break
                    if (|s)
                    begin
                        i = 1;
                    end
                end
                2 : begin
                    if (|s)
                    begin
                        i = 1;
                    end
                end
                default : begin
                end
                endcase
            end
            l_next = 0;
            case (s)
            1 : begin
                i = 1;
            end
            default : begin
                i = 2;
            end
            endcase
            switch_for3_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:307:21;
        end
        1: begin
            l_next++;
            if (l_next < 3)
            begin
                case (s)
                1 : begin
                    i = 1;
                end
                default : begin
                    i = 2;
                end
                endcase
                switch_for3_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:307:21;
            end
            j_next0++;
            if (j_next0 < 3)
            begin
                if (|t)
                begin
                    case (s)
                    1 : begin  // Empty case without break
                        if (|s)
                        begin
                            i = 1;
                        end
                    end
                    2 : begin
                        if (|s)
                        begin
                            i = 1;
                        end
                    end
                    default : begin
                    end
                    endcase
                end
                l_next = 0;
                case (s)
                1 : begin
                    i = 1;
                end
                default : begin
                    i = 2;
                end
                endcase
                switch_for3_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:307:21;
            end
            switch_for3_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:310:13;
        end
        2: begin
            j_next0 = 0;
            if (|t)
            begin
                case (s)
                1 : begin  // Empty case without break
                    if (|s)
                    begin
                        i = 1;
                    end
                end
                2 : begin
                    if (|s)
                    begin
                        i = 1;
                    end
                end
                default : begin
                end
                endcase
            end
            l_next = 0;
            case (s)
            1 : begin
                i = 1;
            end
            default : begin
                i = 2;
            end
            endcase
            switch_for3_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:307:21;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_for3_ff
    if ( ~rstn ) begin
        switch_for3_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:290:9;
    end
    else begin
        l0 <= l_next;
        j1 <= j_next0;
        switch_for3_PROC_STATE <= switch_for3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_for4 (test_cthread_switch_inside.cpp:314:5) 

// Thread-local variables
logic signed [31:0] l1;
logic signed [31:0] l_next0;
logic signed [31:0] j2;
logic signed [31:0] j_next1;
logic [1:0] switch_for4_PROC_STATE;
logic [1:0] switch_for4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_for4_comb     // test_cthread_switch_inside.cpp:314:5
    switch_for4_func;
end
function void switch_for4_func;
    integer i;
    j_next1 = j2;
    l_next0 = l1;
    switch_for4_PROC_STATE_next = switch_for4_PROC_STATE;
    
    case (switch_for4_PROC_STATE)
        0: begin
            j_next1 = 0;
            if (|t)
            begin
                case (s)
                1 : begin
                    i = 1;
                end
                default : begin
                    l_next0 = 0;
                    switch_for4_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:325:33;
                end
                endcase
            end
            switch_for4_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:334:17;
        end
        1: begin
            case (t)
            1 : begin
                i = 1;
            end
            default : begin
                i = 2;
            end
            endcase
            l_next0++;
            if (l_next0 < 3)
            begin
                switch_for4_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:325:33;
            end
            switch_for4_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:334:17;
        end
        2: begin
            j_next1++;
            if (j_next1 < 3)
            begin
                if (|t)
                begin
                    case (s)
                    1 : begin
                        i = 1;
                    end
                    default : begin
                        l_next0 = 0;
                        switch_for4_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:325:33;
                    end
                    endcase
                end
                switch_for4_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:334:17;
            end
            switch_for4_PROC_STATE_next = 3; return;    // test_cthread_switch_inside.cpp:336:13;
        end
        3: begin
            j_next1 = 0;
            if (|t)
            begin
                case (s)
                1 : begin
                    i = 1;
                end
                default : begin
                    l_next0 = 0;
                    switch_for4_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:325:33;
                end
                endcase
            end
            switch_for4_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:334:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_for4_ff
    if ( ~rstn ) begin
        switch_for4_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:316:9;
    end
    else begin
        l1 <= l_next0;
        j2 <= j_next1;
        switch_for4_PROC_STATE <= switch_for4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_for5 (test_cthread_switch_inside.cpp:341:5) 

// Thread-local variables
logic [3:0] arr2d[3][4];
logic [3:0] arr2d_next[3][4];

// Next-state combinational logic
always_comb begin : switch_for5_comb     // test_cthread_switch_inside.cpp:341:5
    switch_for5_func;
end
function void switch_for5_func;
    integer i;
    logic [15:0] sum;
    arr2d_next = arr2d;
    sum = 1;
    for (integer j_1 = 0; j_1 < 3; j_1++)
    begin
        for (integer l_1 = 0; l_1 < 4; l_1++)
        begin
            case (arr2d_next[j_1][l_1])
            1 : begin
                i = 1;
            end
            default : begin
                i = 2;
            end
            endcase
            sum = sum + i;
        end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_for5_ff
    if ( ~rstn ) begin
        integer i;
        i = 0;
        for (integer j = 0; j < 3; j++)
        begin
            for (integer l = 0; l < 4; l++)
            begin
                arr2d[j][l] <= l / (j + 1);
            end
        end
    end
    else begin
        arr2d <= arr2d_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_for6 (test_cthread_switch_inside.cpp:365:5) 

// Thread-local variables
logic signed [31:0] j3;
logic signed [31:0] j_next2;
logic [1:0] switch_for6_PROC_STATE;
logic [1:0] switch_for6_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_for6_comb     // test_cthread_switch_inside.cpp:365:5
    switch_for6_func;
end
function void switch_for6_func;
    integer i;
    j_next2 = j3;
    switch_for6_PROC_STATE_next = switch_for6_PROC_STATE;
    
    case (switch_for6_PROC_STATE)
        0: begin
            j_next2 = 1;
            case (s)
            2 : begin
                i = 1;
            end
            endcase
            switch_for6_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:378:17;
        end
        1: begin
            j_next2++;
            if (j_next2 < 3)
            begin
                case (s)
                2 : begin
                    i = 1;
                end
                endcase
                switch_for6_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:378:17;
            end
            for (integer j = 1; j < 3; j++)
            begin
                case (s)
                3 : begin
                    i = 1;
                end
                default : begin
                end
                endcase
            end
            switch_for6_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:387:13;
        end
        2: begin
            j_next2 = 1;
            case (s)
            2 : begin
                i = 1;
            end
            endcase
            switch_for6_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:378:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_for6_ff
    if ( ~rstn ) begin
        switch_for6_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:367:9;
    end
    else begin
        j3 <= j_next2;
        switch_for6_PROC_STATE <= switch_for6_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_while1 (test_cthread_switch_inside.cpp:391:5) 

// Next-state combinational logic
always_comb begin : switch_while1_comb     // test_cthread_switch_inside.cpp:391:5
    switch_while1_func;
end
function void switch_while1_func;
    integer i;
    integer j;
    j = 0;
    while (j < 4)
    begin
        if (j == s)
        begin
            case (t)
            1 : begin
                i = 1;
            end
            default : begin
                i = 2;
            end
            endcase
        end
        j = j + 2;
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_while1_ff
    if ( ~rstn ) begin
        integer i;
        i = 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_while2 (test_cthread_switch_inside.cpp:410:5) 

// Thread-local variables
logic signed [31:0] i5;
logic signed [31:0] i_next4;
logic signed [31:0] j4;
logic signed [31:0] j_next3;
logic [1:0] switch_while2_PROC_STATE;
logic [1:0] switch_while2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_while2_comb     // test_cthread_switch_inside.cpp:410:5
    switch_while2_func;
end
function void switch_while2_func;
    i_next4 = i5;
    j_next3 = j4;
    switch_while2_PROC_STATE_next = switch_while2_PROC_STATE;
    
    case (switch_while2_PROC_STATE)
        0: begin
            j_next3 = 5;
            case (t)
            1 : begin
                for (integer j = 1; j < 3; j++)
                begin
                    i_next4 = i_next4 + j;
                end
            end
            default : begin
                i_next4 = 2;
            end
            endcase
            switch_while2_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:425:17;
        end
        1: begin
            j_next3--;
            if (j_next3 != 0)
            begin
                case (t)
                1 : begin
                    for (integer j = 1; j < 3; j++)
                    begin
                        i_next4 = i_next4 + j;
                    end
                end
                default : begin
                    i_next4 = 2;
                end
                endcase
                switch_while2_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:425:17;
            end
            switch_while2_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:428:13;
        end
        2: begin
            j_next3 = 5;
            case (t)
            1 : begin
                for (integer j = 1; j < 3; j++)
                begin
                    i_next4 = i_next4 + j;
                end
            end
            default : begin
                i_next4 = 2;
            end
            endcase
            switch_while2_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:425:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_while2_ff
    if ( ~rstn ) begin
        i5 <= 0;
        switch_while2_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:412:9;
    end
    else begin
        i5 <= i_next4;
        j4 <= j_next3;
        switch_while2_PROC_STATE <= switch_while2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_call1 (test_cthread_switch_inside.cpp:446:5) 

// Thread-local variables
logic [3:0] val;
logic [3:0] val_next;
logic [1:0] switch_call1_PROC_STATE;
logic [1:0] switch_call1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_call1_comb     // test_cthread_switch_inside.cpp:446:5
    switch_call1_func;
end
function void switch_call1_func;
    integer i;
    logic [3:0] TMP_0;
    logic [3:0] TMP_1;
    val_next = val;
    switch_call1_PROC_STATE_next = switch_call1_PROC_STATE;
    
    case (switch_call1_PROC_STATE)
        0: begin
            val_next = t;
            // Call swfunc1() begin
            case (val_next)
            1 : begin
                TMP_0 = 1;
            end
            2 : begin
                if (val_next == s)
                begin
                    val_next = val_next + 1;
                    switch_call1_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:439:25;
                end
                TMP_0 = val_next;
            end
            default : begin
                TMP_0 = val_next + 2;
            end
            endcase
            // Call swfunc1() end
            i = TMP_0;
            switch_call1_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:452:13;
        end
        1: begin
            // Call swfunc1() begin
            TMP_0 = val_next;
            // Call swfunc1() end
            i = TMP_0;
            switch_call1_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:452:13;
        end
        2: begin
            val_next = t;
            // Call swfunc1() begin
            case (val_next)
            1 : begin
                TMP_1 = 1;
            end
            2 : begin
                if (val_next == s)
                begin
                    val_next = val_next + 1;
                    switch_call1_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:439:25;
                end
                TMP_1 = val_next;
            end
            default : begin
                TMP_1 = val_next + 2;
            end
            endcase
            // Call swfunc1() end
            i = TMP_1;
            switch_call1_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:452:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_call1_ff
    if ( ~rstn ) begin
        integer i;
        i = 0;
        switch_call1_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:448:9;
    end
    else begin
        val <= val_next;
        switch_call1_PROC_STATE <= switch_call1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_call2 (test_cthread_switch_inside.cpp:476:5) 

// Thread-local variables
logic signed [31:0] l2;
logic signed [31:0] l_next1;
logic [1:0] switch_call2_PROC_STATE;
logic [1:0] switch_call2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : switch_call2_comb     // test_cthread_switch_inside.cpp:476:5
    switch_call2_func;
end
function void switch_call2_func;
    integer i;
    logic [3:0] TMP_0;
    integer TMP_1;
    integer par;
    logic [3:0] TMP_2;
    integer TMP_3;
    l_next1 = l2;
    switch_call2_PROC_STATE_next = switch_call2_PROC_STATE;
    
    case (switch_call2_PROC_STATE)
        0: begin
            // Call swfunc2() begin
            l_next1 = 0;
            case (t)
            1 : begin
                l_next1 = 1;
            end
            2 : begin
                if (t == s)
                begin
                    l_next1 = 2;
                end
            end
            default : begin
                par = t + 1;
                // Call f() begin
                TMP_1 = par + 1;
                // Call f() end
                l_next1 = TMP_1;
            end
            endcase
            switch_call2_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:472:9;
            // Call swfunc2() end
        end
        1: begin
            // Call swfunc2() begin
            TMP_0 = l_next1;
            // Call swfunc2() end
            i = TMP_0;
            switch_call2_PROC_STATE_next = 2; return;    // test_cthread_switch_inside.cpp:482:13;
        end
        2: begin
            // Call swfunc2() begin
            l_next1 = 0;
            case (t)
            1 : begin
                l_next1 = 1;
            end
            2 : begin
                if (t == s)
                begin
                    l_next1 = 2;
                end
            end
            default : begin
                par = t + 1;
                // Call f() begin
                TMP_3 = par + 1;
                // Call f() end
                l_next1 = TMP_3;
            end
            endcase
            switch_call2_PROC_STATE_next = 1; return;    // test_cthread_switch_inside.cpp:472:9;
            // Call swfunc2() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : switch_call2_ff
    if ( ~rstn ) begin
        integer i;
        i = 0;
        switch_call2_PROC_STATE <= 0;    // test_cthread_switch_inside.cpp:478:9;
    end
    else begin
        l2 <= l_next1;
        switch_call2_PROC_STATE <= switch_call2_PROC_STATE_next;
    end
end

endmodule


