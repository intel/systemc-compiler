//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.15
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic [7:0] s;

// Local parameters generated for C++ constants
localparam logic signed [31:0] CI = 1;

//------------------------------------------------------------------------------
// Method process: read_array_bug (test_cthread_read_defined.cpp:57:5) 

always_comb 
begin : read_array_bug     // test_cthread_read_defined.cpp:57:5
    integer a[3];
    integer b[2][2];
    logic [3:0] c[3];
    integer i;
    c[0] = 0; c[1] = 0; c[2] = 0;
    i = a[s];
    i = c[i] + 1;
    i = b[1][s];
    i = c[i] - 1;
end

//------------------------------------------------------------------------------
// Clocked THREAD: linear1 (test_cthread_read_defined.cpp:75:5) 

// Thread-local variables
logic signed [31:0] m;
logic signed [31:0] k;
logic signed [31:0] n;

// Next-state combinational logic
always_comb begin : linear1_comb     // test_cthread_read_defined.cpp:75:5
    linear1_func;
end
function void linear1_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : linear1_ff
    if ( ~nrst ) begin
        integer i;
        integer m;
        integer k;
        integer n;
        m = 1;
        i = 1;
        k = m + CI;
        m = k - 1;
        n = k;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Method process: linear_self (test_cthread_read_defined.cpp:96:5) 

// Process-local variables
logic signed [31:0] k1;
logic signed [31:0] m1;

always_comb 
begin : linear_self     // test_cthread_read_defined.cpp:96:5
    k1 = k1 + 1;
    m1 = ~m1;
end

//------------------------------------------------------------------------------
// Clocked THREAD: linear_comp_assign (test_cthread_read_defined.cpp:107:5) 

// Thread-local variables
logic signed [31:0] k2;
logic signed [31:0] m2;

// Next-state combinational logic
always_comb begin : linear_comp_assign_comb     // test_cthread_read_defined.cpp:107:5
    linear_comp_assign_func;
end
function void linear_comp_assign_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : linear_comp_assign_ff
    if ( ~nrst ) begin
        integer i;
        integer k2;
        integer m2;
        k2 = 0;
        m2 = 0;
        i = 1;
        i = i + 1;
        k2 = k2 - m2;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: linear_unary (test_cthread_read_defined.cpp:128:5) 

// Thread-local variables
logic signed [31:0] k3;
logic signed [31:0] m3;
logic signed [31:0] n3;

// Next-state combinational logic
always_comb begin : linear_unary_comb     // test_cthread_read_defined.cpp:128:5
    linear_unary_func;
end
function void linear_unary_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : linear_unary_ff
    if ( ~nrst ) begin
        integer i;
        integer k3;
        integer m3;
        integer n3;
        k3 = 0;
        m3 = 1;
        n3 = 2;
        i = k3;
        i = --m3;
        n3++;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: decl_init (test_cthread_read_defined.cpp:145:5) 

// Next-state combinational logic
always_comb begin : decl_init_comb     // test_cthread_read_defined.cpp:145:5
    decl_init_func;
end
function void decl_init_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : decl_init_ff
    if ( ~nrst ) begin
        integer i;
        integer j;
        integer b[2];
        logic c[3];
        logic [1:0] d[2];
        logic [2:0] e[3];
        i = 0;
        j = i;
        b[0] = 1; b[1] = 2;
        c[0] = 1; c[1] = 0; c[2] = 1;
        d[0] = 0; d[1] = 0;
        e[0] = 1; e[1] = 2; e[2] = j;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: decl_init_array (test_cthread_read_defined.cpp:170:5) 

// Next-state combinational logic
always_comb begin : decl_init_array_comb     // test_cthread_read_defined.cpp:170:5
    decl_init_array_func;
end
function void decl_init_array_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : decl_init_array_ff
    if ( ~nrst ) begin
        integer a[3];
        integer b[2][2];
        logic [3:0] c[2][3];
        integer d[4];
        a[0] = 1; a[1] = 2; a[2] = 3;
        b[0][0] = 1; b[0][1] = 2; b[1][0] = 3; b[1][1] = 4;
        c[0][0] = 0; c[0][1] = 0; c[0][2] = 0; c[1][0] = 0; c[1][1] = 0; c[1][2] = 0;
        for (integer i = 0; i < 4; ++i)
        begin
            d[i] = i;
        end
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Method process: read_array (test_cthread_read_defined.cpp:191:5) 

always_comb 
begin : read_array     // test_cthread_read_defined.cpp:191:5
    integer a[3];
    integer b[2][2];
    logic [3:0] c[3];
    logic d[4];
    logic signed e[4];
    logic [32:0] f[10];
    integer i;
    a[0] = 1; a[1] = 2; a[2] = 3;
    c[0] = 0; c[1] = 0; c[2] = 0;
    e[0] = 0; e[1] = 0; e[2] = 0; e[3] = 0;
    f[0] = 0; f[1] = 0; f[2] = 0; f[3] = 0; f[4] = 0; f[5] = 0; f[6] = 0; f[7] = 0; f[8] = 0; f[9] = 0;
    i = a[1];
    i = b[1][s];
    i = c[i] + 1;
    i = d[s - 1] ? 1 : 2;
    e[s]++;
    for (integer i_1 = 0; i_1 < 4; ++i_1)
    begin
        d[i_1] = |(1 <<< 32'(f[i_1 + 1]));
    end
end

//------------------------------------------------------------------------------
// Method process: wite_known_array (test_cthread_read_defined.cpp:223:5) 

always_comb 
begin : wite_known_array     // test_cthread_read_defined.cpp:223:5
    integer a[3];
    logic b[2][2];
    integer unsigned c[2][3];
    logic signed [63:0] d[2][2];
    integer l;
    logic [3:0] x;
    l = 0;
    x = 2;
    a[1] = 1;
    a[x] = 2;
    b[l][1] = 1;
    c[l + 1][2] = 3;
end

//------------------------------------------------------------------------------
// Method process: wite_unknown_array (test_cthread_read_defined.cpp:243:5) 

always_comb 
begin : wite_unknown_array     // test_cthread_read_defined.cpp:243:5
    integer a[3];
    integer b[2][2];
    integer c[2][3];
    integer i;
    i = s;
    a[i] = 1;
    a[s + 1] = 1;
    b[i][1] = 2;
    c[1][s] = 3;
    a[i] = a[i - 1];
    a[s] = 1;
    a[s + 1] = 1;
end

//------------------------------------------------------------------------------
// Method process: linear_scint_oper (test_cthread_read_defined.cpp:267:5) 

always_comb 
begin : linear_scint_oper     // test_cthread_read_defined.cpp:267:5
    integer i;
    integer j1;
    integer j2;
    logic signed [7:0] x;
    logic signed [32:0] y;
    integer k_1;
    i = 1;
    j1 = 3;
    j2 = 2;
    x = 0;
    x[i] = 1;
    x[j1 - 1 +: 2] = 1;
    x[j2 +: 2] = 1;
    y = 0;
    k_1 = i;
    y[k_1] = 1;
    y[k_1 + 1] = 0;
    y[k_1 +: 2] = 0;
    y[s] = 0;
    y[s - 1 +: 3] = 0;
end

//------------------------------------------------------------------------------
// Method process: linear_scint_member (test_cthread_read_defined.cpp:300:5) 

always_comb 
begin : linear_scint_member     // test_cthread_read_defined.cpp:300:5
    integer i;
    integer j1;
    integer j2;
    logic signed [7:0] x;
    i = 1;
    j1 = 2;
    j2 = 3;
    x = 0;
    x[i] = 1;
    x[j1 - 1 +: 2] = 1;
    x[j2 +: 2] = 1;
end

//------------------------------------------------------------------------------
// Method process: linear_scfunc_call (test_cthread_read_defined.cpp:315:5) 

always_comb 
begin : linear_scfunc_call     // test_cthread_read_defined.cpp:315:5
    logic signed [2:0] x;
    logic signed [2:0] y;
    logic [5:0] z;
    logic b;
    x = 0;
    y = 0;
    z = {x, y};
    b = &z;
    b = |s;
end

//------------------------------------------------------------------------------
// Method process: sc_type_init (test_cthread_read_defined.cpp:330:5) 

always_comb 
begin : sc_type_init     // test_cthread_read_defined.cpp:330:5
    logic signed [15:0] x1;
    logic signed [15:0] y;
    logic signed [15:0] x2;
    logic signed [15:0] z;
    x1 = 0;
    y = x1;
    x2 = 0;
    z = x2;
end

//------------------------------------------------------------------------------
// Method process: sc_type_init2 (test_cthread_read_defined.cpp:343:6) 

always_comb 
begin : sc_type_init2     // test_cthread_read_defined.cpp:343:6
    logic signed [3:0] x;
    logic signed [3:0] y;
    logic signed [7:0] z;
    x = 0;
    y = 0;
    z = x + y;
end

//------------------------------------------------------------------------------
// Method process: sc_type_binary (test_cthread_read_defined.cpp:353:5) 

always_comb 
begin : sc_type_binary     // test_cthread_read_defined.cpp:353:5
    logic signed [3:0] x;
    logic signed [3:0] y;
    logic signed [7:0] z;
    logic signed [3:0] x2;
    logic signed [7:0] z2;
    x = 0;
    y = 0;
    z = 0;
    z = x + y;
    x2 = 0;
    z2 = 0;
    z2 = s + x2;
end

//------------------------------------------------------------------------------
// Method process: sc_type_unary (test_cthread_read_defined.cpp:373:5) 

always_comb 
begin : sc_type_unary     // test_cthread_read_defined.cpp:373:5
    logic signed [3:0] x;
    logic signed [3:0] y;
    logic b;
    logic signed [3:0] z;
    x = 0;
    y = 0;
    z = 0;
    b = !(|x);
    z = ~y;
end

//------------------------------------------------------------------------------
// Method process: if_stmt (test_cthread_read_defined.cpp:387:5) 

always_comb 
begin : if_stmt     // test_cthread_read_defined.cpp:387:5
    logic c1;
    integer i1;
    integer j1;
    integer k_1;
    integer k_2;
    c1 = |s;
    if (c1)
    begin
        k_1 = i1;
    end else begin
        k_2 = j1;
    end
end

//------------------------------------------------------------------------------
// Method process: cond_oper (test_cthread_read_defined.cpp:401:5) 

always_comb 
begin : cond_oper     // test_cthread_read_defined.cpp:401:5
    logic c1;
    integer i1;
    integer j1;
    integer k1_1;
    integer i2;
    integer j2;
    integer c2;
    integer k2_1;
    c1 = |s;
    k1_1 = c1 ? i1 : j1;
    k2_1 = (c2 == 0) ? i2 + 1 : j2 + 1;
end

endmodule


