//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.15
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic p_req;
logic [15:0] p_s;
logic pp_req[2];
logic [15:0] pp_s[2];
logic [15:0] s;
logic p_clk;
logic p_rstn;
logic pp_clk[2];
logic pp_rstn[2];
logic cc_req[2];
logic [31:0] cc_resp[2];

// Assignments generated for C++ channel arrays
assign p_clk = clk;
assign p_rstn = rstn;
assign pp_clk[0] = clk;
assign pp_clk[1] = clk;
assign pp_rstn[0] = rstn;
assign pp_rstn[1] = rstn;
assign cc_req = pp_req;

//------------------------------------------------------------------------------
// Clocked THREAD: p_threadProc (test_sc_vector_mif3.cpp:29:5) 

// Thread-local variables
logic [15:0] p_s_next;
logic p_req_next;

// Next-state combinational logic
always_comb begin : p_threadProc_comb     // test_sc_vector_mif3.cpp:29:5
    p_threadProc_func;
end
function void p_threadProc_func;
    p_req_next = p_req;
    p_s_next = p_s;
    p_req_next = 0;
    p_s_next = p_s + 1;
    if (|(p_s % 3))
    begin
        p_req_next = 1;
    end
endfunction

// Synchronous register update
always_ff @(posedge p_clk or negedge p_rstn) 
begin : p_threadProc_ff
    if ( ~p_rstn ) begin
        p_s <= 0;
        p_req <= 0;
    end
    else begin
        p_s <= p_s_next;
        p_req <= p_req_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: pp_threadProc (test_sc_vector_mif3.cpp:29:5) 

// Thread-local variables
logic [15:0] pp_s_next[2];
logic pp_req_next[2];

// Next-state combinational logic
always_comb begin : pp_threadProc_comb     // test_sc_vector_mif3.cpp:29:5
    pp_threadProc_func;
end
function void pp_threadProc_func;
    pp_req_next[0] = pp_req[0];
    pp_s_next[0] = pp_s[0];
    pp_req_next[0] = 0;
    pp_s_next[0] = pp_s[0] + 1;
    if (|(pp_s[0] % 3))
    begin
        pp_req_next[0] = 1;
    end
endfunction

// Synchronous register update
always_ff @(posedge pp_clk[0] or negedge pp_rstn[0]) 
begin : pp_threadProc_ff
    if ( ~pp_rstn[0] ) begin
        pp_s[0] <= 0;
        pp_req[0] <= 0;
    end
    else begin
        pp_s[0] <= pp_s_next[0];
        pp_req[0] <= pp_req_next[0];
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: pp_threadProc0 (test_sc_vector_mif3.cpp:29:5) 

// Next-state combinational logic
always_comb begin : pp_threadProc0_comb     // test_sc_vector_mif3.cpp:29:5
    pp_threadProc0_func;
end
function void pp_threadProc0_func;
    pp_req_next[1] = pp_req[1];
    pp_s_next[1] = pp_s[1];
    pp_req_next[1] = 0;
    pp_s_next[1] = pp_s[1] + 1;
    if (|(pp_s[1] % 3))
    begin
        pp_req_next[1] = 1;
    end
endfunction

// Synchronous register update
always_ff @(posedge pp_clk[1] or negedge pp_rstn[1]) 
begin : pp_threadProc0_ff
    if ( ~pp_rstn[1] ) begin
        pp_s[1] <= 0;
        pp_req[1] <= 0;
    end
    else begin
        pp_s[1] <= pp_s_next[1];
        pp_req[1] <= pp_req_next[1];
    end
end

//------------------------------------------------------------------------------
// Method process: cc_methProc (test_sc_vector_mif3.cpp:59:5) 

always_comb 
begin : cc_methProc     // test_sc_vector_mif3.cpp:59:5
    cc_resp[0] = 1;
    if (cc_req[0])
    begin
        cc_resp[0] = 2;
    end
end

//------------------------------------------------------------------------------
// Method process: cc_methProc0 (test_sc_vector_mif3.cpp:59:5) 

always_comb 
begin : cc_methProc0     // test_sc_vector_mif3.cpp:59:5
    cc_resp[1] = 1;
    if (cc_req[1])
    begin
        cc_resp[1] = 2;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: mainProc (test_sc_vector_mif3.cpp:95:5) 

// Next-state combinational logic
always_comb begin : mainProc_comb     // test_sc_vector_mif3.cpp:95:5
    mainProc_func;
end
function void mainProc_func;
    integer unsigned u;
    logic [15:0] TMP_0;
    logic [15:0] TMP_1;
    logic [15:0] res;
    u = s;
    // Call getData() begin
    TMP_0 = pp_s[u];
    // Call getData() end
    // Call getData() begin
    TMP_1 = p_s;
    // Call getData() end
    res = TMP_0 + TMP_1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : mainProc_ff
    if ( ~rstn ) begin
    end
    else begin
    end
end

endmodule


