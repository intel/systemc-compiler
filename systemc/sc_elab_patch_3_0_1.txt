diff -crBN systemc-3.0.1/CMakeLists.txt systemc-3.0.1_patched/CMakeLists.txt
*** systemc-3.0.1/CMakeLists.txt	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/CMakeLists.txt	2025-05-13 16:58:16.843306000 -0700
***************
*** 255,268 ****
         FORCE)
  endif()
  
! if (NOT (WIN32 OR CYGWIN))
!   option (BUILD_SHARED_LIBS "Build shared libraries." ON)
! else (NOT (WIN32 OR CYGWIN))
!   option (BUILD_SHARED_LIBS "Build shared libraries." OFF)
! endif (NOT (WIN32 OR CYGWIN))
! if (BUILD_SHARED_LIBS AND (WIN32 OR CYGWIN))
!   set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
! endif(BUILD_SHARED_LIBS AND (WIN32 OR CYGWIN))
  
  option (BUILD_SOURCE_DOCUMENTATION "Build source documentation with Doxygen." OFF)
  
--- 255,268 ----
         FORCE)
  endif()
  
! #if (NOT (WIN32 OR CYGWIN))
! #  option (BUILD_SHARED_LIBS "Build shared libraries." ON)
! #else (NOT (WIN32 OR CYGWIN))
! #  option (BUILD_SHARED_LIBS "Build shared libraries." OFF)
! #endif (NOT (WIN32 OR CYGWIN))
! #if (BUILD_SHARED_LIBS AND (WIN32 OR CYGWIN))
! #  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
! #endif(BUILD_SHARED_LIBS AND (WIN32 OR CYGWIN))
  
  option (BUILD_SOURCE_DOCUMENTATION "Build source documentation with Doxygen." OFF)
  
***************
*** 457,477 ****
  # Set the installation paths
  ###############################################################################
  
! if (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
!   if (IS_ABSOLUTE $ENV{SYSTEMC_HOME})
!     set (_CMAKE_INSTALL_PREFIX $ENV{SYSTEMC_HOME})
!   elseif (UNIX)
!     set (_CMAKE_INSTALL_PREFIX "/opt/systemc")
!   elseif (WIN32)
!     file (TO_CMAKE_PATH $ENV{ProgramFiles} _WIN32_INSTALL_PREFIX)
!     set (_CMAKE_INSTALL_PREFIX "${_WIN32_INSTALL_PREFIX}/SystemC")
!     unset (_WIN32_INSTALL_PREFIX)
!   else (EXISTS $ENV{SYSTEMC_ROOT_DIR})
!     set (_CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}/systemc")
!   endif (IS_ABSOLUTE $ENV{SYSTEMC_HOME})
!   set (CMAKE_INSTALL_PREFIX ${_CMAKE_INSTALL_PREFIX} CACHE PATH "Installation root directory" FORCE)
!   unset (_CMAKE_INSTALL_PREFIX)
! endif (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  
  # Set the installation paths for headers, libraries, and documentation.
  set (CMAKE_INSTALL_DOCDIR "share/doc/systemc" CACHE PATH
--- 457,477 ----
  # Set the installation paths
  ###############################################################################
  
! #if (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
! #  if (IS_ABSOLUTE $ENV{SYSTEMC_HOME})
! #    set (_CMAKE_INSTALL_PREFIX $ENV{SYSTEMC_HOME})
! #  elseif (UNIX)
! #    set (_CMAKE_INSTALL_PREFIX "/opt/systemc")
! #  elseif (WIN32)
! #    file (TO_CMAKE_PATH $ENV{ProgramFiles} _WIN32_INSTALL_PREFIX)
! #    set (_CMAKE_INSTALL_PREFIX "${_WIN32_INSTALL_PREFIX}/SystemC")
! #    unset (_WIN32_INSTALL_PREFIX)
! #  else (EXISTS $ENV{SYSTEMC_ROOT_DIR})
! #    set (_CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}/systemc")
! #  endif (IS_ABSOLUTE $ENV{SYSTEMC_HOME})
! #  set (CMAKE_INSTALL_PREFIX ${_CMAKE_INSTALL_PREFIX} CACHE PATH "Installation root directory" FORCE)
! #  unset (_CMAKE_INSTALL_PREFIX)
! #endif (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  
  # Set the installation paths for headers, libraries, and documentation.
  set (CMAKE_INSTALL_DOCDIR "share/doc/systemc" CACHE PATH
***************
*** 637,644 ****
  list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
  add_subdirectory (src)
  add_subdirectory (docs)
! add_subdirectory (examples)
! add_subdirectory (tests)
  
  ###############################################################################
  # Install README files
--- 637,644 ----
  list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
  add_subdirectory (src)
  add_subdirectory (docs)
! #add_subdirectory (examples)
! #add_subdirectory (tests)
  
  ###############################################################################
  # Install README files
***************
*** 660,700 ****
  ###############################################################################
  
  # Export the systemc library target for usage by other programs to installation tree
! install (EXPORT SystemCLanguageTargets
!          NAMESPACE SystemC::
!          DESTINATION ${SystemCLanguage_INSTALL_CMAKEDIR}
!          COMPONENT dev)
! 
  # Register the SystemCLanguage and SystemCTLM packages for use from the
  # build tree. (This registers the build tree with the global CMake-registry.)
! export (PACKAGE SystemCLanguage)
! export (PACKAGE SystemCTLM)
! 
  # Create the <Package>Config.cmake and <Package>ConfigVersion files
! include(CMakePackageConfigHelpers)
! configure_package_config_file(cmake/SystemCLanguageConfig.cmake.in
!   ${CMAKE_CURRENT_BINARY_DIR}/SystemCLanguageConfig.cmake
!   INSTALL_DESTINATION ${SystemCLanguage_INSTALL_CMAKEDIR})
! write_basic_package_version_file(
!   "${CMAKE_CURRENT_BINARY_DIR}/SystemCLanguageConfigVersion.cmake"
!   VERSION ${SystemCLanguage_VERSION_MAJOR}.${SystemCLanguage_VERSION_MINOR}.${SystemCLanguage_VERSION_PATCH}.${SystemCLanguage_VERSION_RELEASE_DATE}
!   COMPATIBILITY AnyNewerVersion
! )
! configure_package_config_file(cmake/SystemCTLMConfig.cmake.in
!   ${CMAKE_CURRENT_BINARY_DIR}/SystemCTLMConfig.cmake
!   INSTALL_DESTINATION ${SystemCTLM_INSTALL_CMAKEDIR})
! write_basic_package_version_file(
!   "${CMAKE_CURRENT_BINARY_DIR}/SystemCTLMConfigVersion.cmake"
!   VERSION ${SystemCTLM_VERSION_MAJOR}.${SystemCTLM_VERSION_MINOR}.${SystemCTLM_VERSION_PATCH}.${SystemCTLM_VERSION_RELEASE_DATE}
!   COMPATIBILITY AnyNewerVersion
! )
  
  # Install the <Package>Config.cmake and <Package>ConfigVersion.cmake
! install(FILES "${PROJECT_BINARY_DIR}/SystemCLanguageConfig.cmake"
!               "${PROJECT_BINARY_DIR}/SystemCLanguageConfigVersion.cmake"
!         DESTINATION "${SystemCLanguage_INSTALL_CMAKEDIR}"
!         COMPONENT dev)
! install(FILES "${PROJECT_BINARY_DIR}/SystemCTLMConfig.cmake"
!               "${PROJECT_BINARY_DIR}/SystemCTLMConfigVersion.cmake"
!         DESTINATION "${SystemCTLM_INSTALL_CMAKEDIR}"
!         COMPONENT dev)
--- 660,700 ----
  ###############################################################################
  
  # Export the systemc library target for usage by other programs to installation tree
! #install (EXPORT SystemCLanguageTargets
! #         NAMESPACE SystemC::
! #         DESTINATION ${SystemCLanguage_INSTALL_CMAKEDIR}
! #         COMPONENT dev)
! #
  # Register the SystemCLanguage and SystemCTLM packages for use from the
  # build tree. (This registers the build tree with the global CMake-registry.)
! #export (PACKAGE SystemCLanguage)
! #export (PACKAGE SystemCTLM)
! #
  # Create the <Package>Config.cmake and <Package>ConfigVersion files
! #include(CMakePackageConfigHelpers)
! #configure_package_config_file(cmake/SystemCLanguageConfig.cmake.in
! #  ${CMAKE_CURRENT_BINARY_DIR}/SystemCLanguageConfig.cmake
! #  INSTALL_DESTINATION ${SystemCLanguage_INSTALL_CMAKEDIR})
! #write_basic_package_version_file(
! #  "${CMAKE_CURRENT_BINARY_DIR}/SystemCLanguageConfigVersion.cmake"
! #  VERSION ${SystemCLanguage_VERSION_MAJOR}.${SystemCLanguage_VERSION_MINOR}.${SystemCLanguage_VERSION_PATCH}.${SystemCLanguage_VERSION_RELEASE_DATE}
! #  COMPATIBILITY AnyNewerVersion
! #)
! #configure_package_config_file(cmake/SystemCTLMConfig.cmake.in
! #  ${CMAKE_CURRENT_BINARY_DIR}/SystemCTLMConfig.cmake
! #  INSTALL_DESTINATION ${SystemCTLM_INSTALL_CMAKEDIR})
! #write_basic_package_version_file(
! #  "${CMAKE_CURRENT_BINARY_DIR}/SystemCTLMConfigVersion.cmake"
! #  VERSION ${SystemCTLM_VERSION_MAJOR}.${SystemCTLM_VERSION_MINOR}.${SystemCTLM_VERSION_PATCH}.${SystemCTLM_VERSION_RELEASE_DATE}
! #  COMPATIBILITY AnyNewerVersion
! #)
  
  # Install the <Package>Config.cmake and <Package>ConfigVersion.cmake
! #install(FILES "${PROJECT_BINARY_DIR}/SystemCLanguageConfig.cmake"
! #              "${PROJECT_BINARY_DIR}/SystemCLanguageConfigVersion.cmake"
! #        DESTINATION "${SystemCLanguage_INSTALL_CMAKEDIR}"
! #        COMPONENT dev)
! #install(FILES "${PROJECT_BINARY_DIR}/SystemCTLMConfig.cmake"
! #              "${PROJECT_BINARY_DIR}/SystemCTLMConfigVersion.cmake"
! #        DESTINATION "${SystemCTLM_INSTALL_CMAKEDIR}"
! #        COMPONENT dev)
diff -crBN systemc-3.0.1/src/CMakeLists.txt systemc-3.0.1_patched/src/CMakeLists.txt
*** systemc-3.0.1/src/CMakeLists.txt	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/CMakeLists.txt	2025-05-14 11:30:13.098725000 -0700
***************
*** 51,57 ****
      target_compile_features(
          ${libName}
          PUBLIC
!         cxx_std_17)
  
      target_compile_definitions (
          ${libName}
--- 51,57 ----
      target_compile_features(
          ${libName}
          PUBLIC
!         cxx_std_20)
  
      target_compile_definitions (
          ${libName}
***************
*** 409,414 ****
--- 409,421 ----
          tlm_utils/simple_initiator_socket.h
          tlm_utils/simple_target_socket.h
          tlm_utils/tlm_quantumkeeper.h
+ 
+         # SVC SystemC Elaboration support
+         sc_elab/elab_alloc.h
+         sc_elab/elab_alloc.cpp
+         sc_elab/sc_tool_opts.h
+         sc_elab/sc_tool_opts.cpp
+ 
          # QuickThreads
          $<$<BOOL:${QT_ARCH}>:
            sysc/packages/qt/qt.c
***************
*** 486,491 ****
--- 493,501 ----
  
  add_library(SystemC::systemc ALIAS systemc)
  
+ add_library (SVC::systemc ALIAS systemc)
+ target_compile_features(systemc PUBLIC cxx_std_20)
+ 
  install(TARGETS ${SYSTEMC_TARGETS} EXPORT SystemCLanguageTargets
          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
          LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
***************
*** 501,506 ****
--- 511,522 ----
          NAMESPACE SystemC::
          FILE ${CMAKE_BINARY_DIR}/SystemCLanguageTargets.cmake)
  
+ install (TARGETS systemc EXPORT  SVCTargets
+                          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+                          LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+                          ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+                          COMPONENT lib)
+ 
  # Install the SystemC and TLM headers
  install (FILES systemc tlm
           DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
diff -crBN systemc-3.0.1/src/sc_elab/allocated_node.h systemc-3.0.1_patched/src/sc_elab/allocated_node.h
*** systemc-3.0.1/src/sc_elab/allocated_node.h	1969-12-31 16:00:00.000000000 -0800
--- systemc-3.0.1_patched/src/sc_elab/allocated_node.h	2025-05-13 16:58:16.855309000 -0700
***************
*** 0 ****
--- 1,41 ----
+ //
+ // Created by ripopov on 9/25/18.
+ //
+ 
+ #ifndef SCTOOL_ALLOCATED_NODE_H
+ #define SCTOOL_ALLOCATED_NODE_H
+ 
+ #include <string>
+ #include <vector>
+ 
+ namespace sc_core
+ {
+     class sc_module;
+ }
+ 
+ namespace sc_elab
+ {
+ 
+ /// allocated_node - information about memory allocation
+ struct allocated_node {
+     void *ptr; /// ptr to allocated block
+     sc_core::sc_module* host_mod_p; /// owning sc_module
+     std::size_t size_bytes; /// size of allocation in bytes
+     bool is_array; /// true for new[] allocations
+     std::string mangled_type_name;
+     std::size_t array_size; // number of elements in array for new [X]
+ };
+ 
+ /// get traced dynamic allocations for specified module
+ const std::vector<allocated_node>&
+ get_module_allocs(const sc_core::sc_module* mod_ptr);
+ 
+ /// Calls before_end_of_elaboration callbacks
+ void finalize_elaboration();
+ 
+ /// Generate mangled names for sc_objects, allocated using raw new or new[]
+ void finalize_module_allocations();
+ 
+ }
+ 
+ #endif //SCTOOL_ALLOCATED_NODE_H
diff -crBN systemc-3.0.1/src/sc_elab/elab_alloc.cpp systemc-3.0.1_patched/src/sc_elab/elab_alloc.cpp
*** systemc-3.0.1/src/sc_elab/elab_alloc.cpp	1969-12-31 16:00:00.000000000 -0800
--- systemc-3.0.1_patched/src/sc_elab/elab_alloc.cpp	2025-05-13 16:58:16.857338000 -0700
***************
*** 0 ****
--- 1,135 ----
+ //
+ // Created by ripopov on 12/18/17.
+ //
+ //
+ 
+ #include <sc_elab/elab_alloc.h>
+ #include <sysc/kernel/sc_module.h>
+ #include <sysc/kernel/sc_simcontext.h>
+ #include <sysc/kernel/sc_module_registry.h>
+ #include <sysc/communication/sc_prim_channel.h>
+ #include <sysc/communication/sc_port.h>
+ #include <sysc/communication/sc_export.h>
+ #include <iostream>
+ #include <unordered_map>
+ #include "elab_alloc.h"
+ 
+ namespace sc_elab
+ {
+ 
+ typedef std::unordered_map<const sc_core::sc_module *,
+                            std::vector<allocated_node>> node_map_t;
+ 
+ /// alloc_node_map stores information about dynamic allocations for each module
+ node_map_t *get_alloc_node_map()
+ {
+     static node_map_t *alloc_node_map = nullptr;
+ 
+     if (!alloc_node_map) {
+         alloc_node_map = new node_map_t{};
+     }
+ 
+     return alloc_node_map;
+ }
+ 
+ /// get current active module (parent of currently created sc_objects)
+ static sc_core::sc_module *curr_module()
+ {
+     auto *simctx = sc_core::sc_curr_simcontext;
+     if (!simctx)
+         return nullptr;
+     simctx->get_module_registry();
+     return static_cast<sc_core::sc_module*>(simctx->hierarchy_curr());
+ }
+ 
+ /// get dynamic allocations for given module
+ const std::vector<allocated_node> &get_module_allocs(const sc_core::sc_module *mod_ptr)
+ {
+     return get_alloc_node_map()->operator[](mod_ptr);
+ }
+ 
+ void trace_alloc_impl(void *ptr,
+                       bool is_array,
+                       const char *type_name,
+                       size_t sizeof_alloc,
+                       size_t array_size)
+ {
+ 
+     if (curr_module()) {
+         allocated_node new_node;
+         new_node.ptr = ptr;
+         new_node.host_mod_p = curr_module();
+         new_node.size_bytes = sizeof_alloc;
+         new_node.is_array = is_array;
+         if (type_name)
+             new_node.mangled_type_name = type_name;
+         new_node.array_size = array_size;
+ 
+         (*get_alloc_node_map())[curr_module()].emplace_back(std::move(new_node));
+     }
+ }
+ 
+ void finalize_elaboration()
+ {
+     std::cout << "Finalize elaboration\n";
+     auto *context_p = sc_core::sc_get_curr_simcontext();
+     context_p->sc_tool_elaboration();
+ }
+ 
+ void finalize_module_allocations()
+ {
+     // Iterate over all dynamic allocations and add mangled name where it is absent
+     for (auto &allocIter : *get_alloc_node_map()) {
+ 
+         const sc_core::sc_module *mod_ptr = allocIter.first;
+         std::vector<allocated_node> &alloc_nodes = allocIter.second;
+ 
+         for (auto &node : alloc_nodes) {
+ 
+             // If mangled_type_name is empty, then it is sc_object allocated using raw new or new[]
+             if (node.mangled_type_name.empty()) {
+ 
+                 if (node.is_array) {
+                     // TODO:: optimize by reading Linux/Windows ABI manual
+                     // Current implementation should be safe, it
+                     // finds first child sc_object that is inside allocated node
+                     //
+                     // CXX ABI may store a cookie before actual array, so we
+                     // cant just dereference node.ptr (because it may point to cookie,
+                     // instead of first element of array )
+ 
+                     size_t array_size = 0;
+                     size_t node_addr = (size_t) node.ptr;
+                     node.ptr = nullptr;
+ 
+                     // Calculate array size by counting all sc_objects that are
+                     // inside allocated node
+                     for (auto child_obj : mod_ptr->get_child_objects()) {
+ 
+                         size_t child_addr = (size_t) child_obj;
+ 
+                         if (child_addr >= node_addr
+                             && child_addr < node_addr + node.size_bytes) {
+ 
+                             ++array_size;
+ 
+                             if (!node.ptr) {
+                                 node.ptr = dynamic_cast<void *>(child_obj);
+ 								node.mangled_type_name = MANGLED_TYPENAME(*child_obj);
+                             }
+                         }
+                     }
+ 
+                     node.array_size = array_size;
+ 
+                 }
+                 else {
+                     sc_core::sc_object *obj_ptr = static_cast<sc_core::sc_object *>(node.ptr);
+                     node.mangled_type_name = MANGLED_TYPENAME(*obj_ptr);
+                 }
+             }
+         }
+     }
+ }
+ 
+ }
diff -crBN systemc-3.0.1/src/sc_elab/elab_alloc.h systemc-3.0.1_patched/src/sc_elab/elab_alloc.h
*** systemc-3.0.1/src/sc_elab/elab_alloc.h	1969-12-31 16:00:00.000000000 -0800
--- systemc-3.0.1_patched/src/sc_elab/elab_alloc.h	2025-05-13 16:58:16.860302000 -0700
***************
*** 0 ****
--- 1,110 ----
+ //
+ // Created by ripopov on 12/18/17.
+ //
+ 
+ #ifndef ELAB_ALLOC_H
+ #define ELAB_ALLOC_H
+ 
+ #include <sc_elab/allocated_node.h>
+ 
+ #include <cstdint>
+ #include <typeinfo>
+ 
+ #ifndef _MSC_VER
+ 
+ template<typename T> std::string MANGLED_TYPENAME() {
+     return typeid(T).name();
+ }
+ 
+ template<typename T> std::string MANGLED_TYPENAME(T &&var) {
+     return typeid(var).name();
+ }
+ 
+ #else
+ 
+ inline std::string adjust_msvc_rawname (const char *rawname)
+ {
+     std::string name = (rawname + 1);
+     if (name[0] == '?')
+         return name;
+     else
+         return "?A" + name;
+ }
+ 
+ template<typename T> std::string MANGLED_TYPENAME() {
+     return adjust_msvc_rawname(typeid(T).raw_name());
+ }
+ 
+ template<typename T> std::string MANGLED_TYPENAME(T &&var) {
+     return adjust_msvc_rawname(typeid(var).raw_name());
+ }
+ 
+ 
+ #endif // !_MSC_VER
+ 
+ /**
+  *  Dynamic memory allocation tracking for SystemC elaboration
+  *
+  *  Currently elaborator supports following allocation methods:
+  *
+  *  1.
+  *  template<class T, class... Args>
+  *  T* sc_new(Args&&... args)
+  *
+  *  usage example:  my_module = sc_new<my_module> ("my_module");
+  *
+  *  2.
+  *  template<class T>
+  *  T* sc_new_array(size_t n)
+  *
+  *  usage example:   int * array_ptr = sc_new_array<int> (10);  // create int[10]
+  *
+  *  3.
+  *  All classes derived from sc_objects can use raw new, it is overloaded in
+  *  sc_object
+  *
+  */
+ namespace sc_elab {
+ 
+ ///
+ /// Store information about dynamically allocated object
+ /// @param ptr - pointer to newly allocated object
+ /// @param is_array - true for new[]
+ /// @param type_name - mangled type name
+ /// @param sizeof_alloc - size of object
+ /// @param array_size - N, number of array elements for new[N]
+ ///
+ void trace_alloc_impl(void *ptr,
+                       bool is_array,
+                       const char *type_name,
+                       size_t sizeof_alloc,
+                       size_t array_size = 0);
+ 
+ 
+ }
+ 
+ namespace sc_core
+ {
+ 
+ /// Allocate singular object dynamically and store information for SVC elaboration
+ template<class T, class... Args>
+ T* sc_new(Args&&... args)
+ {
+     T* rptr = ::new T(std::forward<Args>(args)...);
+     sc_elab::trace_alloc_impl(rptr, false, MANGLED_TYPENAME<T>().c_str() , sizeof(T));
+     return rptr;
+ }
+ 
+ /// Allocate array dynamically and store information for SVC elaboration
+ template<class T>
+ T* sc_new_array(size_t n)
+ {
+     T* rptr = ::new T[n];
+     if (n > 0)
+         sc_elab::trace_alloc_impl(rptr, true, MANGLED_TYPENAME<T>().c_str(), sizeof(T)*n, n);
+     return rptr;
+ }
+ 
+ }
+ 
+ #endif // ELAB_ALLOC_H
\ No newline at end of file
diff -crBN systemc-3.0.1/src/sc_elab/process_type_info.h systemc-3.0.1_patched/src/sc_elab/process_type_info.h
*** systemc-3.0.1/src/sc_elab/process_type_info.h	1969-12-31 16:00:00.000000000 -0800
--- systemc-3.0.1_patched/src/sc_elab/process_type_info.h	2025-05-13 16:58:16.861366000 -0700
***************
*** 0 ****
--- 1,18 ----
+ //
+ // Created by ripopov on 10/3/18.
+ //
+ 
+ #ifndef SCTOOL_PROCESS_TYPE_INFO_H
+ #define SCTOOL_PROCESS_TYPE_INFO_H
+ 
+ namespace sc_elab
+ {
+ 
+ struct process_type_info {
+     std::string mangled_host_type; /// Linkage name of host module
+     std::string function_name; /// Name of function
+ };
+ 
+ }
+ 
+ #endif //SCTOOL_PROCESS_TYPE_INFO_H
diff -crBN systemc-3.0.1/src/sc_elab/sc_tool_opts.cpp systemc-3.0.1_patched/src/sc_elab/sc_tool_opts.cpp
*** systemc-3.0.1/src/sc_elab/sc_tool_opts.cpp	1969-12-31 16:00:00.000000000 -0800
--- systemc-3.0.1_patched/src/sc_elab/sc_tool_opts.cpp	2025-05-13 16:58:16.864303000 -0700
***************
*** 0 ****
--- 1,7 ----
+ //
+ // Created by ripopov on 10/30/18.
+ //
+ 
+ #include "sc_tool_opts.h"
+ 
+ std::string *sctool_extra_opts = nullptr;
diff -crBN systemc-3.0.1/src/sc_elab/sc_tool_opts.h systemc-3.0.1_patched/src/sc_elab/sc_tool_opts.h
*** systemc-3.0.1/src/sc_elab/sc_tool_opts.h	1969-12-31 16:00:00.000000000 -0800
--- systemc-3.0.1_patched/src/sc_elab/sc_tool_opts.h	2025-05-13 16:58:16.866321000 -0700
***************
*** 0 ****
--- 1,12 ----
+ //
+ // Created by ripopov on 10/30/18.
+ //
+ 
+ #ifndef SCTOOL_SC_TOOL_OPTS_H
+ #define SCTOOL_SC_TOOL_OPTS_H
+ 
+ #include <string>
+ 
+ extern std::string *sctool_extra_opts;
+ 
+ #endif //SCTOOL_SC_TOOL_OPTS_H
diff -crBN systemc-3.0.1/src/sc_elab/sensitivity.h systemc-3.0.1_patched/src/sc_elab/sensitivity.h
*** systemc-3.0.1/src/sc_elab/sensitivity.h	1969-12-31 16:00:00.000000000 -0800
--- systemc-3.0.1_patched/src/sc_elab/sensitivity.h	2025-05-13 16:58:16.868309000 -0700
***************
*** 0 ****
--- 1,21 ----
+ //
+ // Created by ripopov on 9/28/18.
+ //
+ 
+ #ifndef SCTOOL_SENSITIVITY_H
+ #define SCTOOL_SENSITIVITY_H
+ 
+ namespace sc_core {
+     class sc_process_b;
+ }
+ 
+ namespace sc_elab {
+ 
+ struct port_sens_proc {
+     enum EVENT_KIND {DEFAULT, POSEDGE, NEGEDGE} kind;
+     sc_core::sc_process_b * proc_ptr;
+ };
+ 
+ }
+ 
+ #endif //SCTOOL_SENSITIVITY_H
diff -crBN systemc-3.0.1/src/sysc/communication/sc_event_finder.h systemc-3.0.1_patched/src/sysc/communication/sc_event_finder.h
*** systemc-3.0.1/src/sysc/communication/sc_event_finder.h	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/communication/sc_event_finder.h	2025-05-13 16:58:16.871335000 -0700
***************
*** 110,115 ****
--- 110,121 ----
  
      virtual const sc_event& find_event( sc_interface* if_p = 0 ) const;
  
+     typedef const sc_event& (IF::*event_method_t) () const;
+ 
+     event_method_t get_event_method() {
+         return m_event_method;
+     }
+ 
  private:
  
      const sc_event& (IF::*m_event_method) () const;
diff -crBN systemc-3.0.1/src/sysc/communication/sc_port.cpp systemc-3.0.1_patched/src/sysc/communication/sc_port.cpp
*** systemc-3.0.1/src/sysc/communication/sc_port.cpp	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/communication/sc_port.cpp	2025-05-13 16:58:16.874371000 -0700
***************
*** 767,772 ****
--- 767,831 ----
      }
  }
  
+ // SVC
+ 
+ sc_port_base ** sc_port_base::first_parent_port_ptr()
+ {
+     int i = first_parent();
+     if ( i >= 0 ) {
+         return &m_bind_info->vec[i]->parent;
+     }
+ 
+     return nullptr;
+ }
+ 
+ static sc_elab::port_sens_proc create_sens_proc (sc_bind_ef* bind_ef) {
+     sc_elab::port_sens_proc sens;
+     sens.proc_ptr = bind_ef->handle;
+ 
+     if (bind_ef->event_finder) {
+ 
+         typedef sc_core::sc_signal_in_if<bool> bool_in_if;
+         typedef sc_event_finder_t<bool_in_if> bool_in_if_finder;
+ 
+         if (bool_in_if_finder *inif = dynamic_cast<bool_in_if_finder*>(bind_ef->event_finder)) {
+             if ( inif->get_event_method() == &bool_in_if::posedge_event)
+                 sens.kind = sc_elab::port_sens_proc::POSEDGE;
+             else if ( inif->get_event_method() == &bool_in_if::negedge_event)
+                 sens.kind = sc_elab::port_sens_proc::NEGEDGE;
+             else
+                 sens.kind = sc_elab::port_sens_proc::DEFAULT;
+         }
+     } else {
+         sens.kind = sc_elab::port_sens_proc::DEFAULT;
+     }
+ 
+     return sens;
+ 
+ }
+ 
+ std::vector<sc_elab::port_sens_proc> sc_port_base::get_sensitive_procs() const
+ {
+ 
+     std::vector<sc_elab::port_sens_proc> res;
+ 
+     if ( m_bind_info ) {
+ 
+         for (auto met_bind : m_bind_info->method_vec) {
+             res.push_back(create_sens_proc(met_bind));
+         }
+ 
+         for (auto thread_bind : m_bind_info->thread_vec) {
+             res.push_back(create_sens_proc(thread_bind));
+         }
+ 
+     }
+ 
+     return res;
+ }
+ 
+ 
+ 
  } // namespace sc_core
  
  
diff -crBN systemc-3.0.1/src/sysc/communication/sc_port.h systemc-3.0.1_patched/src/sysc/communication/sc_port.h
*** systemc-3.0.1/src/sysc/communication/sc_port.h	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/communication/sc_port.h	2025-05-13 16:58:16.879312000 -0700
***************
*** 38,43 ****
--- 38,45 ----
  #include "sysc/kernel/sc_object.h"
  #include "sysc/kernel/sc_process.h"
  
+ #include "sc_elab/sensitivity.h"
+ 
  #if defined(_MSC_VER) && !defined(SC_WIN_DLL_WARN)
  #pragma warning(push)
  #pragma warning(disable: 4251) // DLL import for std::vector
***************
*** 98,103 ****
--- 100,109 ----
      // return RTTI information of associated interface
      virtual std::type_index get_interface_type() const = 0;
  
+     this_type ** first_parent_port_ptr();
+ 
+     std::vector<sc_elab::port_sens_proc>   get_sensitive_procs() const;
+ 
  protected:
  
      // constructors
diff -crBN systemc-3.0.1/src/sysc/kernel/sc_main.cpp systemc-3.0.1_patched/src/sysc/kernel/sc_main.cpp
*** systemc-3.0.1/src/sysc/kernel/sc_main.cpp	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/kernel/sc_main.cpp	2025-05-13 16:58:16.882349000 -0700
***************
*** 30,38 ****
--- 30,55 ----
  #include "sysc/kernel/sc_cmnhdr.h"
  #include "sysc/kernel/sc_externs.h"
  
+ #include "sc_elab/sc_tool_opts.h"
+ #include <iostream>
+ 
  int
  main( int argc, char* argv[] )
  {
+     // arguments prefixed with  -sctool  go to SVC, used for debug output options
+     for (int i = 0; i < argc; ++i) {
+         if (std::string(argv[i]) == "-sctool") {
+             if (sctool_extra_opts == nullptr)
+                 sctool_extra_opts = new std::string();
+ 
+             if (i == argc - 1) {
+                 std::cerr << "-sctool specified without passing an option\n";
+                 std::cerr << "Usage: -sctool -some_option\n";
+             }
+ 
+             *sctool_extra_opts = *sctool_extra_opts + " " + argv[i+1];
+         }
+     }
  	return sc_core::sc_elab_and_sim( argc, argv );
  }
  
diff -crBN systemc-3.0.1/src/sysc/kernel/sc_main_main.cpp systemc-3.0.1_patched/src/sysc/kernel/sc_main_main.cpp
*** systemc-3.0.1/src/sysc/kernel/sc_main_main.cpp	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/kernel/sc_main_main.cpp	2025-05-13 16:58:16.885352000 -0700
***************
*** 97,111 ****
          sc_report_handler::get_handler()
              ( x, sc_report_handler::get_catch_actions() );
      }
!     catch( ... )
!     {
!         // translate other escaping exceptions
!         sc_report*  err_p = sc_handle_exception();
!         if( err_p )
!             sc_report_handler::get_handler()
!                 ( *err_p, sc_report_handler::get_catch_actions() );
!         delete err_p;
!     }
  
      for ( int i = 0; i < argc; ++i ) {
          delete[] argv_copy[i];
--- 97,112 ----
          sc_report_handler::get_handler()
              ( x, sc_report_handler::get_catch_actions() );
      }
! //  In SVC we want to crash regularly on exceptions
! //    catch( ... )
! //    {
! //        // translate other escaping exceptions
! //        sc_report*  err_p = sc_handle_exception();
! //        if( err_p )
! //            sc_report_handler::get_handler()
! //                ( *err_p, sc_report_handler::get_catch_actions() );
! //        delete err_p;
! //    }
  
      for ( int i = 0; i < argc; ++i ) {
          delete[] argv_copy[i];
diff -crBN systemc-3.0.1/src/sysc/kernel/sc_module.cpp systemc-3.0.1_patched/src/sysc/kernel/sc_module.cpp
*** systemc-3.0.1/src/sysc/kernel/sc_module.cpp	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/kernel/sc_module.cpp	2025-05-13 16:58:16.889310000 -0700
***************
*** 53,58 ****
--- 53,61 ----
  
  namespace sc_core {
  
+ std::unordered_map<const sc_core::sc_process_b *, sc_elab::process_type_info>
+     proc_info_map;
+ 
  // ----------------------------------------------------------------------------
  //  STRUCT : sc_bind_proxy
  //
***************
*** 276,306 ****
  
  // create processes via SC_METHOD, SC_THREAD, SC_CTHREAD
  
  void
! sc_module::declare_method_process( sc_entry_func func, const char* name )
  {
      sc_process_handle handle =
        simcontext()->create_method_process( name, false, func, this, 0 );
      sensitive << handle;
      sensitive_pos << handle;
      sensitive_neg << handle;
  }
  
  void
! sc_module::declare_thread_process( sc_entry_func func, const char* name )
  {
      sc_process_handle handle =
        simcontext()->create_thread_process( name, false, func, this, 0 );
      sensitive << handle;
      sensitive_pos << handle;
      sensitive_neg << handle;
  }
  
  sc_process_handle
! sc_module::declare_cthread_process( sc_entry_func func, const char* name )
  {
      sc_process_handle handle =
        simcontext()->create_cthread_process( name, false, func, this, 0 );
      return handle;
      // sensitivity is handled in template function
  }
--- 279,325 ----
  
  // create processes via SC_METHOD, SC_THREAD, SC_CTHREAD
  
+ // Save process class and method name so SVC can use it to find in Clang AST
+ void sc_module::register_process(sc_process_handle& handle, 
+                                  const std::string& hostType, 
+                                  const char* func_name)
+ {
+     sc_core::sc_process_b *proc = handle;
+     std::string methodName = func_name;
+     sc_core::proc_info_map[proc] = sc_elab::process_type_info{hostType, methodName};
+ }
+ 
  void
! sc_module::declare_method_process( sc_entry_func func, const std::string& hostType,
!                                    const char* name )
  {
      sc_process_handle handle =
        simcontext()->create_method_process( name, false, func, this, 0 );
+     register_process(handle, hostType, name);
      sensitive << handle;
      sensitive_pos << handle;
      sensitive_neg << handle;
  }
  
  void
! sc_module::declare_thread_process( sc_entry_func func, const std::string& hostType, 
!                                    const char* name )
  {
      sc_process_handle handle =
        simcontext()->create_thread_process( name, false, func, this, 0 );
+     register_process(handle, hostType, name);
      sensitive << handle;
      sensitive_pos << handle;
      sensitive_neg << handle;
  }
  
  sc_process_handle
! sc_module::declare_cthread_process( sc_entry_func func, const std::string& hostType, 
!                                     const char* name )
  {
      sc_process_handle handle =
        simcontext()->create_cthread_process( name, false, func, this, 0 );
+     register_process(handle, hostType, name);
      return handle;
      // sensitivity is handled in template function
  }
diff -crBN systemc-3.0.1/src/sysc/kernel/sc_module.h systemc-3.0.1_patched/src/sysc/kernel/sc_module.h
*** systemc-3.0.1/src/sysc/kernel/sc_module.h	2025-05-13 17:06:44.223332000 -0700
--- systemc-3.0.1_patched/src/sysc/kernel/sc_module.h	2025-05-13 17:06:31.398341000 -0700
***************
*** 44,49 ****
--- 44,53 ----
  
  #include <type_traits> // std::remove_reference
  
+ #include <sc_elab/process_type_info.h>
+ #include <unordered_map>
+ 
+ 
  namespace sc_core {
  
  class sc_name_gen;
***************
*** 152,163 ****
      // this must be called by user-defined modules
      void end_module();
  
!     void declare_method_process( sc_entry_func func, const char* name );
!     void declare_thread_process( sc_entry_func func, const char* name );
!     sc_process_handle declare_cthread_process( sc_entry_func func, const char* name );
      template<typename EdgeType>
!     void declare_cthread_process( sc_entry_func func,const char* name, EdgeType& edge )
!       { sensitive( declare_cthread_process(func, name), edge ); }
  
      // to prevent initialization for SC_METHODs and SC_THREADs
      void dont_initialize();
--- 156,174 ----
      // this must be called by user-defined modules
      void end_module();
  
!     void register_process(sc_process_handle& handle, const std::string& hostType,
!                           const char* func_name);
!     void declare_method_process( sc_entry_func func, const std::string& hostType, 
!                                  const char* name );
!     void declare_thread_process( sc_entry_func func, const std::string& hostType, 
!                                  const char* name );
!     sc_process_handle declare_cthread_process( 
!                                  sc_entry_func func, const std::string& hostType, 
!                                  const char* name );
      template<typename EdgeType>
!     void declare_cthread_process( sc_entry_func func, const std::string& hostType, 
!                                   const char* name, EdgeType& edge )
!       { sensitive( declare_cthread_process(func, hostType, name), edge ); }
  
      // to prevent initialization for SC_METHODs and SC_THREADs
      void dont_initialize();
***************
*** 462,483 ****
  // template<typename X>
  // class A : public B<X>
  
  #define SC_CTHREAD(func, edge)                                                \
      SC_PROCESS_MACRO_BEGIN_                                                   \
      this->declare_cthread_process                                             \
!       ( SC_MAKE_FUNC_PTR(SC_CURRENT_USER_MODULE_TYPE, func), #func, edge )    \
      SC_PROCESS_MACRO_END_
  
  #define SC_METHOD(func)                                                       \
      SC_PROCESS_MACRO_BEGIN_                                                   \
      this->declare_method_process                                              \
!       ( SC_MAKE_FUNC_PTR(SC_CURRENT_USER_MODULE_TYPE, func), #func )          \
      SC_PROCESS_MACRO_END_
  
  #define SC_THREAD(func)                                                       \
      SC_PROCESS_MACRO_BEGIN_                                                   \
      this->declare_thread_process                                              \
!       ( SC_MAKE_FUNC_PTR(SC_CURRENT_USER_MODULE_TYPE, func), #func )          \
      SC_PROCESS_MACRO_END_
  
  
--- 473,505 ----
  // template<typename X>
  // class A : public B<X>
  
+ extern
+ std::unordered_map<const sc_core::sc_process_b *, sc_elab::process_type_info>
+     proc_info_map;
+ 
+ 
  #define SC_CTHREAD(func, edge)                                                \
      SC_PROCESS_MACRO_BEGIN_                                                   \
      this->declare_cthread_process                                             \
!       ( SC_MAKE_FUNC_PTR(SC_CURRENT_USER_MODULE_TYPE, func),                  \
!         MANGLED_TYPENAME<typename std::remove_reference<decltype(*this)>::type>(), \
!         #func, edge )    \
      SC_PROCESS_MACRO_END_
  
  #define SC_METHOD(func)                                                       \
      SC_PROCESS_MACRO_BEGIN_                                                   \
      this->declare_method_process                                              \
!       ( SC_MAKE_FUNC_PTR(SC_CURRENT_USER_MODULE_TYPE, func),                  \
!         MANGLED_TYPENAME<typename std::remove_reference<decltype(*this)>::type>(), \
!         #func )          \
      SC_PROCESS_MACRO_END_
  
  #define SC_THREAD(func)                                                       \
      SC_PROCESS_MACRO_BEGIN_                                                   \
      this->declare_thread_process                                              \
!       ( SC_MAKE_FUNC_PTR(SC_CURRENT_USER_MODULE_TYPE, func),                  \
!         MANGLED_TYPENAME<typename std::remove_reference<decltype(*this)>::type>(), \
!         #func )          \
      SC_PROCESS_MACRO_END_
  
  
***************
*** 488,493 ****
--- 510,520 ----
  typedef sc_module sc_channel;
  typedef sc_module sc_behavior;
  
+ // Not a modular interface  (Prevent module inherited from sc_interface to become modular interface)
+ struct sc_dont_collapse {};
+ // Modular interface
+ struct sc_modular_interface : sc_module {};
+ 
  } // namespace sc_core
  
  /*****************************************************************************
diff -crBN systemc-3.0.1/src/sysc/kernel/sc_object.h systemc-3.0.1_patched/src/sysc/kernel/sc_object.h
*** systemc-3.0.1/src/sysc/kernel/sc_object.h	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/kernel/sc_object.h	2025-05-13 16:58:16.899309000 -0700
***************
*** 31,36 ****
--- 31,37 ----
  #define SC_OBJECT_H
  
  #include "sysc/kernel/sc_attribute.h"
+ #include "sc_elab/elab_alloc.h"
  #include <iostream>
  
  #if defined(_MSC_VER) && !defined(SC_WIN_DLL_WARN)
***************
*** 164,169 ****
--- 165,187 ----
  
      virtual ~sc_object();
  
+     void* operator new(std::size_t sz)
+     {
+         void *rptr = ::operator new(sz);
+         // we don't know type of allocation yet, it will be filled later
+         sc_elab::trace_alloc_impl(rptr, false, nullptr, sz);
+         return rptr;
+     }
+ 
+     void* operator new[](std::size_t sz)
+     {
+         void *rptr = ::operator new(sz);
+         if (sz >= sizeof(sc_object)) {
+             sc_elab::trace_alloc_impl(rptr, true, nullptr, sz);
+         }
+         return rptr;
+     }
+ 
  protected:
      sc_object();
      sc_object(const char* nm);
diff -crBN systemc-3.0.1/src/sysc/kernel/sc_process.h systemc-3.0.1_patched/src/sysc/kernel/sc_process.h
*** systemc-3.0.1/src/sysc/kernel/sc_process.h	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/kernel/sc_process.h	2025-05-13 16:58:16.902308000 -0700
***************
*** 291,296 ****
--- 291,297 ----
      inline sc_curr_proc_kind proc_kind() const;
      sc_event& reset_event();
      sc_event& terminated_event();
+     const std::vector<const sc_event*>& get_static_events() {return m_static_events;}
  
    public:
      static inline sc_process_handle last_created_process_handle();
diff -crBN systemc-3.0.1/src/sysc/kernel/sc_reset.cpp systemc-3.0.1_patched/src/sysc/kernel/sc_reset.cpp
*** systemc-3.0.1/src/sysc/kernel/sc_reset.cpp	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/kernel/sc_reset.cpp	2025-05-13 16:58:16.905312000 -0700
***************
*** 220,229 ****
        case SC_THREAD_PROC_:
        case SC_METHOD_PROC_:
        case SC_CTHREAD_PROC_:
!         iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(port.get_interface());
!         if ( iface_p )
!             reset_signal_is( async, *iface_p, level );
!         else
              new sc_reset_finder( async, &port, level, process_p );
          break;
        default:
--- 220,231 ----
        case SC_THREAD_PROC_:
        case SC_METHOD_PROC_:
        case SC_CTHREAD_PROC_:
! 
! // SVC elaborator : Always use finders to keep ports
! //        iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(port.get_interface());
! //        if ( iface_p )
! //            reset_signal_is( async, *iface_p, level );
! //        else
              new sc_reset_finder( async, &port, level, process_p );
          break;
        default:
***************
*** 246,255 ****
        case SC_THREAD_PROC_:
        case SC_METHOD_PROC_:
        case SC_CTHREAD_PROC_:
!         iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(port.get_interface());
!         if ( iface_p )
!             reset_signal_is( async, *iface_p, level );
!         else
              new sc_reset_finder( async, &port, level, process_p );
          break;
        default:
--- 248,259 ----
        case SC_THREAD_PROC_:
        case SC_METHOD_PROC_:
        case SC_CTHREAD_PROC_:
! 
! // SVC elaborator : Always use finders to keep ports
! //        iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(port.get_interface());
! //        if ( iface_p )
! //            reset_signal_is( async, *iface_p, level );
! //        else
              new sc_reset_finder( async, &port, level, process_p );
          break;
        default:
diff -crBN systemc-3.0.1/src/sysc/kernel/sc_simcontext.cpp systemc-3.0.1_patched/src/sysc/kernel/sc_simcontext.cpp
*** systemc-3.0.1/src/sysc/kernel/sc_simcontext.cpp	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/kernel/sc_simcontext.cpp	2025-05-13 16:58:16.910327000 -0700
***************
*** 652,657 ****
--- 652,674 ----
  }
  
  void
+ sc_simcontext::sc_tool_elaboration()
+ {
+     if( m_elaboration_done || sim_status() != SC_SIM_OK ) {
+         return;
+     }
+ 
+     // Instantiate the method invocation module
+     // (not added to public object hierarchy)
+ 
+     m_method_invoker_p =
+         new sc_invoke_method("$$$$kernel_module$$$$_invoke_method" );
+ 
+     m_simulation_status = SC_BEFORE_END_OF_ELABORATION;
+     m_module_registry->construction_done();
+ }
+ 
+ void
  sc_simcontext::elaborate()
  {
      if( m_elaboration_done || sim_status() != SC_SIM_OK ) {
diff -crBN systemc-3.0.1/src/sysc/kernel/sc_simcontext.h systemc-3.0.1_patched/src/sysc/kernel/sc_simcontext.h
*** systemc-3.0.1/src/sysc/kernel/sc_simcontext.h	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/kernel/sc_simcontext.h	2025-05-13 16:58:16.914338000 -0700
***************
*** 243,248 ****
--- 243,251 ----
  
      sc_object_host* active_object();
  
+     void hierarchy_push(sc_object_host*);
+     sc_object_host* hierarchy_pop();
+     sc_object_host* hierarchy_curr() const;
      sc_object* first_object();
      sc_object* next_object();
      sc_object* find_object( const char* name );
***************
*** 321,326 ****
--- 324,330 ----
  
      sc_event& null_event();
  
+     void sc_tool_elaboration();
      void elaborate();
      void prepare_to_simulate();
      inline void initial_crunch( bool no_crunch );
***************
*** 331,340 ****
      void post_suspend() const;
  
  private:
-     void hierarchy_push(sc_object_host*);
-     sc_object_host* hierarchy_pop();
-     sc_object_host* hierarchy_curr() const;
- 
      void add_child_event( sc_event* );
      void add_child_object( sc_object* );
      void remove_child_event( sc_event* );
--- 335,340 ----
diff -crBN systemc-3.0.1/src/sysc/tracing/sc_vcd_trace.cpp systemc-3.0.1_patched/src/sysc/tracing/sc_vcd_trace.cpp
*** systemc-3.0.1/src/sysc/tracing/sc_vcd_trace.cpp	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/tracing/sc_vcd_trace.cpp	2025-05-13 16:58:16.919310000 -0700
***************
*** 1535,1541 ****
  SC_API sc_trace_file*
  sc_create_vcd_trace_file(const char * name)
  {
!     sc_trace_file * tf = new vcd_trace_file(name);
      return tf;
  }
  
--- 1535,1541 ----
  SC_API sc_trace_file*
  sc_create_vcd_trace_file(const char * name)
  {
!     sc_trace_file * tf = ::new vcd_trace_file(name);
      return tf;
  }
  
diff -crBN systemc-3.0.1/src/sysc/tracing/sc_wif_trace.cpp systemc-3.0.1_patched/src/sysc/tracing/sc_wif_trace.cpp
*** systemc-3.0.1/src/sysc/tracing/sc_wif_trace.cpp	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/sysc/tracing/sc_wif_trace.cpp	2025-05-13 16:58:16.925303000 -0700
***************
*** 1321,1327 ****
  SC_API sc_trace_file*
  sc_create_wif_trace_file(const char * name)
  {
!     sc_trace_file *tf = new wif_trace_file(name);
      return tf;
  }
  
--- 1321,1327 ----
  SC_API sc_trace_file*
  sc_create_wif_trace_file(const char * name)
  {
!     sc_trace_file *tf = ::new wif_trace_file(name);
      return tf;
  }
  
diff -crBN systemc-3.0.1/src/systemc systemc-3.0.1_patched/src/systemc
*** systemc-3.0.1/src/systemc	2024-10-15 06:47:45.000000000 -0700
--- systemc-3.0.1_patched/src/systemc	2025-05-13 16:58:16.929325000 -0700
***************
*** 76,81 ****
--- 76,84 ----
  #include "sysc/kernel/sc_module.h"
  #include "sysc/kernel/sc_process_handle.h"
  #include "sysc/kernel/sc_simcontext.h"
+ #include "sysc/kernel/sc_method_process.h"
+ #include "sysc/kernel/sc_thread_process.h"
+ #include "sysc/kernel/sc_cthread_process.h"
  #include "sysc/kernel/sc_ver.h"
  
  #include "sysc/communication/sc_buffer.h"
***************
*** 134,139 ****
--- 137,144 ----
  #include "sysc/utils/sc_vector.h"
  #include "sysc/utils/sc_string.h"
  
+ #include "sc_elab/elab_alloc.h"
+ 
  #endif // !defined(SYSTEMC_INCLUDED)
  
  #ifdef SC_INCLUDE_EXTRA_STD_HEADERS
