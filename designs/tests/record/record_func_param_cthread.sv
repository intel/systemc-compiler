//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.25
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic signed [31:0] t1;
logic signed [31:0] t1a;
logic signed [31:0] t2;
logic signed [31:0] t2a;
logic signed [31:0] t0;
logic signed [31:0] t3;
logic signed [31:0] t4;
logic signed [31:0] t5;
logic signed [31:0] t6;
logic signed [31:0] t7;

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_ref (test_func_param_cthread.cpp:103:5) 

// Thread-local variables
logic signed [31:0] s_b;
logic signed [31:0] s_b_next;
logic signed [31:0] t0_next;
logic record_fcall_ref_PROC_STATE;
logic record_fcall_ref_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_fcall_ref_comb     // test_func_param_cthread.cpp:103:5
    record_fcall_ref_func;
end
function void record_fcall_ref_func;
    logic s_a;
    s_b_next = s_b;
    t0_next = t0;
    record_fcall_ref_PROC_STATE_next = record_fcall_ref_PROC_STATE;
    
    case (record_fcall_ref_PROC_STATE)
        0: begin
            s_b_next = 1;
            // Call f1() begin
            s_b_next = 2;
            // Call f1() end
            record_fcall_ref_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:111:13;
        end
        1: begin
            t0_next = s_b_next;
            s_b_next = 1;
            // Call f1() begin
            s_b_next = 2;
            // Call f1() end
            record_fcall_ref_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:111:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_ref_ff
    if ( ~rstn ) begin
        logic s_a;
        record_fcall_ref_PROC_STATE <= '0;    // test_func_param_cthread.cpp:106:9;
    end
    else begin
        s_b <= s_b_next;
        t0 <= t0_next;
        record_fcall_ref_PROC_STATE <= record_fcall_ref_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_val_reg (test_func_param_cthread.cpp:119:5) 

// Thread-local variables
logic s_a0;
logic s_a_next;
logic signed [31:0] s_b0;
logic signed [31:0] s_b_next0;
logic signed [31:0] t1_next;

// Next-state combinational logic
always_comb begin : record_fcall_val_reg_comb     // test_func_param_cthread.cpp:119:5
    record_fcall_val_reg_func;
end
function void record_fcall_val_reg_func;
    logic par_a;
    integer par_b;
    logic b;
    s_a_next = s_a0;
    s_b_next0 = s_b0;
    t1_next = t1;
    par_a = s_a_next; par_b = s_b_next0;
    // Call f2() begin
    b = par_a;
    par_b = 2;
    t1_next = b;
    // Call f2() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_val_reg_ff
    if ( ~rstn ) begin
        s_b0 <= 1;
    end
    else begin
        s_a0 <= s_a_next;
        s_b0 <= s_b_next0;
        t1 <= t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_val_comb (test_func_param_cthread.cpp:132:5) 

// Thread-local variables
logic signed [31:0] t1a_next;

// Next-state combinational logic
always_comb begin : record_fcall_val_comb_comb     // test_func_param_cthread.cpp:132:5
    record_fcall_val_comb_func;
end
function void record_fcall_val_comb_func;
    logic s_a;
    integer s_b_1;
    logic par_a;
    integer par_b;
    logic b;
    t1a_next = t1a;
    s_b_1 = 1;
    par_a = s_a; par_b = s_b_1;
    // Call f2a() begin
    b = par_a;
    par_b = 2;
    t1a_next = b;
    // Call f2a() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_val_comb_ff
    if ( ~rstn ) begin
    end
    else begin
        t1a <= t1a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_two_val (test_func_param_cthread.cpp:144:5) 

// Thread-local variables
logic s_a1;
logic s_a_next0;
logic signed [31:0] s_b1;
logic signed [31:0] s_b_next1;
logic signed [31:0] t2_next;

// Next-state combinational logic
always_comb begin : record_fcall_two_val_comb     // test_func_param_cthread.cpp:144:5
    record_fcall_two_val_func;
end
function void record_fcall_two_val_func;
    logic r_a;
    integer r_b;
    logic par1_a;
    integer par1_b;
    logic par2_a;
    integer par2_b;
    logic b;
    s_a_next0 = s_a1;
    s_b_next1 = s_b1;
    t2_next = t2;
    par1_a = s_a_next0; par1_b = s_b_next1; par2_a = r_a; par2_b = r_b;
    // Call f3() begin
    b = par1_a || par2_a;
    par1_a = |2'(b + 2'sd1);
    par2_a = |2'(b - 2'sd1);
    t2_next = par2_a;
    // Call f3() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_two_val_ff
    if ( ~rstn ) begin
    end
    else begin
        s_a1 <= s_a_next0;
        s_b1 <= s_b_next1;
        t2 <= t2_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_two_val2 (test_func_param_cthread.cpp:157:5) 

// Thread-local variables
logic signed [31:0] gr_b;
logic signed [31:0] gr_b_next;
logic signed [31:0] t2a_next;
logic gr_a;

// Next-state combinational logic
always_comb begin : record_fcall_two_val2_comb     // test_func_param_cthread.cpp:157:5
    record_fcall_two_val2_func;
end
function void record_fcall_two_val2_func;
    logic s_a;
    integer s_b_1;
    logic par1_a;
    integer par1_b;
    logic par2_a;
    integer par2_b;
    logic b;
    gr_b_next = gr_b;
    t2a_next = t2a;
    gr_a = 1;
    par1_a = gr_a; par1_b = gr_b_next; par2_a = s_a; par2_b = s_b_1;
    // Call f3a() begin
    b = 1;
    par1_a = |2'(b + 2'sd1);
    par2_a = |2'(b - 2'sd1);
    t2a_next = par2_a;
    // Call f3a() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_two_val2_ff
    if ( ~rstn ) begin
    end
    else begin
        gr_b <= gr_b_next;
        t2a <= t2a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_two_ref (test_func_param_cthread.cpp:170:5) 

// Thread-local variables
logic s_a2;
logic s_a_next1;
logic signed [31:0] t3_next;
logic record_fcall_two_ref_PROC_STATE;
logic record_fcall_two_ref_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_fcall_two_ref_comb     // test_func_param_cthread.cpp:170:5
    record_fcall_two_ref_func;
end
function void record_fcall_two_ref_func;
    integer s_b_1;
    logic r_a;
    integer r_b;
    logic b;
    s_a_next1 = s_a2;
    t3_next = t3;
    record_fcall_two_ref_PROC_STATE_next = record_fcall_two_ref_PROC_STATE;
    
    case (record_fcall_two_ref_PROC_STATE)
        0: begin
            record_fcall_two_ref_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:175:13;
        end
        1: begin
            // Call f4() begin
            b = s_a_next1 && r_a;
            s_a_next1 = b;
            // Call f4() end
            t3_next = s_a_next1 + r_a;
            record_fcall_two_ref_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:175:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_two_ref_ff
    if ( ~rstn ) begin
        record_fcall_two_ref_PROC_STATE <= '0;    // test_func_param_cthread.cpp:172:9;
    end
    else begin
        s_a2 <= s_a_next1;
        t3 <= t3_next;
        record_fcall_two_ref_PROC_STATE <= record_fcall_two_ref_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_two_ref2 (test_func_param_cthread.cpp:185:5) 

// Thread-local variables
logic gs_a;
logic gs_a_next;
logic r_a0;
logic r_a_next;
logic signed [31:0] t4_next;

// Next-state combinational logic
always_comb begin : record_fcall_two_ref2_comb     // test_func_param_cthread.cpp:185:5
    record_fcall_two_ref2_func;
end
function void record_fcall_two_ref2_func;
    integer r_b;
    logic b;
    gs_a_next = gs_a;
    r_a_next = r_a0;
    t4_next = t4;
    r_b = 4;
    // Call f4() begin
    b = gs_a_next && r_a_next;
    gs_a_next = b;
    // Call f4() end
    t4_next = r_b;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_two_ref2_ff
    if ( ~rstn ) begin
        integer r_b;
    end
    else begin
        gs_a <= gs_a_next;
        r_a0 <= r_a_next;
        t4 <= t4_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_const_ref1 (test_func_param_cthread.cpp:205:5) 

// Thread-local variables
logic t_a;
logic t_a_next;
logic signed [31:0] t_b;
logic signed [31:0] t_b_next;
logic r_a1;
logic r_a_next0;
logic signed [31:0] r_b0;
logic signed [31:0] r_b_next;
logic signed [31:0] t5_next;
logic record_fcall_const_ref1_PROC_STATE;
logic record_fcall_const_ref1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_fcall_const_ref1_comb     // test_func_param_cthread.cpp:205:5
    record_fcall_const_ref1_func;
end
function void record_fcall_const_ref1_func;
    logic TMP_0;
    logic b;
    r_a_next0 = r_a1;
    r_b_next = r_b0;
    t5_next = t5;
    t_a_next = t_a;
    t_b_next = t_b;
    record_fcall_const_ref1_PROC_STATE_next = record_fcall_const_ref1_PROC_STATE;
    
    case (record_fcall_const_ref1_PROC_STATE)
        0: begin
            // Call cref_copy() begin
            r_a_next0 = t_a_next; r_b_next = t_b_next;
            // Call cref_copy() end
            r_a_next0 = t_a_next; r_b_next = t_b_next;
            record_fcall_const_ref1_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:212:13;
        end
        1: begin
            // Call cref_cmp() begin
            TMP_0 = r_a_next0 == t_a_next && r_b_next == t_b_next;
            // Call cref_cmp() end
            b = TMP_0;
            t5_next = b;
            // Call cref_copy() begin
            r_a_next0 = t_a_next; r_b_next = t_b_next;
            // Call cref_copy() end
            r_a_next0 = t_a_next; r_b_next = t_b_next;
            record_fcall_const_ref1_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:212:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_const_ref1_ff
    if ( ~rstn ) begin
        record_fcall_const_ref1_PROC_STATE <= '0;    // test_func_param_cthread.cpp:208:9;
    end
    else begin
        t_a <= t_a_next;
        t_b <= t_b_next;
        r_a1 <= r_a_next0;
        r_b0 <= r_b_next;
        t5 <= t5_next;
        record_fcall_const_ref1_PROC_STATE <= record_fcall_const_ref1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_const_ref2 (test_func_param_cthread.cpp:224:5) 

// Thread-local variables
logic r_a2;
logic r_a_next1;
logic t_a0;
logic t_a_next0;
logic signed [31:0] t_b0;
logic signed [31:0] t_b_next0;
logic signed [31:0] r_b1;
logic signed [31:0] r_b_next0;
logic signed [31:0] t6_next;
logic record_fcall_const_ref2_PROC_STATE;
logic record_fcall_const_ref2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_fcall_const_ref2_comb     // test_func_param_cthread.cpp:224:5
    record_fcall_const_ref2_func;
end
function void record_fcall_const_ref2_func;
    logic TMP_0;
    logic b;
    r_a_next1 = r_a2;
    r_b_next0 = r_b1;
    t6_next = t6;
    t_a_next0 = t_a0;
    t_b_next0 = t_b0;
    record_fcall_const_ref2_PROC_STATE_next = record_fcall_const_ref2_PROC_STATE;
    
    case (record_fcall_const_ref2_PROC_STATE)
        0: begin
            t_a_next0 = 1'd1;
            record_fcall_const_ref2_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:230:13;
        end
        1: begin
            // Call cref_cmp() begin
            TMP_0 = r_a_next1 == t_a_next0 && r_b_next0 == t_b_next0;
            // Call cref_cmp() end
            b = TMP_0;
            t6_next = b;
            t_a_next0 = 1'd1;
            record_fcall_const_ref2_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:230:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_const_ref2_ff
    if ( ~rstn ) begin
        record_fcall_const_ref2_PROC_STATE <= '0;    // test_func_param_cthread.cpp:227:9;
    end
    else begin
        r_a2 <= r_a_next1;
        t_a0 <= t_a_next0;
        t_b0 <= t_b_next0;
        r_b1 <= r_b_next0;
        t6 <= t6_next;
        record_fcall_const_ref2_PROC_STATE <= record_fcall_const_ref2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_const_ref3 (test_func_param_cthread.cpp:243:5) 

// Thread-local variables
logic r_a3;
logic r_a_next2;
logic signed [31:0] r_b2;
logic signed [31:0] r_b_next1;
logic signed [31:0] t7_next;
logic t_a1;
logic t_a_next1;
logic signed [31:0] t_b1;
logic signed [31:0] t_b_next1;
logic [1:0] record_fcall_const_ref3_PROC_STATE;
logic [1:0] record_fcall_const_ref3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_fcall_const_ref3_comb     // test_func_param_cthread.cpp:243:5
    record_fcall_const_ref3_func;
end
function void record_fcall_const_ref3_func;
    integer TMP_0;
    integer res;
    integer i;
    integer TMP_2;
    r_a_next2 = r_a3;
    r_b_next1 = r_b2;
    t7_next = t7;
    t_a_next1 = t_a1;
    t_b_next1 = t_b1;
    record_fcall_const_ref3_PROC_STATE_next = record_fcall_const_ref3_PROC_STATE;
    
    case (record_fcall_const_ref3_PROC_STATE)
        0: begin
            // Call cref_sum() begin
            record_fcall_const_ref3_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:237:9;
            // Call cref_sum() end
        end
        1: begin
            // Call cref_sum() begin
            res = t_a_next1 + t_b_next1;
            TMP_0 = res;
            // Call cref_sum() end
            i = TMP_0;
            // Call cref_sum() begin
            record_fcall_const_ref3_PROC_STATE_next = 2; return;    // test_func_param_cthread.cpp:237:9;
            // Call cref_sum() end
        end
        2: begin
            // Call cref_sum() begin
            res = r_a_next2 + r_b_next1;
            TMP_2 = res;
            // Call cref_sum() end
            i = TMP_2;
            t7_next = i;
            // Call cref_sum() begin
            record_fcall_const_ref3_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:237:9;
            // Call cref_sum() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_const_ref3_ff
    if ( ~rstn ) begin
        record_fcall_const_ref3_PROC_STATE <= '0;    // test_func_param_cthread.cpp:246:9;
    end
    else begin
        r_a3 <= r_a_next2;
        r_b2 <= r_b_next1;
        t7 <= t7_next;
        t_a1 <= t_a_next1;
        t_b1 <= t_b_next1;
        record_fcall_const_ref3_PROC_STATE <= record_fcall_const_ref3_PROC_STATE_next;
    end
end

endmodule


