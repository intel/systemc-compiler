//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a"
(
    input logic clk,
    output logic [3:0] nco_out[3]
);

// Variables generated for SystemC signals
logic rstn;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;

//------------------------------------------------------------------------------
// Clocked THREAD: func_call_in_reset (test_member_func_cthread.cpp:45:5) 

// Thread-local variables
logic signed [31:0] t1_next;

// Next-state combinational logic
always_comb begin : func_call_in_reset_comb     // test_member_func_cthread.cpp:45:5
    func_call_in_reset_func;
end
function void func_call_in_reset_func;
    integer par_1;
    integer c_1;
    t1_next = t1;
    par_1 = 1;
    // Call g() begin
    c_1 = par_1;
    t1_next = c_1;
    // Call g() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : func_call_in_reset_ff
    if ( ~rstn ) begin
        logic par;
        logic c;
        par = 1;
        // Call f() begin
        c = par;
        t0 <= c;
        // Call f() end
    end
    else begin
        t1 <= t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: call_in_reset (test_member_func_cthread.cpp:79:5) 

// Thread-local variables
logic [3:0] nc_nco_acc;
logic [3:0] nc_nco_acc_next;
logic signed [31:0] t2_next;

// Next-state combinational logic
always_comb begin : call_in_reset_comb     // test_member_func_cthread.cpp:79:5
    call_in_reset_func;
end
function void call_in_reset_func;
    logic [3:0] i;
    nc_nco_acc_next = nc_nco_acc;
    t2_next = t2;
    i = 0;
    t2_next = i;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : call_in_reset_ff
    if ( ~rstn ) begin
        logic [3:0] val;
        val = 0;
        // Call acc_init() begin
        nc_nco_acc <= val;
        // Call acc_init() end
    end
    else begin
        nc_nco_acc <= nc_nco_acc_next;
        t2 <= t2_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: arr_call_in_reset (test_member_func_cthread.cpp:95:5) 

// Thread-local variables
logic [3:0] ncc_nco_acc[3];
logic [3:0] ncc_nco_acc_next[3];
logic [3:0] nco_out_next[3];

// Next-state combinational logic
always_comb begin : arr_call_in_reset_comb     // test_member_func_cthread.cpp:95:5
    arr_call_in_reset_func;
end
function void arr_call_in_reset_func;
    ncc_nco_acc_next = ncc_nco_acc;
    nco_out_next = nco_out;
    for (integer i_1 = 0; i_1 < 3; i_1++)
    begin
        nco_out_next[i_1] = 0 >>> 2;
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : arr_call_in_reset_ff
    if ( ~rstn ) begin
        logic [3:0] val;
        for (integer i = 0; i < 3; i++)
        begin
            val = 0;
            // Call acc_init() begin
            ncc_nco_acc[i] <= val;
            // Call acc_init() end
            nco_out[i] <= 0;
        end
    end
    else begin
        ncc_nco_acc <= ncc_nco_acc_next;
        nco_out <= nco_out_next;
    end
end

endmodule


