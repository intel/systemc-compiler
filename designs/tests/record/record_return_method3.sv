//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.6
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic s_a;
logic signed [31:0] s_b;
logic t_a;
logic signed [31:0] t_b;
logic [9:0] u;
logic [31:0] t1;
logic [31:0] t2;
logic z_a;
logic signed [31:0] z_b;
logic t3_a;
logic signed [31:0] t3_b;
logic [31:0] t4;

//------------------------------------------------------------------------------
// Method process: sig_ref_meth1 (test_return_method3.cpp:81:5) 

always_comb 
begin : sig_ref_meth1     // test_return_method3.cpp:81:5
    logic r0_a;
    integer r0_b;
    logic [9:0] TMP_3;
    integer i;
    integer TMP_5;
    integer par;
    r0_a = t_a; r0_b = t_b;
    // Call read_uint_ref() begin
    TMP_3 = u;
    // Call read_uint_ref() end
    t1 = r0_b + t_b + TMP_3;
    if (t_a)
    begin
        i = t_b + 1;
        par = t_b;
        // Call f() begin
        TMP_5 = par + 1;
        // Call f() end
        i = TMP_5;
        i = s_a ? t_b : s_b;
        t1 = i;
    end
end

//------------------------------------------------------------------------------
// Method process: sig_ref_meth2 (test_return_method3.cpp:103:5) 

always_comb 
begin : sig_ref_meth2     // test_return_method3.cpp:103:5
    logic r0_a;
    integer r0_b;
    r0_a = t_a; r0_b = t_b;
    t2 = r0_b + t_b;
    r0_a = r0_a; r0_b = r0_b;
    r0_a = t_a; r0_b = t_b;
end

//------------------------------------------------------------------------------
// Method process: sig_ref_meth3 (test_return_method3.cpp:120:5) 

always_comb 
begin : sig_ref_meth3     // test_return_method3.cpp:120:5
    // Call put_rec_ref() begin
    z_a = t_a; z_b = t_b;
    // Call put_rec_ref() end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sig_ref_thrd1 (test_return_method3.cpp:142:5) 

// Thread-local variables
logic t3_a_next;
logic signed [31:0] t3_b_next;

// Next-state combinational logic
always_comb begin : sig_ref_thrd1_comb     // test_return_method3.cpp:142:5
    sig_ref_thrd1_func;
end
function void sig_ref_thrd1_func;
    logic TMP_0_a;
    integer TMP_0_b;
    logic r1_a;
    integer r1_b;
    logic r2_a;
    integer r2_b;
    logic TMP_3_a;
    integer TMP_3_b;
    logic r3_a;
    integer r3_b;
    logic r4_a;
    integer r4_b;
    t3_a_next = t3_a;
    t3_b_next = t3_b;
    // Call read_rec_val() begin
    TMP_3_a = s_a; TMP_3_b = s_b;
    // Call read_rec_val() end
    r3_a = TMP_3_a; r3_b = TMP_3_b;
    r4_a = t_a; r4_b = t_b;
    if (r4_a == s_a)
    begin
        r3_a = s_a; r3_b = s_b;
        t3_a_next = r3_a; t3_b_next = r3_b;
        t3_a_next = r4_a; t3_b_next = r4_b;
        t3_a_next = s_a; t3_b_next = s_b;
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : sig_ref_thrd1_ff
    if ( ~nrst ) begin
        logic TMP_0_a;
        integer TMP_0_b;
        logic r1_a;
        integer r1_b;
        logic r2_a;
        integer r2_b;
        // Call read_rec_val() begin
        TMP_0_a = s_a; TMP_0_b = s_b;
        // Call read_rec_val() end
        r1_a = TMP_0_a; r1_b = TMP_0_b;
        r2_a = t_a; r2_b = t_b;
    end
    else begin
        t3_a <= t3_a_next;
        t3_b <= t3_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sig_ref_thrd2 (test_return_method3.cpp:162:5) 

// Thread-local variables
logic signed [31:0] r1_b0;
logic signed [31:0] r1_b_next;
logic signed [31:0] r0_b0;
logic signed [31:0] r0_b_next;
logic [31:0] t4_next;
logic sig_ref_thrd2_PROC_STATE;
logic sig_ref_thrd2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sig_ref_thrd2_comb     // test_return_method3.cpp:162:5
    sig_ref_thrd2_func;
end
function void sig_ref_thrd2_func;
    logic r0_a;
    logic r1_a;
    r0_b_next = r0_b0;
    r1_b_next = r1_b0;
    t4_next = t4;
    sig_ref_thrd2_PROC_STATE_next = sig_ref_thrd2_PROC_STATE;
    
    case (sig_ref_thrd2_PROC_STATE)
        0: begin
            r1_a = t_a; r1_b_next = t_b;
            r0_a = s_a; r0_b_next = s_b;
            sig_ref_thrd2_PROC_STATE_next = 1; return;    // test_return_method3.cpp:170:13;
        end
        1: begin
            t4_next = r0_b_next + r1_b_next + s_b;
            r1_a = t_a; r1_b_next = t_b;
            r0_a = s_a; r0_b_next = s_b;
            sig_ref_thrd2_PROC_STATE_next = 1; return;    // test_return_method3.cpp:170:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : sig_ref_thrd2_ff
    if ( ~nrst ) begin
        logic r0_a;
        sig_ref_thrd2_PROC_STATE <= 0;    // test_return_method3.cpp:165:9;
    end
    else begin
        r1_b0 <= r1_b_next;
        r0_b0 <= r0_b_next;
        t4 <= t4_next;
        sig_ref_thrd2_PROC_STATE <= sig_ref_thrd2_PROC_STATE_next;
    end
end

endmodule


