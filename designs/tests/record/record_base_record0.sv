//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.17
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] sig;
logic signed [31:0] t0;
logic signed [31:0] t1;

//------------------------------------------------------------------------------
// Method process: call_record1 (test_base_record0.cpp:70:5) 

always_comb 
begin : call_record1     // test_base_record0.cpp:70:5
    integer par;
    logic [7:0] s_bits;
    integer s_m;
    integer TMP_0;
    integer s_par;
    integer s_l;
    integer s_k;
    integer unsigned s_par_1;
    integer s_i;
    integer unsigned s_par_2;
    integer s_i_1;
    integer unsigned TMP_2;
    integer unsigned s_par_3;
    logic k;
    par = sig;
    s_bits = par;
    // Call Simple() begin
    s_par = par + s_m;
    // Call incrVal() begin
    TMP_0 = 32'(s_par + 1);
    // Call incrVal() end
    s_l = TMP_0;
    s_k = s_l + s_m + par;
    s_par_1 = s_l;
    // Call incrBits() begin
    s_i = 41;
    s_bits = s_bits + (s_par_1 + s_i);
    // Call incrBits() end
    s_par_1 = par;
    // Call incrBits() begin
    s_i = 41;
    s_bits = s_bits + (s_par_1 + s_i);
    // Call incrBits() end
    s_par_1 = s_m;
    // Call incrBits() begin
    s_i = 41;
    s_bits = s_bits + (s_par_1 + s_i);
    // Call incrBits() end
    s_par_2 = s_k;
    // Call setBits() begin
    s_i_1 = 41;
    s_bits = s_par_2 + s_i_1 + s_m;
    s_par_3 = s_par_2 + s_i_1 + s_m;
    // Call incrVal() begin
    TMP_2 = 32'(s_par_3 + 1);
    // Call incrVal() end
    s_bits = TMP_2;
    // Call setBits() end
    // Call Simple() end
    s_bits = 43;
    k = 1'(s_bits[3]);
    t0 = k;
end

//------------------------------------------------------------------------------
// Clocked THREAD: call_record2 (test_base_record0.cpp:95:5) 

// Thread-local variables
logic [14:0] r_bits;
logic [14:0] r_bits_next;
logic signed [31:0] t1_next;

// Next-state combinational logic
always_comb begin : call_record2_comb     // test_base_record0.cpp:95:5
    call_record2_func;
end
function void call_record2_func;
    logic [14:0] bts;
    logic [14:0] r_l;
    integer par;
    logic [7:0] t_bits;
    integer t_m;
    integer TMP_2;
    integer t_par;
    integer t_l;
    integer t_k;
    integer unsigned t_par_1;
    integer t_i;
    integer unsigned t_par_2;
    integer t_i_1;
    integer unsigned TMP_4;
    integer unsigned t_par_3;
    logic [7:0] k;
    r_bits_next = r_bits;
    t1_next = t1;
    par = sig;
    t_bits = par;
    // Call Simple() begin
    t_par = par + t_m;
    // Call incrVal() begin
    TMP_2 = 32'(t_par + 1);
    // Call incrVal() end
    t_l = TMP_2;
    t_k = t_l + t_m + par;
    t_par_1 = t_l;
    // Call incrBits() begin
    t_i = 41;
    t_bits = t_bits + (t_par_1 + t_i);
    // Call incrBits() end
    t_par_1 = par;
    // Call incrBits() begin
    t_i = 41;
    t_bits = t_bits + (t_par_1 + t_i);
    // Call incrBits() end
    t_par_1 = t_m;
    // Call incrBits() begin
    t_i = 41;
    t_bits = t_bits + (t_par_1 + t_i);
    // Call incrBits() end
    t_par_2 = t_k;
    // Call setBits() begin
    t_i_1 = 41;
    t_bits = t_par_2 + t_i_1 + t_m;
    t_par_3 = t_par_2 + t_i_1 + t_m;
    // Call incrVal() begin
    TMP_4 = 32'(t_par_3 + 1);
    // Call incrVal() end
    t_bits = TMP_4;
    // Call setBits() end
    // Call Simple() end
    k = t_bits;
    k = r_bits_next * 2;
    t1_next = k;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : call_record2_ff
    if ( ~nrst ) begin
        logic [14:0] bts;
        logic [14:0] r_l;
        bts = 12;
        r_bits <= bts;
        // Call Simple_() begin
        r_l = 13;
        // Call Simple_() end
    end
    else begin
        r_bits <= r_bits_next;
        t1 <= t1_next;
    end
end

endmodule


