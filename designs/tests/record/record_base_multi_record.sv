//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.21
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] sig;

//------------------------------------------------------------------------------
// Method process: base_record1 (test_base_multi_record.cpp:84:5) 

always_comb 
begin : base_record1     // test_base_multi_record.cpp:84:5
    integer s_a;
    integer s_b;
    integer unsigned s_c;
    logic [3:0] s_d;
    integer l;
    integer TMP_0;
    integer TMP_1;
    integer TMP_2;
    integer unsigned TMP_3;
    integer unsigned TMP_4;
    integer unsigned TMP_5;
    integer unsigned TMP_6;
    s_a = sig;
    s_b = sig;
    s_c = sig;
    s_d = 0;
    // Call getB1() begin
    TMP_0 = s_b;
    // Call getB1() end
    l = TMP_0;
    // Call getB2() begin
    // Call getB() begin
    TMP_2 = s_b;
    // Call getB() end
    TMP_1 = TMP_2;
    // Call getB2() end
    l = TMP_1;
    s_b = l;
    l = s_b;
    s_b = s_b;
    s_d = s_d;
    s_c = sig;
    // Call getC() begin
    // Call getC() begin
    TMP_4 = s_c;
    // Call getC() end
    TMP_3 = TMP_4;
    // Call getC() end
    l = TMP_3;
    // Call getC() begin
    // Call getC() begin
    TMP_6 = s_c;
    // Call getC() end
    TMP_5 = TMP_6;
    // Call getC() end
    l = TMP_5;
    s_c = s_c;
    // Call setC() begin
    s_c = s_c - 1;
    // Call setC() end
end

//------------------------------------------------------------------------------
// Clocked THREAD: base_record2 (test_base_multi_record.cpp:106:5) 

// Thread-local variables
logic signed [31:0] ms_b;
logic signed [31:0] ms_b_next;
logic signed [31:0] ls_b;
logic signed [31:0] ls_b_next;
logic [31:0] ms_c;
logic [31:0] ms_c_next;
logic base_record2_PROC_STATE;
logic base_record2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : base_record2_comb     // test_base_multi_record.cpp:106:5
    base_record2_func;
end
function void base_record2_func;
    integer par;
    integer unsigned ls_c;
    integer unsigned l;
    integer TMP_0;
    integer par_1;
    integer TMP_2;
    ls_b_next = ls_b;
    ms_b_next = ms_b;
    ms_c_next = ms_c;
    base_record2_PROC_STATE_next = base_record2_PROC_STATE;
    
    case (base_record2_PROC_STATE)
        0: begin
            // Call getB1() begin
            TMP_0 = ms_b_next;
            // Call getB1() end
            l = TMP_0 + 43;
            par_1 = sig;
            // Call setB() begin
            ms_b_next = par_1 + 1;
            // Call setB() end
            base_record2_PROC_STATE_next = 1; return;    // test_base_multi_record.cpp:116:13;
        end
        1: begin
            l = ms_c_next;
            par_1 = ls_b_next;
            // Call setB() begin
            ms_b_next = par_1 + 1;
            // Call setB() end
            // Call setC() begin
            ls_c = l - 1;
            // Call setC() end
            // Call getB1() begin
            TMP_2 = ms_b_next;
            // Call getB1() end
            l = TMP_2 + 43;
            par_1 = sig;
            // Call setB() begin
            ms_b_next = par_1 + 1;
            // Call setB() end
            base_record2_PROC_STATE_next = 1; return;    // test_base_multi_record.cpp:116:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : base_record2_ff
    if ( ~nrst ) begin
        integer par;
        integer ls_a;
        integer unsigned ls_c;
        logic [3:0] ls_d;
        par = 43;
        ls_a = par;
        ls_b <= par;
        ls_c = par;
        ls_d = 0;
        base_record2_PROC_STATE <= 0;    // test_base_multi_record.cpp:109:9;
    end
    else begin
        ms_b <= ms_b_next;
        ls_b <= ls_b_next;
        ms_c <= ms_c_next;
        base_record2_PROC_STATE <= base_record2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: base_record3 (test_base_multi_record.cpp:124:5) 

// Thread-local variables
logic [7:0] ll;
logic [7:0] ll_next;
logic [31:0] lt_c;
logic [31:0] lt_c_next;
logic base_record3_PROC_STATE;
logic base_record3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : base_record3_comb     // test_base_multi_record.cpp:124:5
    base_record3_func;
end
function void base_record3_func;
    integer par;
    integer lt_a;
    integer lt_b;
    logic [3:0] lt_d;
    integer TMP_0;
    integer unsigned TMP_1;
    integer unsigned TMP_2;
    integer l;
    integer lt_par;
    integer TMP_4;
    ll_next = ll;
    lt_c_next = lt_c;
    base_record3_PROC_STATE_next = base_record3_PROC_STATE;
    
    case (base_record3_PROC_STATE)
        0: begin
            par = sig * 3;
            lt_a = par;
            lt_b = par;
            lt_c_next = par;
            lt_d = 0;
            // Call getB1() begin
            TMP_0 = lt_b;
            // Call getB1() end
            ll_next = ll_next + TMP_0;
            base_record3_PROC_STATE_next = 1; return;    // test_base_multi_record.cpp:133:13;
        end
        1: begin
            // Call getC() begin
            // Call getC() begin
            TMP_2 = lt_c_next;
            // Call getC() end
            TMP_1 = TMP_2;
            // Call getC() end
            l = TMP_1;
            lt_par = ll_next + l;
            // Call setB() begin
            lt_b = lt_par + 1;
            // Call setB() end
            par = sig * 3;
            lt_a = par;
            lt_b = par;
            lt_c_next = par;
            lt_d = 0;
            // Call getB1() begin
            TMP_4 = lt_b;
            // Call getB1() end
            ll_next = ll_next + TMP_4;
            base_record3_PROC_STATE_next = 1; return;    // test_base_multi_record.cpp:133:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : base_record3_ff
    if ( ~nrst ) begin
        ll <= 0;
        base_record3_PROC_STATE <= 0;    // test_base_multi_record.cpp:127:9;
    end
    else begin
        ll <= ll_next;
        lt_c <= lt_c_next;
        base_record3_PROC_STATE <= base_record3_PROC_STATE_next;
    end
end

endmodule


