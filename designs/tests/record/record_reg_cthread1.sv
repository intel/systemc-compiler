//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;
logic signed [31:0] t3;
logic signed [31:0] t6;
logic signed [31:0] t7;

//------------------------------------------------------------------------------
// Clocked THREAD: record_assign (test_reg_cthread1.cpp:56:5) 

// Thread-local variables
logic signed [31:0] s_cos;
logic signed [31:0] s_cos_next;
logic signed [31:0] r_sin;
logic signed [31:0] r_sin_next;
logic signed [31:0] t0_next;
logic record_assign_PROC_STATE;
logic record_assign_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_assign_comb     // test_reg_cthread1.cpp:56:5
    record_assign_func;
end
function void record_assign_func;
    integer s_sin;
    integer r_cos;
    integer b;
    r_sin_next = r_sin;
    s_cos_next = s_cos;
    t0_next = t0;
    record_assign_PROC_STATE_next = record_assign_PROC_STATE;
    
    case (record_assign_PROC_STATE)
        0: begin
            s_sin = 1;
            r_sin_next = s_sin; r_cos = s_cos_next;
            record_assign_PROC_STATE_next = 1; return;    // test_reg_cthread1.cpp:63:13;
        end
        1: begin
            b = r_sin_next;
            t0_next = b;
            s_sin = 1;
            r_sin_next = s_sin; r_cos = s_cos_next;
            record_assign_PROC_STATE_next = 1; return;    // test_reg_cthread1.cpp:63:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_assign_ff
    if ( ~rstn ) begin
        integer s_sin;
        s_sin = 1;
        s_cos <= 2;
        record_assign_PROC_STATE <= 0;    // test_reg_cthread1.cpp:58:9;
    end
    else begin
        s_cos <= s_cos_next;
        r_sin <= r_sin_next;
        t0 <= t0_next;
        record_assign_PROC_STATE <= record_assign_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_usedef_assign (test_reg_cthread1.cpp:71:5) 

// Thread-local variables
logic signed [31:0] r_sin0;
logic signed [31:0] r_sin_next0;
logic signed [31:0] t1_next;
logic record_usedef_assign_PROC_STATE;
logic record_usedef_assign_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_usedef_assign_comb     // test_reg_cthread1.cpp:71:5
    record_usedef_assign_func;
end
function void record_usedef_assign_func;
    integer r_cos;
    integer i;
    r_sin_next0 = r_sin0;
    t1_next = t1;
    record_usedef_assign_PROC_STATE_next = record_usedef_assign_PROC_STATE;
    
    case (record_usedef_assign_PROC_STATE)
        0: begin
            r_sin_next0 = 1;
            r_cos = 2;
            record_usedef_assign_PROC_STATE_next = 1; return;    // test_reg_cthread1.cpp:76:13;
        end
        1: begin
            i = r_sin_next0;
            t1_next = i;
            r_sin_next0 = 1;
            r_cos = 2;
            record_usedef_assign_PROC_STATE_next = 1; return;    // test_reg_cthread1.cpp:76:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_usedef_assign_ff
    if ( ~rstn ) begin
        record_usedef_assign_PROC_STATE <= 0;    // test_reg_cthread1.cpp:72:9;
    end
    else begin
        r_sin0 <= r_sin_next0;
        t1 <= t1_next;
        record_usedef_assign_PROC_STATE <= record_usedef_assign_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_glob_reg (test_reg_cthread1.cpp:86:5) 

// Thread-local variables
logic signed [31:0] gr_sin;
logic signed [31:0] gr_sin_next;
logic signed [31:0] t2_next;
logic record_glob_reg_PROC_STATE;
logic record_glob_reg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_glob_reg_comb     // test_reg_cthread1.cpp:86:5
    record_glob_reg_func;
end
function void record_glob_reg_func;
    integer b;
    gr_sin_next = gr_sin;
    t2_next = t2;
    record_glob_reg_PROC_STATE_next = record_glob_reg_PROC_STATE;
    
    case (record_glob_reg_PROC_STATE)
        0: begin
            gr_sin_next = 1;
            record_glob_reg_PROC_STATE_next = 1; return;    // test_reg_cthread1.cpp:91:13;
        end
        1: begin
            b = gr_sin_next;
            t2_next = b;
            gr_sin_next = 1;
            record_glob_reg_PROC_STATE_next = 1; return;    // test_reg_cthread1.cpp:91:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_glob_reg_ff
    if ( ~rstn ) begin
        record_glob_reg_PROC_STATE <= 0;    // test_reg_cthread1.cpp:87:9;
    end
    else begin
        gr_sin <= gr_sin_next;
        t2 <= t2_next;
        record_glob_reg_PROC_STATE <= record_glob_reg_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_glob_assign1 (test_reg_cthread1.cpp:100:5) 

// Thread-local variables
logic signed [31:0] grr_sin;
logic signed [31:0] grr_sin_next;
logic signed [31:0] t3_next;
logic signed [31:0] grr_cos;

// Next-state combinational logic
always_comb begin : record_glob_assign1_comb     // test_reg_cthread1.cpp:100:5
    record_glob_assign1_func;
end
function void record_glob_assign1_func;
    integer r_sin_1;
    integer r_cos;
    grr_sin_next = grr_sin;
    t3_next = t3;
    grr_cos = 1;
    r_sin_1 = grr_sin_next; r_cos = grr_cos;
    t3_next = r_sin_1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_glob_assign1_ff
    if ( ~rstn ) begin
    end
    else begin
        grr_sin <= grr_sin_next;
        t3 <= t3_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_not_defined (test_reg_cthread1.cpp:143:5) 

// Thread-local variables
logic signed [31:0] rn_sin;
logic signed [31:0] rn_sin_next;
logic signed [31:0] t6_next;
logic record_not_defined_PROC_STATE;
logic record_not_defined_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_not_defined_comb     // test_reg_cthread1.cpp:143:5
    record_not_defined_func;
end
function void record_not_defined_func;
    integer rn_cos;
    integer i;
    rn_sin_next = rn_sin;
    t6_next = t6;
    record_not_defined_PROC_STATE_next = record_not_defined_PROC_STATE;
    
    case (record_not_defined_PROC_STATE)
        0: begin
            rn_sin_next = 1;
            rn_cos = 2;
            record_not_defined_PROC_STATE_next = 1; return;    // test_reg_cthread1.cpp:148:13;
        end
        1: begin
            i = rn_sin_next;
            t6_next = i;
            rn_sin_next = 1;
            rn_cos = 2;
            record_not_defined_PROC_STATE_next = 1; return;    // test_reg_cthread1.cpp:148:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_not_defined_ff
    if ( ~rstn ) begin
        record_not_defined_PROC_STATE <= 0;    // test_reg_cthread1.cpp:144:9;
    end
    else begin
        rn_sin <= rn_sin_next;
        t6 <= t6_next;
        record_not_defined_PROC_STATE <= record_not_defined_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_glob_not_defined (test_reg_cthread1.cpp:157:5) 

// Thread-local variables
logic signed [31:0] gn_sin;
logic signed [31:0] gn_sin_next;
logic signed [31:0] gn_cos;
logic signed [31:0] gn_cos_next;
logic signed [31:0] t7_next;

// Next-state combinational logic
always_comb begin : record_glob_not_defined_comb     // test_reg_cthread1.cpp:157:5
    record_glob_not_defined_func;
end
function void record_glob_not_defined_func;
    integer r_sin_1;
    integer r_cos;
    gn_cos_next = gn_cos;
    gn_sin_next = gn_sin;
    t7_next = t7;
    r_sin_1 = gn_sin_next; r_cos = gn_cos_next;
    t7_next = r_sin_1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_glob_not_defined_ff
    if ( ~rstn ) begin
    end
    else begin
        gn_sin <= gn_sin_next;
        gn_cos <= gn_cos_next;
        t7 <= t7_next;
    end
end

endmodule


