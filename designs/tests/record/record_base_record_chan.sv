//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] s;
logic sig_a;
logic [41:0] sig_b;
logic [3:0] sig_c;
logic signed [31:0] ssig_d;
logic [3:0] ssig_e;
logic signed [31:0] reg_reg_data_b;
logic signed [31:0] reg_reg_data_d_b;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic t2_a;
logic [41:0] t2_b;
logic [3:0] t2_c;
logic signed [31:0] t3;
logic t4_a;
logic [41:0] t4_b;
logic [3:0] t4_c;
logic t5_a;
logic [41:0] t5_b;
logic [3:0] t5_c;
logic t6_a;
logic [41:0] t6_b;
logic [3:0] t6_c;
logic t7_a[2];
logic [41:0] t7_b[2];
logic [3:0] t7_c[2];
logic t8_a[2];
logic [41:0] t8_b[2];
logic [3:0] t8_c[2];
logic reg_clk;
logic reg_nrst;

// Local parameters generated for C++ constants
localparam logic signed [31:0] reg_RESET_VAL_b = 0;
localparam logic [31:0] SIZE = 42;
localparam logic [31:0] ARR[2] = '{ 11, 12 };

// Assignments generated for C++ channel arrays
assign reg_clk = clk;
assign reg_nrst = nrst;

//------------------------------------------------------------------------------
// Clocked THREAD: reg_reg_thread (sct_register.h:83:5) 

// Thread-local variables
logic signed [31:0] reg_reg_data_d_b_next;

// Next-state combinational logic
always_comb begin : reg_reg_thread_comb     // sct_register.h:83:5
    reg_reg_thread_func;
end
function void reg_reg_thread_func;
    reg_reg_data_d_b_next = reg_reg_data_d_b;
    reg_reg_data_d_b_next = reg_reg_data_b;
endfunction

// Synchronous register update
always_ff @(posedge reg_clk or negedge reg_nrst) 
begin : reg_reg_thread_ff
    if ( ~reg_nrst ) begin
        reg_reg_data_d_b <= reg_RESET_VAL_b;
    end
    else begin
        reg_reg_data_d_b <= reg_reg_data_d_b_next;
    end
end

//------------------------------------------------------------------------------
// Method process: record_reg (test_base_record_chan.cpp:137:5) 

always_comb 
begin : record_reg     // test_base_record_chan.cpp:137:5
    integer r_b;
    // Call reset() begin
    reg_reg_data_b = reg_reg_data_d_b;
    // Call reset() end
    r_b = reg_reg_data_d_b;
    t0 = r_b;
end

//------------------------------------------------------------------------------
// Method process: record_chan1 (test_base_record_chan.cpp:146:5) 

always_comb 
begin : record_chan1     // test_base_record_chan.cpp:146:5
    integer r_d;
    logic [3:0] r_e;
    integer t_d;
    logic [3:0] t_e;
    logic v_a;
    logic [41:0] v_b;
    logic [3:0] v_c;
    logic w_a;
    logic [41:0] w_b;
    logic [3:0] w_c;
    r_e = 0;
    t_e = 0;
    r_d = t_d; r_e = t_e;
    r_d = ssig_d; r_e = ssig_e;
    v_b = 0;
    v_c = 0;
    w_b = 0;
    w_c = 0;
    v_a = sig_a; v_b = sig_b; v_c = sig_c;
    w_a = v_a; w_b = v_b; w_c = v_c;
    t2_a = v_a; t2_b = v_b; t2_c = v_c;
    t1 = sig_c;
    t1 = r_d + w_c;
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_chan2 (test_base_record_chan.cpp:166:5) 

// Thread-local variables
logic x_a;
logic x_a_next;
logic [41:0] x_b;
logic [41:0] x_b_next;
logic [3:0] x_c;
logic [3:0] x_c_next;
logic t4_a_next;
logic [41:0] t4_b_next;
logic [3:0] t4_c_next;
logic signed [31:0] t3_next;
logic record_chan2_PROC_STATE;
logic record_chan2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_chan2_comb     // test_base_record_chan.cpp:166:5
    record_chan2_func;
end
function void record_chan2_func;
    t3_next = t3;
    t4_a_next = t4_a;
    t4_b_next = t4_b;
    t4_c_next = t4_c;
    x_a_next = x_a;
    x_b_next = x_b;
    x_c_next = x_c;
    record_chan2_PROC_STATE_next = record_chan2_PROC_STATE;
    
    case (record_chan2_PROC_STATE)
        0: begin
            x_b_next = 0;
            x_c_next = 0;
            x_a_next = sig_a; x_b_next = sig_b; x_c_next = sig_c;
            record_chan2_PROC_STATE_next = 1; return;    // test_base_record_chan.cpp:171:13;
        end
        1: begin
            t4_a_next = x_a_next; t4_b_next = x_b_next; t4_c_next = x_c_next;
            t3_next = x_b_next;
            x_b_next = 0;
            x_c_next = 0;
            x_a_next = sig_a; x_b_next = sig_b; x_c_next = sig_c;
            record_chan2_PROC_STATE_next = 1; return;    // test_base_record_chan.cpp:171:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : record_chan2_ff
    if ( ~nrst ) begin
        record_chan2_PROC_STATE <= 0;    // test_base_record_chan.cpp:167:9;
    end
    else begin
        x_a <= x_a_next;
        x_b <= x_b_next;
        x_c <= x_c_next;
        t4_a <= t4_a_next;
        t4_b <= t4_b_next;
        t4_c <= t4_c_next;
        t3 <= t3_next;
        record_chan2_PROC_STATE <= record_chan2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_chan3 (test_base_record_chan.cpp:178:5) 

// Thread-local variables
logic t5_a_next;
logic [41:0] t5_b_next;
logic [3:0] t5_c_next;

// Next-state combinational logic
always_comb begin : record_chan3_comb     // test_base_record_chan.cpp:178:5
    record_chan3_func;
end
function void record_chan3_func;
    logic d_a;
    logic [41:0] d_b;
    logic [3:0] d_c;
    t5_a_next = t5_a;
    t5_b_next = t5_b;
    t5_c_next = t5_c;
    t5_a_next = sig_a; t5_b_next = sig_b; t5_c_next = sig_c;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : record_chan3_ff
    if ( ~nrst ) begin
        logic d_a;
        logic [41:0] d_b;
        logic [3:0] d_c;
        d_b = 0;
        d_c = 0;
        d_b = SIZE;
        d_c = SIZE;
        t5_a <= d_a; t5_b <= d_b; t5_c <= d_c;
    end
    else begin
        t5_a <= t5_a_next;
        t5_b <= t5_b_next;
        t5_c <= t5_c_next;
    end
end

//------------------------------------------------------------------------------
// Method process: record_chan4 (test_base_record_chan.cpp:191:5) 

always_comb 
begin : record_chan4     // test_base_record_chan.cpp:191:5
    logic d_a;
    logic [41:0] d_b;
    logic [3:0] d_c;
    d_b = 0;
    d_c = 0;
    d_b = SIZE + ARR[0];
    d_c = SIZE + ARR[s];
    d_c = SIZE + SIZE + ARR[1];
    t6_a = d_a; t6_b = d_b; t6_c = d_c;
end

//------------------------------------------------------------------------------
// Method process: record_chan5 (test_base_record_chan.cpp:203:5) 

always_comb 
begin : record_chan5     // test_base_record_chan.cpp:203:5
    logic d_a;
    logic [41:0] d_b;
    logic [3:0] d_c;
    logic e_a[2];
    logic [41:0] e_b[2];
    logic [3:0] e_c[2];
    d_b = 0;
    d_c = 0;
    e_b[0] = SIZE;
    e_c[1] = SIZE;
    e_a[s] = d_a; e_b[s] = d_b; e_c[s] = d_c;
    e_c[s] = SIZE;
    t7_a[s] = e_a[s]; t7_b[s] = e_b[s]; t7_c[s] = e_c[s];
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_chan6 (test_base_record_chan.cpp:216:5) 

// Thread-local variables
logic e_a0[2];
logic e_a_next[2];
logic [3:0] e_c0[2];
logic [3:0] e_c_next[2];
logic t8_a_next[2];
logic [41:0] t8_b_next[2];
logic [3:0] t8_c_next[2];
logic [41:0] e_b0[2];
logic [41:0] e_b_next[2];

// Next-state combinational logic
always_comb begin : record_chan6_comb     // test_base_record_chan.cpp:216:5
    record_chan6_func;
end
function void record_chan6_func;
    e_a_next = e_a0;
    e_b_next = e_b0;
    e_c_next = e_c0;
    t8_a_next = t8_a;
    t8_b_next = t8_b;
    t8_c_next = t8_c;
    e_c_next[s] = e_c_next[s] + SIZE;
    e_a_next[s] = e_b_next[s] == 1;
    e_b_next[s + 1] = s;
    t8_a_next[s] = e_a_next[s]; t8_b_next[s] = e_b_next[s]; t8_c_next[s] = e_c_next[s];
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : record_chan6_ff
    if ( ~nrst ) begin
        e_b0[0] <= SIZE;
        e_c0[1] <= SIZE;
        t8_a[0] <= e_a0[0]; t8_b[0] <= e_b0[0]; t8_c[0] <= e_c0[0];
    end
    else begin
        e_a0 <= e_a_next;
        e_c0 <= e_c_next;
        t8_a <= t8_a_next;
        t8_b <= t8_b_next;
        t8_c <= t8_c_next;
        e_b0 <= e_b_next;
    end
end

endmodule


