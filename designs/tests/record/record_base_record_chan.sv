//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.20
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] s;
logic sig_a;
logic [41:0] sig_b;
logic [3:0] sig_c;
logic signed [31:0] ssig_d;
logic [3:0] ssig_e;
logic signed [31:0] reg_reg_data_b;
logic signed [31:0] reg_reg_data_d_b;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic t2_a;
logic [41:0] t2_b;
logic [3:0] t2_c;
logic signed [31:0] t3;
logic t4_a;
logic [41:0] t4_b;
logic [3:0] t4_c;
logic t5_a;
logic [41:0] t5_b;
logic [3:0] t5_c;
logic t6_a;
logic [41:0] t6_b;
logic [3:0] t6_c;
logic t7_a[2];
logic [41:0] t7_b[2];
logic [3:0] t7_c[2];
logic t8_a[2];
logic [41:0] t8_b[2];
logic [3:0] t8_c[2];
logic signed [31:0] t9;
logic tt9_a[2];
logic [41:0] tt9_b[2];
logic [3:0] tt9_c[2];
logic t10_a;
logic [41:0] t10_b;
logic [3:0] t10_c;
logic reg_clk;
logic reg_nrst;

// Local parameters generated for C++ constants
localparam logic signed [31:0] reg_RESET_VAL_b = '0;
localparam logic [31:0] m8_SIZE = 42;
localparam logic [31:0] m8_SIZE1 = 43;
localparam logic [31:0] m8_SIZE2 = 44;
localparam logic [31:0] m8_SIZE3 = 45;
localparam logic [31:0] m8_ARR[2] = '{ 11, 12 };

// Assignments generated for C++ channel arrays
assign reg_clk = clk;
assign reg_nrst = nrst;

//------------------------------------------------------------------------------
// Clocked THREAD: reg_reg_thread (sct_register.h:83:5) 

// Thread-local variables
logic signed [31:0] reg_reg_data_d_b_next;

// Next-state combinational logic
always_comb begin : reg_reg_thread_comb     // sct_register.h:83:5
    reg_reg_thread_func;
end
function void reg_reg_thread_func;
    reg_reg_data_d_b_next = reg_reg_data_d_b;
    reg_reg_data_d_b_next = reg_reg_data_b;
endfunction

// Synchronous register update
always_ff @(posedge reg_clk or negedge reg_nrst) 
begin : reg_reg_thread_ff
    if ( ~reg_nrst ) begin
        reg_reg_data_d_b <= reg_RESET_VAL_b;
    end
    else begin
        reg_reg_data_d_b <= reg_reg_data_d_b_next;
    end
end

//------------------------------------------------------------------------------
// Method process: record_reg (test_base_record_chan.cpp:145:5) 

always_comb 
begin : record_reg     // test_base_record_chan.cpp:145:5
    integer TMP_0_b;
    integer r_b;
    // Call reset() begin
    reg_reg_data_b = reg_reg_data_d_b;
    // Call reset() end
    // Call read() begin
    TMP_0_b = reg_reg_data_d_b;
    // Call read() end
    r_b = TMP_0_b;
    t0 = r_b;
end

//------------------------------------------------------------------------------
// Method process: record_chan1 (test_base_record_chan.cpp:154:5) 

always_comb 
begin : record_chan1     // test_base_record_chan.cpp:154:5
    integer r_d;
    logic [3:0] r_e;
    integer t_d;
    logic [3:0] t_e;
    logic v_a;
    logic [41:0] v_b;
    logic [3:0] v_c;
    logic w_a;
    logic [41:0] w_b;
    logic [3:0] w_c;
    r_e = 0;
    t_e = 0;
    r_d = t_d; r_e = t_e;
    r_d = ssig_d; r_e = ssig_e;
    v_b = 0;
    v_c = 0;
    w_b = 0;
    w_c = 0;
    v_a = sig_a; v_b = sig_b; v_c = sig_c;
    w_a = v_a; w_b = v_b; w_c = v_c;
    t2_a = v_a; t2_b = v_b; t2_c = v_c;
    t1 = sig_c;
    t1 = r_d + w_c;
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_chan2 (test_base_record_chan.cpp:174:5) 

// Thread-local variables
logic x_a;
logic x_a_next;
logic [41:0] x_b;
logic [41:0] x_b_next;
logic [3:0] x_c;
logic [3:0] x_c_next;
logic t4_a_next;
logic [41:0] t4_b_next;
logic [3:0] t4_c_next;
logic signed [31:0] t3_next;
logic record_chan2_PROC_STATE;
logic record_chan2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_chan2_comb     // test_base_record_chan.cpp:174:5
    record_chan2_func;
end
function void record_chan2_func;
    t3_next = t3;
    t4_a_next = t4_a;
    t4_b_next = t4_b;
    t4_c_next = t4_c;
    x_a_next = x_a;
    x_b_next = x_b;
    x_c_next = x_c;
    record_chan2_PROC_STATE_next = record_chan2_PROC_STATE;
    
    case (record_chan2_PROC_STATE)
        0: begin
            x_b_next = 0;
            x_c_next = 0;
            x_a_next = sig_a; x_b_next = sig_b; x_c_next = sig_c;
            record_chan2_PROC_STATE_next = 1; return;    // test_base_record_chan.cpp:179:13;
        end
        1: begin
            t4_a_next = x_a_next; t4_b_next = x_b_next; t4_c_next = x_c_next;
            t3_next = x_b_next;
            x_b_next = 0;
            x_c_next = 0;
            x_a_next = sig_a; x_b_next = sig_b; x_c_next = sig_c;
            record_chan2_PROC_STATE_next = 1; return;    // test_base_record_chan.cpp:179:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : record_chan2_ff
    if ( ~nrst ) begin
        record_chan2_PROC_STATE <= 0;    // test_base_record_chan.cpp:175:9;
    end
    else begin
        x_a <= x_a_next;
        x_b <= x_b_next;
        x_c <= x_c_next;
        t4_a <= t4_a_next;
        t4_b <= t4_b_next;
        t4_c <= t4_c_next;
        t3 <= t3_next;
        record_chan2_PROC_STATE <= record_chan2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_chan3 (test_base_record_chan.cpp:186:5) 

// Thread-local variables
logic t5_a_next;
logic [41:0] t5_b_next;
logic [3:0] t5_c_next;

// Next-state combinational logic
always_comb begin : record_chan3_comb     // test_base_record_chan.cpp:186:5
    record_chan3_func;
end
function void record_chan3_func;
    logic d_a;
    logic [41:0] d_b;
    logic [3:0] d_c;
    t5_a_next = t5_a;
    t5_b_next = t5_b;
    t5_c_next = t5_c;
    t5_a_next = sig_a; t5_b_next = sig_b; t5_c_next = sig_c;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : record_chan3_ff
    if ( ~nrst ) begin
        logic d_a;
        logic [41:0] d_b;
        logic [3:0] d_c;
        d_b = 0;
        d_c = 0;
        d_b = m8_SIZE;
        d_c = m8_SIZE;
        t5_a <= d_a; t5_b <= d_b; t5_c <= d_c;
    end
    else begin
        t5_a <= t5_a_next;
        t5_b <= t5_b_next;
        t5_c <= t5_c_next;
    end
end

//------------------------------------------------------------------------------
// Method process: record_chan4 (test_base_record_chan.cpp:199:5) 

always_comb 
begin : record_chan4     // test_base_record_chan.cpp:199:5
    logic d_a;
    logic [41:0] d_b;
    logic [3:0] d_c;
    d_b = 0;
    d_c = 0;
    d_b = m8_SIZE + m8_ARR[0];
    d_c = m8_SIZE + m8_ARR[s];
    d_c = m8_SIZE + m8_SIZE + m8_ARR[1];
    t6_a = d_a; t6_b = d_b; t6_c = d_c;
end

//------------------------------------------------------------------------------
// Method process: record_chan5 (test_base_record_chan.cpp:211:5) 

always_comb 
begin : record_chan5     // test_base_record_chan.cpp:211:5
    logic d_a;
    logic [41:0] d_b;
    logic [3:0] d_c;
    logic e_a[2];
    logic [41:0] e_b[2];
    logic [3:0] e_c[2];
    d_b = 0;
    d_c = 0;
    e_b[0] = m8_SIZE;
    e_c[1] = m8_SIZE;
    e_a[s] = d_a; e_b[s] = d_b; e_c[s] = d_c;
    e_c[s] = m8_SIZE;
    t7_a[s] = e_a[s]; t7_b[s] = e_b[s]; t7_c[s] = e_c[s];
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_chan6 (test_base_record_chan.cpp:224:5) 

// Thread-local variables
logic t8_a_next[2];
logic [41:0] t8_b_next[2];
logic [3:0] t8_c_next[2];
logic [3:0] e_c0[2];
logic [3:0] e_c_next[2];
logic [41:0] e_b0[2];
logic [41:0] e_b_next[2];

// Next-state combinational logic
always_comb begin : record_chan6_comb     // test_base_record_chan.cpp:224:5
    record_chan6_func;
end
function void record_chan6_func;
    logic e_a[2];
    e_b_next = e_b0;
    e_c_next = e_c0;
    t8_a_next = t8_a;
    t8_b_next = t8_b;
    t8_c_next = t8_c;
    e_c_next[s] = e_c_next[s] + m8_SIZE;
    e_a[s] = e_b_next[s] == 1;
    e_b_next[s + 1] = s;
    t8_a_next[s] = e_a[s]; t8_b_next[s] = e_b_next[s]; t8_c_next[s] = e_c_next[s];
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : record_chan6_ff
    if ( ~nrst ) begin
        logic e_a[2];
        e_b0[0] <= m8_SIZE;
        e_c0[1] <= m8_SIZE;
        t8_a[0] <= e_a[0]; t8_b[0] <= e_b0[0]; t8_c[0] <= e_c0[0];
    end
    else begin
        t8_a <= t8_a_next;
        t8_b <= t8_b_next;
        t8_c <= t8_c_next;
        e_c0 <= e_c_next;
        e_b0 <= e_b_next;
    end
end

//------------------------------------------------------------------------------
// Method process: record_chan7 (test_base_record_chan.cpp:244:5) 

// Process-local variables
logic m8_a;
logic [41:0] m8_b;
logic [3:0] m8_c;
logic m9_a[2];
logic [41:0] m9_b[2];
logic [3:0] m9_c[2];
logic mm9_a[2];
logic [41:0] mm9_b[2];

always_comb 
begin : record_chan7     // test_base_record_chan.cpp:244:5
    logic d_a;
    logic [41:0] d_b;
    logic [3:0] d_c;
    logic e_a[2];
    logic [41:0] e_b[2];
    logic [3:0] e_c[2];
    d_b = 0;
    d_c = 0;
    m8_a = d_a; m8_b = d_b; m8_c = d_c;
    m8_a = e_a[0]; m8_b = e_b[0]; m8_c = e_c[0];
    m9_a[s] = d_a; m9_b[s] = d_b; m9_c[s] = d_c;
    t9 = m9_b[s];
    t9 = m9_c[s];
    m9_b[s] = m9_c[s + 1];
    tt9_a[s] = d_a; tt9_b[s] = d_b; tt9_c[s] = d_c;
    mm9_a[s] = d_a; mm9_b[s] = d_b;
    t9 = m8_SIZE2;
    t9 = m8_SIZE2;
    t9 = m8_SIZE2;
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_chan8 (test_base_record_chan.cpp:265:5) 

// Thread-local variables
logic t10_a_next;
logic [41:0] t10_b_next;
logic [3:0] t10_c_next;
logic f_a[2];
logic f_a_next[2];
logic [3:0] f_c[2];
logic [3:0] f_c_next[2];

// Next-state combinational logic
always_comb begin : record_chan8_comb     // test_base_record_chan.cpp:265:5
    record_chan8_func;
end
function void record_chan8_func;
    logic [41:0] f_b[2];
    f_a_next = f_a;
    f_c_next = f_c;
    t10_a_next = t10_a;
    t10_b_next = t10_b;
    t10_c_next = t10_c;
    f_b[s + 1] = m8_SIZE3;
    t10_a_next = f_a_next[s]; t10_b_next = f_b[s]; t10_c_next = f_c_next[s];
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : record_chan8_ff
    if ( ~nrst ) begin
        logic [41:0] f_b[2];
        f_b[0] = m8_SIZE1;
        f_c[1] <= m8_SIZE1;
        t10_a <= f_a[0]; t10_b <= f_b[0]; t10_c <= f_c[0];
    end
    else begin
        t10_a <= t10_a_next;
        t10_b <= t10_b_next;
        t10_c <= t10_c_next;
        f_a <= f_a_next;
        f_c <= f_c_next;
    end
end

endmodule


