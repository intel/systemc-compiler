//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.17
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);


//------------------------------------------------------------------------------
// Child module instances

A b_mod
(
  .clk(clk)
);

endmodule



//==============================================================================
//
// Module: A (test_return_method_mif.cpp:206:5)
//
module A // "top.b_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic mif_nrst[2];
logic signed [31:0] mif_c[2];
logic mif_t_a[2][3][3];
logic signed [31:0] mif_t_b[2][3];
logic mif_tt_a[2][3][3];
logic signed [31:0] mif_tt_b[2][3];
logic signed [31:0] s;
logic t1_a[3];
logic signed [31:0] t1_b;
logic signed [31:0] t2;
logic t7_a[3];
logic signed [31:0] t7_b;
logic t3_a[3];
logic signed [31:0] t3_b;
logic t4_a[2][3];
logic signed [31:0] t4_b[2];
logic mif_clk[2];

// Assignments generated for C++ channel arrays
assign mif_clk[0] = clk;
assign mif_clk[1] = clk;

//------------------------------------------------------------------------------
// Method process: mif_meth (test_return_method_mif.cpp:46:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : mif_meth_sct_i 

    always_comb 
    begin : mif_meth     // test_return_method_mif.cpp:46:5
        logic r_a[3];
        integer r_b;
        logic p_a[3];
        integer p_b;
        r_a = mif_t_a[sct_i][1]; r_b = mif_t_b[sct_i][1];
        p_a = r_a; p_b = r_b;
        mif_t_a[sct_i][1] = p_a; mif_t_b[sct_i][1] = p_b;
        r_a = mif_t_a[sct_i][1]; r_b = mif_t_b[sct_i][1];
        r_a = p_a; r_b = p_b;
        mif_t_a[sct_i][2] = 0; mif_t_b[sct_i][2] = 0;
        mif_t_a[sct_i][2] = r_a; mif_t_b[sct_i][2] = r_b;
        mif_t_a[sct_i][mif_c[sct_i]] = 0; mif_t_b[sct_i][mif_c[sct_i]] = 0;
        mif_t_a[sct_i][2] = mif_t_a[sct_i][1]; mif_t_b[sct_i][2] = mif_t_b[sct_i][1];
        mif_t_a[sct_i][mif_c[sct_i]] = mif_t_a[sct_i][1]; mif_t_b[sct_i][mif_c[sct_i]] = mif_t_b[sct_i][1];
    end

end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: mif_thrd (test_return_method_mif.cpp:62:5) 

// Thread-local variables
logic mif_n_a[2][3];
logic signed [31:0] mif_n_b[2];
logic h_a[2][3];
logic h_a_next[2][3];
logic signed [31:0] h_b[2];
logic signed [31:0] h_b_next[2];
logic mif_tt_a_next[2][3][3];
logic signed [31:0] mif_tt_b_next[2][3];
logic signed [31:0] mif_c_next[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : mif_thrd_sct_i 

    // Next-state combinational logic
    always_comb begin : mif_thrd_comb     // test_return_method_mif.cpp:62:5
        mif_thrd_func;
    end
    function void mif_thrd_func;
        logic g_a[3];
        integer g_b;
        logic j_a[3];
        integer j_b;
        h_a_next[sct_i] = h_a[sct_i];
        h_b_next[sct_i] = h_b[sct_i];
        mif_c_next[sct_i] = mif_c[sct_i];
        mif_tt_a_next[sct_i] = mif_tt_a[sct_i];
        mif_tt_b_next[sct_i] = mif_tt_b[sct_i];
        mif_tt_a_next[sct_i][mif_c[sct_i]] = h_a_next[sct_i]; mif_tt_b_next[sct_i][mif_c[sct_i]] = h_b_next[sct_i];
        j_a = mif_tt_a[sct_i][mif_c[sct_i]]; j_b = mif_tt_b[sct_i][mif_c[sct_i]];
        mif_c_next[sct_i] = 32'(j_a[2]);
    endfunction

    // Synchronous register update
    always_ff @(posedge mif_clk[sct_i] or negedge mif_nrst[sct_i]) 
    begin : mif_thrd_ff
        if ( ~mif_nrst[sct_i] ) begin
            logic g_a[3];
            integer g_b;
            g_a = mif_n_a[sct_i]; g_b = mif_n_b[sct_i];
            h_a[sct_i] <= g_a; h_b[sct_i] <= g_b;
        end
        else begin
            h_a[sct_i] <= h_a_next[sct_i];
            h_b[sct_i] <= h_b_next[sct_i];
            mif_tt_a[sct_i] <= mif_tt_a_next[sct_i];
            mif_tt_b[sct_i] <= mif_tt_b_next[sct_i];
            mif_c[sct_i] <= mif_c_next[sct_i];
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: sig_ref_meth1 (test_return_method_mif.cpp:135:5) 

// Process-local variables
logic mif_m_a[2][3];
logic signed [31:0] mif_m_b[2];

always_comb 
begin : sig_ref_meth1     // test_return_method_mif.cpp:135:5
    logic l_a[3];
    integer l_b;
    logic r_a[3];
    integer r_b;
    logic TMP_2_a[3];
    integer TMP_2_b;
    logic TMP_3_a[3];
    integer TMP_3_b;
    logic TMP_4_a[3];
    integer TMP_4_b;
    logic TMP_5_a[3];
    integer TMP_5_b;
    l_a = mif_t_a[s - 1][s + 1]; l_b = mif_t_b[s - 1][s + 1];
    mif_t_a[s - 1][s + 1] = 0; mif_t_b[s - 1][s + 1] = 0;
    mif_t_a[s - 1][s + 1] = l_a; mif_t_b[s - 1][s + 1] = l_b;
    mif_t_a[s - 1][s + 1] = 0; mif_t_b[s - 1][s + 1] = 0;
    // Call read_val() begin
    r_a = mif_t_a[0][1]; r_b = mif_t_b[0][1];
    r_a = mif_m_a[0]; r_b = mif_m_b[0];
    TMP_2_a = r_a; TMP_2_b = r_b;
    // Call read_val() end
    l_a = TMP_2_a; l_b = TMP_2_b;
    // Call read_val2() begin
    TMP_3_a = mif_t_a[1][1]; TMP_3_b = mif_t_b[1][1];
    // Call read_val2() end
    l_a = TMP_3_a; l_b = TMP_3_b;
    // Call read_val() begin
    r_a = mif_t_a[s][1]; r_b = mif_t_b[s][1];
    r_a = mif_m_a[s]; r_b = mif_m_b[s];
    TMP_4_a = r_a; TMP_4_b = r_b;
    // Call read_val() end
    l_a = TMP_4_a; l_b = TMP_4_b;
    // Call read_val2() begin
    TMP_5_a = mif_t_a[s][1]; TMP_5_b = mif_t_b[s][1];
    // Call read_val2() end
    l_a = TMP_5_a; l_b = TMP_5_b;
    t1_a = l_a; t1_b = l_b;
end

//------------------------------------------------------------------------------
// Method process: sig_ref_meth2 (test_return_method_mif.cpp:156:5) 

// Process-local variables
logic signed [31:0] recArr_b[2];

always_comb 
begin : sig_ref_meth2     // test_return_method_mif.cpp:156:5
    integer i;
    i = recArr_b[0];
    t2 = i;
end

//------------------------------------------------------------------------------
// Method process: sig_ref_meth3 (test_return_method_mif.cpp:164:5) 

// Process-local variables
logic signed [31:0] mif_mmm_b[2];
logic mif_mmm_a[2][3];

always_comb 
begin : sig_ref_meth3     // test_return_method_mif.cpp:164:5
    integer i;
    logic p_a[3];
    integer p_b;
    i = mif_mmm_b[s];
    t2 = i;
    p_a = mif_mmm_a; p_b = mif_mmm_b;
    t7_a = p_a; t7_b = p_b;
end

//------------------------------------------------------------------------------
// Clocked THREAD: sig_ref_thrd (test_return_method_mif.cpp:177:5) 

// Thread-local variables
logic p_a0[3];
logic p_a_next[3];
logic signed [31:0] p_b0;
logic signed [31:0] p_b_next;
logic rr_a[3];
logic rr_a_next[3];
logic signed [31:0] rr_b;
logic signed [31:0] rr_b_next;
logic t3_a_next[3];
logic signed [31:0] t3_b_next;
logic t4_a_next[2][3];
logic signed [31:0] t4_b_next[2];
logic mif_mm_a[2][3];
logic signed [31:0] mif_mm_b[2];
logic sig_ref_thrd_PROC_STATE;
logic sig_ref_thrd_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sig_ref_thrd_comb     // test_return_method_mif.cpp:177:5
    sig_ref_thrd_func;
end
function void sig_ref_thrd_func;
    logic q_a[3];
    integer q_b;
    logic r_a[3];
    integer r_b;
    logic TMP_0_a[3];
    integer TMP_0_b;
    logic TMP_1_a[3];
    integer TMP_1_b;
    logic r_a_1[3];
    integer r_b_1;
    logic TMP_2_a[3];
    integer TMP_2_b;
    logic TMP_3_a[3];
    integer TMP_3_b;
    logic TMP_4_a[3];
    integer TMP_4_b;
    integer TMP_5;
    p_a_next = p_a0;
    p_b_next = p_b0;
    rr_a_next = rr_a;
    rr_b_next = rr_b;
    t3_a_next = t3_a;
    t3_b_next = t3_b;
    t4_a_next = t4_a;
    t4_b_next = t4_b;
    sig_ref_thrd_PROC_STATE_next = sig_ref_thrd_PROC_STATE;
    
    case (sig_ref_thrd_PROC_STATE)
        0: begin
            r_a_1 = p_a_next; r_b_1 = p_b_next;
            rr_a_next = p_a_next; rr_b_next = p_b_next;
            t3_a_next = r_a_1; t3_b_next = r_b_1;
            p_a_next = t4_a[r_a_1[s]]; p_b_next = t4_b[r_a_1[s]];
            // Call read_val_() begin
            mif_mm_a[s] = mif_t_a[s][1]; mif_mm_b[s] = mif_t_b[s][1];
            r_a = mif_mm_a[s]; r_b = mif_mm_b[s];
            mif_mm_a[s] = r_a; mif_mm_b[s] = r_b;
            TMP_2_a = r_a; TMP_2_b = r_b;
            // Call read_val_() end
            p_a_next = TMP_2_a; p_b_next = TMP_2_b;
            // Call read_val2() begin
            TMP_3_a = mif_t_a[s][1]; TMP_3_b = mif_t_b[s][1];
            // Call read_val2() end
            p_a_next = TMP_3_a; p_b_next = TMP_3_b;
            // Call read_val2() begin
            TMP_4_a = mif_t_a[0][1]; TMP_4_b = mif_t_b[0][1];
            // Call read_val2() end
            q_a = TMP_4_a; q_b = TMP_4_b;
            // Call read_int() begin
            TMP_5 = mif_c[0];
            // Call read_int() end
            sig_ref_thrd_PROC_STATE_next = 1; return;    // test_return_method_mif.cpp:194:13;
        end
        1: begin
            t4_a_next[0] = p_a_next; t4_b_next[0] = p_b_next;
            t4_a_next[1] = rr_a_next; t4_b_next[1] = rr_b_next;
            r_a_1 = p_a_next; r_b_1 = p_b_next;
            rr_a_next = p_a_next; rr_b_next = p_b_next;
            t3_a_next = r_a_1; t3_b_next = r_b_1;
            p_a_next = t4_a[r_a_1[s]]; p_b_next = t4_b[r_a_1[s]];
            // Call read_val_() begin
            mif_mm_a[s] = mif_t_a[s][1]; mif_mm_b[s] = mif_t_b[s][1];
            r_a = mif_mm_a[s]; r_b = mif_mm_b[s];
            mif_mm_a[s] = r_a; mif_mm_b[s] = r_b;
            TMP_2_a = r_a; TMP_2_b = r_b;
            // Call read_val_() end
            p_a_next = TMP_2_a; p_b_next = TMP_2_b;
            // Call read_val2() begin
            TMP_3_a = mif_t_a[s][1]; TMP_3_b = mif_t_b[s][1];
            // Call read_val2() end
            p_a_next = TMP_3_a; p_b_next = TMP_3_b;
            // Call read_val2() begin
            TMP_4_a = mif_t_a[0][1]; TMP_4_b = mif_t_b[0][1];
            // Call read_val2() end
            q_a = TMP_4_a; q_b = TMP_4_b;
            // Call read_int() begin
            TMP_5 = mif_c[0];
            // Call read_int() end
            sig_ref_thrd_PROC_STATE_next = 1; return;    // test_return_method_mif.cpp:194:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : sig_ref_thrd_ff
    if ( ~nrst ) begin
        logic q_a[3];
        integer q_b;
        logic r_a[3];
        integer r_b;
        logic TMP_0_a[3];
        integer TMP_0_b;
        logic TMP_1_a[3];
        integer TMP_1_b;
        logic mif_mm_a[3];
        integer mif_mm_b;
        p_a0 <= q_a; p_b0 <= q_b;
        // Call read_val_() begin
        mif_mm_a[0] = mif_t_a[0][1]; mif_mm_b[0] = mif_t_b[0][1];
        r_a = mif_mm_a[0]; r_b = mif_mm_b[0];
        mif_mm_a[0] = r_a; mif_mm_b[0] = r_b;
        TMP_0_a = r_a; TMP_0_b = r_b;
        // Call read_val_() end
        p_a0 <= TMP_0_a; p_b0 <= TMP_0_b;
        // Call read_val2() begin
        TMP_1_a = mif_t_a[1][1]; TMP_1_b = mif_t_b[1][1];
        // Call read_val2() end
        p_a0 <= TMP_1_a; p_b0 <= TMP_1_b;
        sig_ref_thrd_PROC_STATE <= 0;    // test_return_method_mif.cpp:183:9;
    end
    else begin
        p_a0 <= p_a_next;
        p_b0 <= p_b_next;
        rr_a <= rr_a_next;
        rr_b <= rr_b_next;
        t3_a <= t3_a_next;
        t3_b <= t3_b_next;
        t4_a <= t4_a_next;
        t4_b <= t4_b_next;
        sig_ref_thrd_PROC_STATE <= sig_ref_thrd_PROC_STATE_next;
    end
end

endmodule


