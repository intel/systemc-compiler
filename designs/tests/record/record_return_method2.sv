//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.25
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);


//------------------------------------------------------------------------------
// Child module instances

A b_mod
(
  .clk(clk)
);

endmodule



//==============================================================================
//
// Module: A (test_return_method2.cpp:148:5)
//
module A // "top.b_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic c;
logic s_a;
logic signed [31:0] s_b;
logic t_a;
logic signed [31:0] t_b;
logic m_c;
logic m_s_a;
logic signed [31:0] m_s_b;
logic m_t_a;
logic signed [31:0] m_t_b;
logic c1;
logic c2;
logic c3;
logic t1_a;
logic signed [31:0] t1_b;
logic t2_a;
logic signed [31:0] t2_b;
logic t3_a;
logic signed [31:0] t3_b;

// Local parameters generated for C++ constants
localparam logic always_ready = 0;
localparam logic chan_sync = 0;

//------------------------------------------------------------------------------
// Method process: sig_ref_meth1 (test_return_method2.cpp:113:5) 

always_comb 
begin : sig_ref_meth1     // test_return_method2.cpp:113:5
    logic l_a;
    integer l_b;
    logic TMP_0_a;
    integer TMP_0_b;
    // Call cond_read_val() begin
    if (c)
    begin
        TMP_0_a = s_a; TMP_0_b = s_b;
    end else begin
        TMP_0_a = t_a; TMP_0_b = t_b;
    end
    // Call cond_read_val() end
    l_a = TMP_0_a; l_b = TMP_0_b;
    // Call cond_read_ref() begin
    c1 = !c1;
    // Call cond_read_ref() end
    l_a = s_a; l_b = s_b;
    t1_a = l_a; t1_b = l_b;
end

//------------------------------------------------------------------------------
// Clocked THREAD: sig_ref_thrd (test_return_method2.cpp:122:5) 

// Thread-local variables
logic c3_next;
logic t2_a_next;
logic signed [31:0] t2_b_next;
logic c2_next;
logic sig_ref_thrd_PROC_STATE;
logic sig_ref_thrd_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sig_ref_thrd_comb     // test_return_method2.cpp:122:5
    sig_ref_thrd_func;
end
function void sig_ref_thrd_func;
    c2_next = c2;
    c3_next = c3;
    t2_a_next = t2_a;
    t2_b_next = t2_b;
    sig_ref_thrd_PROC_STATE_next = sig_ref_thrd_PROC_STATE;
    
    case (sig_ref_thrd_PROC_STATE)
        0: begin
            // Call constcond_read_ref() begin
            c3_next = !c3;
            // Call constcond_read_ref() end
            t2_a_next = s_a; t2_b_next = s_b;
            // Call noncond_read_ref() begin
            c2_next = !c2;
            // Call noncond_read_ref() end
            sig_ref_thrd_PROC_STATE_next = 1; return;    // test_return_method2.cpp:129:13;
        end
        1: begin
            t2_a_next = s_a; t2_b_next = s_b;
            // Call constcond_read_ref() begin
            c3_next = !c3;
            // Call constcond_read_ref() end
            t2_a_next = s_a; t2_b_next = s_b;
            // Call noncond_read_ref() begin
            c2_next = !c2;
            // Call noncond_read_ref() end
            sig_ref_thrd_PROC_STATE_next = 1; return;    // test_return_method2.cpp:129:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : sig_ref_thrd_ff
    if ( ~nrst ) begin
        sig_ref_thrd_PROC_STATE <= '0;    // test_return_method2.cpp:124:9;
    end
    else begin
        c3 <= c3_next;
        t2_a <= t2_a_next;
        t2_b <= t2_b_next;
        c2 <= c2_next;
        sig_ref_thrd_PROC_STATE <= sig_ref_thrd_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Method process: sig_ref_meth2 (test_return_method2.cpp:136:5) 

always_comb 
begin : sig_ref_meth2     // test_return_method2.cpp:136:5
    logic l_a;
    integer l_b;
    logic TMP_0_a;
    integer TMP_0_b;
    // Call cond_read_val() begin
    if (m_c)
    begin
        TMP_0_a = m_s_a; TMP_0_b = m_s_b;
    end else begin
        TMP_0_a = m_t_a; TMP_0_b = m_t_b;
    end
    // Call cond_read_val() end
    l_a = TMP_0_a; l_b = TMP_0_b;
    l_a = m_s_a; l_b = m_s_b;
    t3_a = l_a; t3_b = l_b;
end

endmodule


