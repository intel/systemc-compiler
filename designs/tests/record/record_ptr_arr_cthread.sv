//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
    input logic clk
);


//------------------------------------------------------------------------------
// Child module instances

A a_mod
(
  .clk(clk)
);

endmodule



//==============================================================================
//
// Module: A (test_ptr_arr_cthread.cpp:100:5)
//
module A // "b_mod.a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic signed [31:0] s;
logic signed [31:0] t2;
logic signed [31:0] t0;
logic signed [31:0] t1;

//------------------------------------------------------------------------------
// Clocked THREAD: rec_ptr_simple (test_ptr_arr_cthread.cpp:51:5) 

// Thread-local variables
logic r1_a[2];
logic r1_a_next[2];
logic signed [31:0] t2_next;

// Next-state combinational logic
always_comb begin : rec_ptr_simple_comb     // test_ptr_arr_cthread.cpp:51:5
    rec_ptr_simple_func;
end
function void rec_ptr_simple_func;
    logic b;
    logic TMP_0;
    r1_a_next = r1_a;
    t2_next = t2;
    b = r1_a_next[0];
    // Call getA() begin
    TMP_0 = r1_a_next[s];
    // Call getA() end
    b = TMP_0;
    t2_next = b;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : rec_ptr_simple_ff
    if ( ~rst ) begin
    end
    else begin
        r1_a <= r1_a_next;
        t2 <= t2_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_ptr_loop (test_ptr_arr_cthread.cpp:64:5) 

// Thread-local variables
logic r2_a[2];
logic r2_a_next[2];
logic signed [31:0] t0_next;
logic [3:0] r2_b[2];

// Next-state combinational logic
always_comb begin : rec_ptr_loop_comb     // test_ptr_arr_cthread.cpp:64:5
    rec_ptr_loop_func;
end
function void rec_ptr_loop_func;
    logic b;
    logic [3:0] par;
    r2_a_next = r2_a;
    t0_next = t0;
    b = 0;
    for (integer i = 0; i < 2; i++)
    begin
        b = b || 0;
        par = i;
        // Call setB() begin
        r2_b[i] = par;
        // Call setB() end
    end
    t0_next = b;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : rec_ptr_loop_ff
    if ( ~rst ) begin
    end
    else begin
        r2_a <= r2_a_next;
        t0 <= t0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_ptr_unknw (test_ptr_arr_cthread.cpp:82:5) 

// Thread-local variables
logic r3_a[2];
logic r3_a_next[2];
logic signed [31:0] t1_next;
logic [3:0] r3_b[2];

// Next-state combinational logic
always_comb begin : rec_ptr_unknw_comb     // test_ptr_arr_cthread.cpp:82:5
    rec_ptr_unknw_func;
end
function void rec_ptr_unknw_func;
    integer i;
    logic b;
    logic [3:0] par;
    r3_a_next = r3_a;
    t1_next = t1;
    i = s;
    b = r3_a_next[i];
    par = i + 2;
    // Call setB() begin
    r3_b[i] = par;
    // Call setB() end
    t1_next = b;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : rec_ptr_unknw_ff
    if ( ~rst ) begin
    end
    else begin
        r3_a <= r3_a_next;
        t1 <= t1_next;
    end
end

endmodule


