//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.25
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic [31:0] s;
logic sim_a;
logic signed [31:0] sim_b;
logic sim2_a;
logic signed [31:0] sim2_b;
logic [11:0] aim_b;
logic [19:0] aim_c[3];
logic signed [31:0] pim_a;
logic csim_a;
logic signed [31:0] csim_b;

//------------------------------------------------------------------------------
// Method process: testDefinedMeth (test_use_def.cpp:150:5) 

always_comb 
begin : testDefinedMeth     // test_use_def.cpp:150:5
    logic ss_a;
    integer ss_b;
    integer a_;
    integer pp_a;
    ss_b = 'h42;
    ss_b = s + 1'd1;
    a_ = s;
    // Call Par() begin
    pp_a = a_;
    // Call Par() end
    if (|pp_a)
    begin
        pp_a = s + 2'd2;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: testDefined (test_use_def.cpp:165:5) 

// Thread-local variables
logic [31:0] s_next;

// Next-state combinational logic
always_comb begin : testDefined_comb     // test_use_def.cpp:165:5
    testDefined_func;
end
function void testDefined_func;
    logic [1:0] bts;
    logic resp_oper;
    logic resp_error;
    s_next = s;
    if (|s)
    begin
        bts = s;
        resp_oper = '0;
        resp_error = '0;
        // Call CoreRsp() begin
        // Call unpack() begin
        {resp_oper, resp_error} = bts;
        // Call unpack() end
        // Call CoreRsp() end
        if (resp_error)
        begin
            s_next = resp_oper;
        end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : testDefined_ff
    if ( ~nrst ) begin
    end
    else begin
        s <= s_next;
    end
end

//------------------------------------------------------------------------------
// Method process: testMeth (test_use_def.cpp:178:5) 

always_comb 
begin : testMeth     // test_use_def.cpp:178:5
    logic ss_a;
    integer ss_b;
    ss_b = 'h42;
    ss_b = 'h43;
    sim_a = 0; sim_b = 'h42;
end

//------------------------------------------------------------------------------
// Method process: clearMeth (test_use_def.cpp:187:5) 

always_comb 
begin : clearMeth     // test_use_def.cpp:187:5
    logic ss_a;
    integer ss_b;
    logic rr_a;
    integer rr_b;
    ss_b = 'h42;
    rr_b = 'h42;
    ss_a = sim_a; ss_b = sim_b;
    ss_b = 'h41;
    rr_a = ss_a; rr_b = ss_b;
    rr_a = sim_a; rr_b = sim_b;
    ss_a = 1'd1;
    ss_b = 'h43;
    rr_a = ss_a; rr_b = ss_b;
end

//------------------------------------------------------------------------------
// Method process: clearArrMeth (test_use_def.cpp:214:5) 

always_comb 
begin : clearArrMeth     // test_use_def.cpp:214:5
    integer unsigned i;
    logic [11:0] ss_b;
    logic [19:0] ss_c[3];
    logic [11:0] rr_b;
    logic [19:0] rr_c[3];
    i = s;
    ss_b = 7'h42;
    ss_c[0] = 1'd1; ss_c[1] = 2'd2; ss_c[2] = 2'd3;
    rr_b = 7'h42;
    rr_c[0] = 1'd1; rr_c[1] = 2'd2; rr_c[2] = 2'd3;
    ss_b = aim_b; ss_c = aim_c;
    ss_b = 'h41;
    rr_b = ss_b; rr_c = ss_c;
    rr_b = aim_b; rr_c = aim_c;
    ss_c[i] = 5;
end

//------------------------------------------------------------------------------
// Method process: recRefMeth (test_use_def.cpp:255:5) 

always_comb 
begin : recRefMeth     // test_use_def.cpp:255:5
    logic ss_a;
    integer ss_b;
    logic ll1_a;
    integer ll1_b;
    logic ll2_a;
    integer ll2_b;
    logic rr_a;
    integer rr_b;
    ss_b = 'h42;
    ll1_a = ss_a; ll1_b = ss_b;
    ll2_b = 'h42;
    ll2_a = ss_a; ll2_b = ss_b;
    ss_b = 'h43;
    ss_b = 'h44;
    ss_a = sim_a; ss_b = sim_b;
    rr_b = 'h42;
    rr_a = 1'd1;
    rr_b = 'h45;
    ss_a = rr_a; ss_b = rr_b;
end

//------------------------------------------------------------------------------
// Method process: combSigMeth (test_use_def.cpp:289:5) 

always_comb 
begin : combSigMeth     // test_use_def.cpp:289:5
    logic ss_a;
    integer ss_b;
    ss_b = 'h42;
    ss_a = csim_a; ss_b = csim_b;
    csim_a = ss_a; csim_b = ss_b;
end

//------------------------------------------------------------------------------
// Method process: methReg (test_use_def.cpp:300:5) 

always_comb 
begin : methReg     // test_use_def.cpp:300:5
    logic ss_a;
    integer ss_b;
    logic tt_a;
    integer tt_b;
    integer a_;
    integer pp1_a;
    integer pp2_a;
    integer pp_a;
    ss_b = 'h42;
    tt_a = ss_a; tt_b = ss_b;
    a_ = 1;
    // Call Par() begin
    pp1_a = a_;
    // Call Par() end
    a_ = 2;
    // Call Par() begin
    pp2_a = a_;
    // Call Par() end
    pp_a = pp1_a;
    pp_a = pp2_a;
end

//------------------------------------------------------------------------------
// Clocked THREAD: threadReg (test_use_def.cpp:316:5) 

// Thread-local variables
logic sim2_a_next;
logic signed [31:0] sim2_b_next;

// Next-state combinational logic
always_comb begin : threadReg_comb     // test_use_def.cpp:316:5
    threadReg_func;
end
function void threadReg_func;
    logic ss_a;
    integer ss_b;
    integer pp_a;
    logic tt_a;
    integer tt_b;
    integer xx_a;
    sim2_a_next = sim2_a;
    sim2_b_next = sim2_b;
    ss_a = sim2_a; ss_b = sim2_b;
    tt_a = ss_a; tt_b = ss_b;
    pp_a = pim_a;
    xx_a = pp_a;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : threadReg_ff
    if ( ~nrst ) begin
        logic ss_a;
        integer ss_b;
        integer a_;
        integer pp_a;
        ss_b = 'h42;
        sim2_a <= ss_a; sim2_b <= ss_b;
        a_ = 1;
        // Call Par() begin
        pp_a = a_;
        // Call Par() end
    end
    else begin
        sim2_a <= sim2_a_next;
        sim2_b <= sim2_b_next;
    end
end

endmodule


