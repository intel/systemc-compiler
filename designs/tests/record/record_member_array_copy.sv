//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.8
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic [3:0] s;

//------------------------------------------------------------------------------
// Method process: simple_loc_rec_meth (test_member_array_copy.cpp:73:5) 

always_comb 
begin : simple_loc_rec_meth     // test_member_array_copy.cpp:73:5
    logic ar_a;
    logic [3:0] ar_b;
    logic br_a;
    logic [3:0] br_b;
    ar_b = 0;
    ar_b = 1;
    br_a = ar_a; br_b = ar_b;
end

//------------------------------------------------------------------------------
// Method process: loc_rec_meth (test_member_array_copy.cpp:81:5) 

always_comb 
begin : loc_rec_meth     // test_member_array_copy.cpp:81:5
    logic [3:0] ar_b[3];
    integer i;
    logic [3:0] br_b[3];
    ar_b[0] = 0; ar_b[1] = 0; ar_b[2] = 0;
    ar_b[0] = 1;
    ar_b[1] = 2;
    ar_b[2] = 4;
    i = s;
    ar_b[i] = i;
    i = ar_b[i + 1] + 1;
    br_b = ar_b;
end

//------------------------------------------------------------------------------
// Method process: loc_arr_rec_arr_meth (test_member_array_copy.cpp:107:5) 

always_comb 
begin : loc_arr_rec_arr_meth     // test_member_array_copy.cpp:107:5
    logic [3:0] ar_b[2][3];
    integer i;
    integer j;
    i = s;
    j = s + 1;
    ar_b[1][0] = 1;
    ar_b[i][j] = 2;
    j = ar_b[i + 1][j - 1] + ar_b[i][1];
end

//------------------------------------------------------------------------------
// Method process: glob_rec_meth (test_member_array_copy.cpp:137:5) 

// Process-local variables
logic [3:0] gr_b[3];

always_comb 
begin : glob_rec_meth     // test_member_array_copy.cpp:137:5
    logic [3:0] lr_b[3];
    gr_b[0] = 1;
    gr_b[1] = 2;
    gr_b[2] = 4;
    lr_b = gr_b;
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_copy (test_member_array_copy.cpp:179:5) 

// Thread-local variables
logic [3:0] par_b[3];
logic [3:0] par_b_next[3];
logic [1:0] loc_array_copy_PROC_STATE;
logic [1:0] loc_array_copy_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : loc_array_copy_comb     // test_member_array_copy.cpp:179:5
    loc_array_copy_func;
end
function void loc_array_copy_func;
    logic [3:0] xlarr_b[3];
    logic [3:0] l;
    par_b_next = par_b;
    loc_array_copy_PROC_STATE_next = loc_array_copy_PROC_STATE;
    
    case (loc_array_copy_PROC_STATE)
        0: begin
            xlarr_b[0] = 0; xlarr_b[1] = 0; xlarr_b[2] = 0;
            par_b_next = xlarr_b;
            // Call rec_param_copy() begin
            par_b_next[s] = 1;
            loc_array_copy_PROC_STATE_next = 1; return;    // test_member_array_copy.cpp:174:9;
            // Call rec_param_copy() end
        end
        1: begin
            // Call rec_param_copy() begin
            l = par_b_next[1];
            // Call rec_param_copy() end
            loc_array_copy_PROC_STATE_next = 2; return;    // test_member_array_copy.cpp:188:13;
        end
        2: begin
            xlarr_b[0] = 0; xlarr_b[1] = 0; xlarr_b[2] = 0;
            par_b_next = xlarr_b;
            // Call rec_param_copy() begin
            par_b_next[s] = 1;
            loc_array_copy_PROC_STATE_next = 1; return;    // test_member_array_copy.cpp:174:9;
            // Call rec_param_copy() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_copy_ff
    if ( rst ) begin
        loc_array_copy_PROC_STATE <= 0;    // test_member_array_copy.cpp:181:9;
    end
    else begin
        par_b <= par_b_next;
        loc_array_copy_PROC_STATE <= loc_array_copy_PROC_STATE_next;
    end
end

endmodule


