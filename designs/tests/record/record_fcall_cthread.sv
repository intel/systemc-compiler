//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.13
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic signed [31:0] sig;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;
logic signed [31:0] t3;
logic signed [31:0] t4;
logic signed [31:0] t5;
logic signed [31:0] t6;
logic signed [31:0] t7;
logic signed [31:0] t8;

// Local parameters generated for C++ constants
localparam logic signed [31:0] A = 1;

//------------------------------------------------------------------------------
// Clocked THREAD: single_rec_call_reg (test_fcall_cthread.cpp:99:5) 

// Thread-local variables
logic s_a;
logic s_a_next;
logic signed [31:0] t0_next;
logic single_rec_call_reg_PROC_STATE;
logic single_rec_call_reg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : single_rec_call_reg_comb     // test_fcall_cthread.cpp:99:5
    single_rec_call_reg_func;
end
function void single_rec_call_reg_func;
    integer s_b;
    logic s_par;
    logic c;
    s_a_next = s_a;
    t0_next = t0;
    single_rec_call_reg_PROC_STATE_next = single_rec_call_reg_PROC_STATE;
    
    case (single_rec_call_reg_PROC_STATE)
        0: begin
            s_par = 1;
            // Call setA() begin
            s_a_next = s_par;
            // Call setA() end
            single_rec_call_reg_PROC_STATE_next = 1; return;    // test_fcall_cthread.cpp:106:13;
        end
        1: begin
            c = 1;    // Call of getA()
            t0_next = c;
            s_par = 1;
            // Call setA() begin
            s_a_next = s_par;
            // Call setA() end
            single_rec_call_reg_PROC_STATE_next = 1; return;    // test_fcall_cthread.cpp:106:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_rec_call_reg_ff
    if ( ~rstn ) begin
        integer s_b;
        single_rec_call_reg_PROC_STATE <= 0;    // test_fcall_cthread.cpp:102:9;
    end
    else begin
        s_a <= s_a_next;
        t0 <= t0_next;
        single_rec_call_reg_PROC_STATE <= single_rec_call_reg_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: single_rec_call_comb (test_fcall_cthread.cpp:115:5) 

// Thread-local variables
logic signed [31:0] t1_next;

// Next-state combinational logic
always_comb begin : single_rec_call_comb_comb     // test_fcall_cthread.cpp:115:5
    single_rec_call_comb_func;
end
function void single_rec_call_comb_func;
    logic r_a;
    integer r_b;
    logic r_par;
    logic c;
    t1_next = t1;
    r_par = 1;
    // Call setA() begin
    r_a = r_par;
    // Call setA() end
    c = 1;    // Call of getA()
    t1_next = c;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_rec_call_comb_ff
    if ( ~rstn ) begin
        logic r_a;
        integer r_b;
    end
    else begin
        t1 <= t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_call_reg (test_fcall_cthread.cpp:132:5) 

// Thread-local variables
logic t_a[2];
logic t_a_next[2];
logic signed [31:0] t_b[2];
logic signed [31:0] t_b_next[2];
logic signed [31:0] t2_next;
logic rec_arr_call_reg_PROC_STATE;
logic rec_arr_call_reg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_call_reg_comb     // test_fcall_cthread.cpp:132:5
    rec_arr_call_reg_func;
end
function void rec_arr_call_reg_func;
    logic t_par;
    logic c;
    t2_next = t2;
    t_a_next = t_a;
    t_b_next = t_b;
    rec_arr_call_reg_PROC_STATE_next = rec_arr_call_reg_PROC_STATE;
    
    case (rec_arr_call_reg_PROC_STATE)
        0: begin
            t_par = 1;
            // Call setA() begin
            t_a_next[1] = t_par;
            // Call setA() end
            rec_arr_call_reg_PROC_STATE_next = 1; return;    // test_fcall_cthread.cpp:140:13;
        end
        1: begin
            // Call reset() begin
            t_a_next[0] = |(A + t_a_next[0]);
            t_b_next[0] = A + t_b_next[0];
            // Call reset() end
            c = 1;    // Call of getA()
            t2_next = c;
            t_par = 1;
            // Call setA() begin
            t_a_next[1] = t_par;
            // Call setA() end
            rec_arr_call_reg_PROC_STATE_next = 1; return;    // test_fcall_cthread.cpp:140:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : rec_arr_call_reg_ff
    if ( ~rstn ) begin
        // Call reset() begin
        t_a[0] <= |(A + t_a[0]);
        t_b[0] <= A + t_b[0];
        // Call reset() end
        rec_arr_call_reg_PROC_STATE <= 0;    // test_fcall_cthread.cpp:136:9;
    end
    else begin
        t_a <= t_a_next;
        t_b <= t_b_next;
        t2 <= t2_next;
        rec_arr_call_reg_PROC_STATE <= rec_arr_call_reg_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_call_comb (test_fcall_cthread.cpp:150:5) 

// Thread-local variables
logic signed [31:0] t3_next;

// Next-state combinational logic
always_comb begin : rec_arr_call_comb_comb     // test_fcall_cthread.cpp:150:5
    rec_arr_call_comb_func;
end
function void rec_arr_call_comb_func;
    logic q_a[2];
    integer q_b[2];
    logic q_par;
    logic c;
    t3_next = t3;
    q_par = 1;
    // Call setA() begin
    q_a[1] = q_par;
    // Call setA() end
    c = 1;    // Call of getA()
    t3_next = c;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : rec_arr_call_comb_ff
    if ( ~rstn ) begin
        integer q_b[2];
    end
    else begin
        t3 <= t3_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_call_reset_reg2 (test_fcall_cthread.cpp:166:5) 

// Thread-local variables
logic w_a[2];
logic w_a_next[2];
logic signed [31:0] t4_next;
logic rec_arr_call_reset_reg2_PROC_STATE;
logic rec_arr_call_reset_reg2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_call_reset_reg2_comb     // test_fcall_cthread.cpp:166:5
    rec_arr_call_reset_reg2_func;
end
function void rec_arr_call_reset_reg2_func;
    integer w_b[2];
    logic w_par;
    logic c;
    t4_next = t4;
    w_a_next = w_a;
    rec_arr_call_reset_reg2_PROC_STATE_next = rec_arr_call_reset_reg2_PROC_STATE;
    
    case (rec_arr_call_reset_reg2_PROC_STATE)
        0: begin
            c = 1;    // Call of getA()
            t4_next = c;
            rec_arr_call_reset_reg2_PROC_STATE_next = 1; return;    // test_fcall_cthread.cpp:175:13;
        end
        1: begin
            rec_arr_call_reset_reg2_PROC_STATE_next = 1; return;    // test_fcall_cthread.cpp:175:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : rec_arr_call_reset_reg2_ff
    if ( ~rstn ) begin
        integer w_b[2];
        logic w_par;
        w_par = 1;
        // Call setA() begin
        w_a[1] <= w_par;
        // Call setA() end
        rec_arr_call_reset_reg2_PROC_STATE <= 0;    // test_fcall_cthread.cpp:170:9;
    end
    else begin
        w_a <= w_a_next;
        t4 <= t4_next;
        rec_arr_call_reset_reg2_PROC_STATE <= rec_arr_call_reset_reg2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_call_reg2 (test_fcall_cthread.cpp:180:5) 

// Thread-local variables
logic signed [31:0] t5_next;

// Next-state combinational logic
always_comb begin : rec_arr_call_reg2_comb     // test_fcall_cthread.cpp:180:5
    rec_arr_call_reg2_func;
end
function void rec_arr_call_reg2_func;
    logic z_a[2];
    integer z_b[2];
    logic TMP_0;
    logic c;
    t5_next = t5;
    // Call getA() begin
    TMP_0 = z_a[1];
    // Call getA() end
    c = TMP_0;
    t5_next = c;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : rec_arr_call_reg2_ff
    if ( ~rstn ) begin
    end
    else begin
        t5 <= t5_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_call_unknw_reg (test_fcall_cthread.cpp:195:5) 

// Thread-local variables
logic s_a0[2];
logic s_a_next0[2];
logic signed [31:0] t6_next;

// Next-state combinational logic
always_comb begin : rec_arr_call_unknw_reg_comb     // test_fcall_cthread.cpp:195:5
    rec_arr_call_unknw_reg_func;
end
function void rec_arr_call_unknw_reg_func;
    integer s_b[2];
    integer j;
    logic s_par;
    logic TMP_0;
    logic c;
    s_a_next0 = s_a0;
    t6_next = t6;
    j = sig + A;
    s_par = 1;
    // Call setA() begin
    s_a_next0[1] = s_par;
    // Call setA() end
    // Call getA() begin
    TMP_0 = s_a_next0[j];
    // Call getA() end
    c = TMP_0;
    t6_next = c;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : rec_arr_call_unknw_reg_ff
    if ( ~rstn ) begin
        integer s_b[2];
    end
    else begin
        s_a0 <= s_a_next0;
        t6 <= t6_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_call_unknw_reg2 (test_fcall_cthread.cpp:212:5) 

// Thread-local variables
logic s_a1[2];
logic s_a_next1[2];
logic signed [31:0] t7_next;

// Next-state combinational logic
always_comb begin : rec_arr_call_unknw_reg2_comb     // test_fcall_cthread.cpp:212:5
    rec_arr_call_unknw_reg2_func;
end
function void rec_arr_call_unknw_reg2_func;
    integer s_b[2];
    integer j;
    logic s_par;
    logic TMP_0;
    logic c;
    s_a_next1 = s_a1;
    t7_next = t7;
    j = sig;
    s_par = 1;
    // Call setA() begin
    s_a_next1[j] = s_par;
    // Call setA() end
    // Call getA() begin
    TMP_0 = s_a_next1[1];
    // Call getA() end
    c = TMP_0;
    t7_next = c;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : rec_arr_call_unknw_reg2_ff
    if ( ~rstn ) begin
        integer s_b[2];
    end
    else begin
        s_a1 <= s_a_next1;
        t7 <= t7_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_call_unknw_reg3 (test_fcall_cthread.cpp:229:5) 

// Thread-local variables
logic s_a2[2];
logic s_a_next2[2];
logic signed [31:0] t8_next;

// Next-state combinational logic
always_comb begin : rec_arr_call_unknw_reg3_comb     // test_fcall_cthread.cpp:229:5
    rec_arr_call_unknw_reg3_func;
end
function void rec_arr_call_unknw_reg3_func;
    integer s_b[2];
    integer j;
    logic s_par;
    logic TMP_0;
    logic c;
    s_a_next2 = s_a2;
    t8_next = t8;
    j = sig;
    s_par = 1;
    // Call setA() begin
    s_a_next2[j] = s_par;
    // Call setA() end
    // Call getA() begin
    TMP_0 = s_a_next2[j];
    // Call getA() end
    c = TMP_0;
    t8_next = c;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : rec_arr_call_unknw_reg3_ff
    if ( ~rstn ) begin
        integer s_b[2];
    end
    else begin
        s_a2 <= s_a_next2;
        t8 <= t8_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_call_unknw_loc (test_fcall_cthread.cpp:247:5) 

// Next-state combinational logic
always_comb begin : rec_arr_call_unknw_loc_comb     // test_fcall_cthread.cpp:247:5
    rec_arr_call_unknw_loc_func;
end
function void rec_arr_call_unknw_loc_func;
    logic s_a_1[2];
    integer s_b[2];
    integer j;
    integer TMP_0;
    integer s_l;
    j = sig;
    // Call locVar() begin
    s_l = 1;
    TMP_0 = s_l + 1;
    // Call locVar() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : rec_arr_call_unknw_loc_ff
    if ( ~rstn ) begin
        logic s_a_1[2];
        integer s_b[2];
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Method process: rec_arr_call_unknw_loc_in_call_m (test_fcall_cthread.cpp:261:5) 

always_comb 
begin : rec_arr_call_unknw_loc_in_call_m     // test_fcall_cthread.cpp:261:5
    logic s_a_1;
    integer s_b;
    integer TMP_0;
    integer s_k;
    integer j;
    logic ss_a[2];
    integer ss_b[2];
    integer TMP_1;
    integer ss_k;
    // Call locFcall() begin
    TMP_0 = s_k;
    // Call locFcall() end
    j = sig;
    // Call locFcall() begin
    TMP_1 = ss_k;
    // Call locFcall() end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_call_unknw_loc_in_call (test_fcall_cthread.cpp:272:5) 

// Next-state combinational logic
always_comb begin : rec_arr_call_unknw_loc_in_call_comb     // test_fcall_cthread.cpp:272:5
    rec_arr_call_unknw_loc_in_call_func;
end
function void rec_arr_call_unknw_loc_in_call_func;
    logic s_a_1[2];
    integer s_b[2];
    integer j;
    integer TMP_0;
    integer s_k;
    j = sig;
    // Call locFcall() begin
    TMP_0 = s_k;
    // Call locFcall() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : rec_arr_call_unknw_loc_in_call_ff
    if ( ~rstn ) begin
        logic s_a_1[2];
        integer s_b[2];
    end
    else begin
    end
end

endmodule


