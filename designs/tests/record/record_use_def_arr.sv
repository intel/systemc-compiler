//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.25
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic [31:0] s;
logic sim_a;
logic signed [31:0] sim_b;
logic sim2_a;
logic signed [31:0] sim2_b;
logic [11:0] aim_b;
logic [19:0] aim_c[3];
logic [11:0] bim_b;
logic [19:0] bim_c[3];
logic signed [31:0] pim_a;
logic csim_a;
logic signed [31:0] csim_b;

//------------------------------------------------------------------------------
// Method process: testDefinedMeth (test_use_def_arr.cpp:153:5) 

always_comb 
begin : testDefinedMeth     // test_use_def_arr.cpp:153:5
    logic ss_a;
    integer ss_b;
    integer a_;
    integer pp_a;
    if (|ss_b)
    begin
        ss_b = s + 1'd1;
    end
    a_ = s;
    // Call Par() begin
    pp_a = a_;
    // Call Par() end
    if (|pp_a)
    begin
        pp_a = s + 2'd2;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: testDefined (test_use_def_arr.cpp:168:5) 

// Thread-local variables
logic [31:0] s_next;

// Next-state combinational logic
always_comb begin : testDefined_comb     // test_use_def_arr.cpp:168:5
    testDefined_func;
end
function void testDefined_func;
    logic [1:0] bts;
    logic resp_oper;
    logic resp_error;
    s_next = s;
    if (|s)
    begin
        bts = s;
        resp_oper = '0;
        resp_error = '0;
        // Call CoreRsp() begin
        // Call unpack() begin
        {resp_oper, resp_error} = bts;
        // Call unpack() end
        // Call CoreRsp() end
        if (resp_error)
        begin
            s_next = resp_oper;
        end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : testDefined_ff
    if ( ~nrst ) begin
    end
    else begin
        s <= s_next;
    end
end

//------------------------------------------------------------------------------
// Method process: testMeth (test_use_def_arr.cpp:181:5) 

always_comb 
begin : testMeth     // test_use_def_arr.cpp:181:5
    logic ss_a;
    integer ss_b;
    ss_b = 'h43;
    sim_a = 0; sim_b = 0;
end

//------------------------------------------------------------------------------
// Method process: clearMeth (test_use_def_arr.cpp:189:5) 

always_comb 
begin : clearMeth     // test_use_def_arr.cpp:189:5
    integer unsigned i;
    logic ss_a;
    integer ss_b;
    logic as_a[3];
    integer as_b[3];
    i = s;
    ss_a = sim_a; ss_b = sim_b;
    ss_b = 'h41;
    as_a[1] = ss_a; as_b[1] = ss_b;
    as_a[1] = sim_a; as_b[1] = sim_b;
    ss_a = 1'd1;
    ss_b = 'h43;
    as_a[2] = ss_a; as_b[2] = ss_b;
    as_a[i] = sim_a; as_b[i] = sim_b;
end

//------------------------------------------------------------------------------
// Method process: clearArrMeth (test_use_def_arr.cpp:217:5) 

always_comb 
begin : clearArrMeth     // test_use_def_arr.cpp:217:5
    integer unsigned i;
    logic [11:0] ss_b;
    logic [19:0] ss_c[3];
    logic [11:0] as_b[3];
    logic [19:0] as_c[3][3];
    logic [19:0] l;
    i = s;
    ss_b = '0;
    ss_c[0] = 0; ss_c[1] = 0; ss_c[2] = 0;
    ss_b = aim_b; ss_c = aim_c;
    ss_b = 'h41;
    as_b[1] = ss_b; as_c[1] = ss_c;
    as_b[1] = aim_b; as_c[1] = aim_c;
    ss_b = 'h43;
    ss_c[0] = 4;
    as_b[2] = ss_b; as_c[2] = ss_c;
    as_c[2][2] = 42;
    l = as_c[2][2];
    as_b[i] = aim_b; as_c[i] = aim_c;
    l = as_c[i][s];
    ss_c[i] = 5;
    as_c[i][s] = 5;
end

//------------------------------------------------------------------------------
// Method process: setMeth (test_use_def_arr.cpp:278:5) 

always_comb 
begin : setMeth     // test_use_def_arr.cpp:278:5
    logic ss_a;
    integer ss_b;
    logic as_a[3];
    integer as_b[3];
    as_a[0] = 1'd1;
    as_b[0] = 2;
    as_a[1] = as_a[0]; as_b[1] = as_b[0];
    ss_a = as_a[1]; ss_b = as_b[1];
    sim_a = ss_a; sim_b = ss_b;
end

//------------------------------------------------------------------------------
// Method process: setArrMeth (test_use_def_arr.cpp:297:5) 

always_comb 
begin : setArrMeth     // test_use_def_arr.cpp:297:5
    integer unsigned i;
    logic [11:0] ss_b;
    logic [19:0] ss_c[3];
    logic [11:0] as_b[3];
    logic [19:0] as_c[3][3];
    i = s;
    ss_b = '0;
    ss_c[0] = 0; ss_c[1] = 0; ss_c[2] = 0;
    as_c[0][2] = 5;
    as_b[0] = 2;
    as_b[1] = as_b[0]; as_c[1] = as_c[0];
    ss_b = as_b[1]; ss_c = as_c[1];
    aim_b = ss_b; aim_c = ss_c;
    aim_b = as_b[i]; aim_c = as_c[i];
    as_b[i] = bim_b; as_c[i] = bim_c;
end

//------------------------------------------------------------------------------
// Method process: recRefMeth (test_use_def_arr.cpp:319:5) 

always_comb 
begin : recRefMeth     // test_use_def_arr.cpp:319:5
    logic ss_a;
    integer ss_b;
    logic ll1_a;
    integer ll1_b;
    logic ll2_a;
    integer ll2_b;
    logic rr_a;
    integer rr_b;
    ll1_a = ss_a; ll1_b = ss_b;
    ll2_a = ss_a; ll2_b = ss_b;
    ss_b = 'h43;
    ss_b = 'h44;
    ss_a = sim_a; ss_b = sim_b;
    rr_a = 1'd1;
    rr_b = 'h45;
    ss_a = rr_a; ss_b = rr_b;
end

//------------------------------------------------------------------------------
// Method process: combSigMeth (test_use_def_arr.cpp:351:5) 

always_comb 
begin : combSigMeth     // test_use_def_arr.cpp:351:5
    logic ss_a;
    integer ss_b;
    ss_a = csim_a; ss_b = csim_b;
    csim_a = ss_a; csim_b = ss_b;
end

//------------------------------------------------------------------------------
// Method process: methReg (test_use_def_arr.cpp:362:5) 

always_comb 
begin : methReg     // test_use_def_arr.cpp:362:5
    logic ss_a;
    integer ss_b;
    logic tt_a;
    integer tt_b;
    integer a_;
    integer pp1_a;
    integer pp2_a;
    integer pp_a;
    tt_a = ss_a; tt_b = ss_b;
    a_ = 1;
    // Call Par() begin
    pp1_a = a_;
    // Call Par() end
    a_ = 2;
    // Call Par() begin
    pp2_a = a_;
    // Call Par() end
    pp_a = pp1_a;
    pp_a = pp2_a;
end

//------------------------------------------------------------------------------
// Clocked THREAD: threadReg (test_use_def_arr.cpp:377:5) 

// Thread-local variables
logic sim2_a_next;
logic signed [31:0] sim2_b_next;

// Next-state combinational logic
always_comb begin : threadReg_comb     // test_use_def_arr.cpp:377:5
    threadReg_func;
end
function void threadReg_func;
    logic ss_a;
    integer ss_b;
    integer pp_a;
    logic tt_a;
    integer tt_b;
    integer xx_a;
    sim2_a_next = sim2_a;
    sim2_b_next = sim2_b;
    ss_a = sim2_a; ss_b = sim2_b;
    tt_a = ss_a; tt_b = ss_b;
    pp_a = pim_a;
    xx_a = pp_a;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : threadReg_ff
    if ( ~nrst ) begin
        logic ss_a;
        integer ss_b;
        integer a_;
        integer pp_a;
        sim2_a <= ss_a; sim2_b <= ss_b;
        a_ = 1;
        // Call Par() begin
        pp_a = a_;
        // Call Par() end
    end
    else begin
        sim2_a <= sim2_a_next;
        sim2_b <= sim2_b_next;
    end
end

endmodule


