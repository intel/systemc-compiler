//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk,
    input logic rst,
    input logic [7:0] iarr[3],
    output logic [7:0] oarr[3]
);

// Variables generated for SystemC signals
logic s;
logic sarr[3];
logic parr[3];
logic [3:0] psarr[3];
logic signed [31:0] t0;
logic [3:0] ns;
logic signed [31:0] t1;
logic signed [31:0] t2;
logic [3:0] ss;
logic [3:0] ps;
logic [3:0] rarr[3];
logic [3:0] rarrp[3];
logic signed [31:0] t3;

//------------------------------------------------------------------------------
// Method process: methProc (test_fcall_array.cpp:86:5) 

always_comb 
begin : methProc     // test_fcall_array.cpp:86:5
    integer i;
    integer j;
    logic [3:0] newval;
    integer k;
    // Call f1() begin
    s = sarr[0] ^ sarr[1];
    // Call f1() end
    // Call f1() begin
    s = parr[0] ^ parr[1];
    // Call f1() end
    i = 0;
    // Call f2() begin
    sarr[i] = 1;
    s = sarr[i + 1];
    // Call f2() end
    i = 1;
    // Call f2() begin
    parr[i] = 1;
    s = parr[i + 1];
    // Call f2() end
    j = 1; newval = 5;
    // Call f3() begin
    psarr[j] = newval;
    // Call f3() end
    k = 1;
    // Call f4() begin
    oarr[k] = sarr[k + 1] ? 42 : 0;
    // Call f4() end
    // Call f5() begin
    for (integer j_1 = 0; j_1 < 3; j_1++)
    begin
        sarr[j_1] = |iarr[j_1];
    end
    // Call f5() end
end

//------------------------------------------------------------------------------
// Clocked THREAD: intArrThread (test_fcall_array.cpp:124:5) 

// Thread-local variables
logic signed [31:0] t0_next;
logic [3:0] arr[3];
logic [3:0] arr_next[3];
logic [3:0] marr[3][3];
logic intArrThread_PROC_STATE;
logic intArrThread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : intArrThread_comb     // test_fcall_array.cpp:124:5
    intArrThread_func;
end
function void intArrThread_func;
    logic [63:0] SIZE;
    integer unsigned k;
    arr_next = arr;
    t0_next = t0;
    intArrThread_PROC_STATE_next = intArrThread_PROC_STATE;
    
    case (intArrThread_PROC_STATE)
        0: begin
            SIZE = 3;
            // Call intArrFunc() begin
            for (integer j_1 = 0; j_1 < SIZE; j_1++)
            begin
                arr_next[j_1] = j_1 + 1;
            end
            // Call intArrFunc() end
            intArrThread_PROC_STATE_next = 1; return;    // test_fcall_array.cpp:134:13;
        end
        1: begin
            k = 1;
            // Call intMultArrFunc() begin
            marr[0][k] = arr_next[k];
            // Call intMultArrFunc() end
            t0_next = arr_next[0];
            SIZE = 3;
            // Call intArrFunc() begin
            for (integer j_1 = 0; j_1 < SIZE; j_1++)
            begin
                arr_next[j_1] = j_1 + 1;
            end
            // Call intArrFunc() end
            intArrThread_PROC_STATE_next = 1; return;    // test_fcall_array.cpp:134:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : intArrThread_ff
    if ( ~rst ) begin
        logic [3:0] x;
        logic [3:0] marr[3][3];
        // Call initIntArr() begin
        for (integer i = 0; i < 3; i++)
        begin
            arr[i] <= 0;
            for (integer j = 0; j < 3; j++)
            begin
                marr[i][j] = 0;
            end
        end
        // Call initIntArr() end
        x = marr[1][1];
        t0 <= x;
        intArrThread_PROC_STATE <= 0;    // test_fcall_array.cpp:129:9;
    end
    else begin
        t0 <= t0_next;
        arr <= arr_next;
        intArrThread_PROC_STATE <= intArrThread_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: intArrThread2 (test_fcall_array.cpp:146:5) 

// Thread-local variables
logic [3:0] ns_next;
logic [3:0] nnarr[3][3];
logic [3:0] nnarr_next[3][3];
logic [3:0] narr[3];
logic [3:0] narr_next[3];
logic signed [31:0] j0;
logic signed [31:0] j_next;
logic intArrThread2_PROC_STATE;
logic intArrThread2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : intArrThread2_comb     // test_fcall_array.cpp:146:5
    intArrThread2_func;
end
function void intArrThread2_func;
    integer unsigned k;
    j_next = j0;
    narr_next = narr;
    nnarr_next = nnarr;
    ns_next = ns;
    intArrThread2_PROC_STATE_next = intArrThread2_PROC_STATE;
    
    case (intArrThread2_PROC_STATE)
        0: begin
            j_next = ns;
            ns_next = nnarr_next[0][j_next];
            intArrThread2_PROC_STATE_next = 1; return;    // test_fcall_array.cpp:156:13;
        end
        1: begin
            k = 1;
            // Call intMultArrFunc() begin
            nnarr_next[0][k] = narr_next[k];
            // Call intMultArrFunc() end
            ns_next = narr_next[j_next];
            j_next = ns;
            ns_next = nnarr_next[0][j_next];
            intArrThread2_PROC_STATE_next = 1; return;    // test_fcall_array.cpp:156:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : intArrThread2_ff
    if ( ~rst ) begin
        ns <= 0;
        // Call initIntArr() begin
        for (integer i = 0; i < 3; i++)
        begin
            narr[i] <= 0;
            for (integer j = 0; j < 3; j++)
            begin
                nnarr[i][j] <= 0;
            end
        end
        // Call initIntArr() end
        intArrThread2_PROC_STATE <= 0;    // test_fcall_array.cpp:150:9;
    end
    else begin
        ns <= ns_next;
        nnarr <= nnarr_next;
        narr <= narr_next;
        j0 <= j_next;
        intArrThread2_PROC_STATE <= intArrThread2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: intPtrArrThread (test_fcall_array.cpp:174:5) 

// Thread-local variables
logic [3:0] marrp[3];
logic [3:0] marrp_next[3];
logic [3:0] pi;
logic [3:0] pi_next;
logic signed [31:0] t1_next;
logic intPtrArrThread_PROC_STATE;
logic intPtrArrThread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : intPtrArrThread_comb     // test_fcall_array.cpp:174:5
    intPtrArrThread_func;
end
function void intPtrArrThread_func;
    integer l;
    marrp_next = marrp;
    pi_next = pi;
    t1_next = t1;
    intPtrArrThread_PROC_STATE_next = intPtrArrThread_PROC_STATE;
    
    case (intPtrArrThread_PROC_STATE)
        0: begin
            // Call intPtrArrFunc() begin
            pi_next = 1;
            marrp_next[pi_next] = 0;
            // Call intPtrArrFunc() end
            intPtrArrThread_PROC_STATE_next = 1; return;    // test_fcall_array.cpp:181:13;
        end
        1: begin
            l = pi_next + marrp_next[1];
            t1_next = l;
            // Call intPtrArrFunc() begin
            pi_next = 1;
            marrp_next[pi_next] = 0;
            // Call intPtrArrFunc() end
            intPtrArrThread_PROC_STATE_next = 1; return;    // test_fcall_array.cpp:181:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : intPtrArrThread_ff
    if ( ~rst ) begin
        intPtrArrThread_PROC_STATE <= 0;    // test_fcall_array.cpp:176:9;
    end
    else begin
        marrp <= marrp_next;
        pi <= pi_next;
        t1 <= t1_next;
        intPtrArrThread_PROC_STATE <= intPtrArrThread_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sigPtrThread (test_fcall_array.cpp:207:5) 

// Thread-local variables
logic [3:0] ss_next;
logic [3:0] ps_next;
logic signed [31:0] t2_next;

// Next-state combinational logic
always_comb begin : sigPtrThread_comb     // test_fcall_array.cpp:207:5
    sigPtrThread_func;
end
function void sigPtrThread_func;
    logic [3:0] a1;
    logic [3:0] a2;
    ps_next = ps;
    ss_next = ss;
    t2_next = t2;
    // Call sigRefPtrFunc() begin
    ss_next = 0;
    a1 = ss;
    ps_next = 0;
    a2 = ps;
    t2_next = a1 + a2;
    // Call sigRefPtrFunc() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : sigPtrThread_ff
    if ( ~rst ) begin
    end
    else begin
        ss <= ss_next;
        ps <= ps_next;
        t2 <= t2_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sigArrThread (test_fcall_array.cpp:246:5) 

// Thread-local variables
logic [3:0] rarr_next[3];
logic [3:0] rarrp_next[3];

// Next-state combinational logic
always_comb begin : sigArrThread_comb     // test_fcall_array.cpp:246:5
    sigArrThread_func;
end
function void sigArrThread_func;
    logic [63:0] SIZE_2;
    rarr_next = rarr;
    rarrp_next = rarrp;
    SIZE_2 = 3;
    // Call sigArrPtrFunc() begin
    for (integer j = 0; j < SIZE_2; j++)
    begin
        rarr_next[j] = rarrp[j];
    end
    rarrp_next[0] = rarr[SIZE_2 - 1];
    rarrp_next[1] = rarr[SIZE_2 - 2];
    // Call sigArrPtrFunc() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : sigArrThread_ff
    if ( ~rst ) begin
        logic [63:0] SIZE;
        logic [63:0] SIZE_1;
        SIZE = 3;
        // Call initSigArr() begin
        for (integer i = 0; i < SIZE; i++)
        begin
            rarr[i] <= 0;
        end
        // Call initSigArr() end
        SIZE_1 = 3;
        // Call initSigPtrArr() begin
        for (integer i_1 = 0; i_1 < SIZE_1; i_1++)
        begin
            rarrp[i_1] <= 0;
        end
        // Call initSigPtrArr() end
    end
    else begin
        rarr <= rarr_next;
        rarrp <= rarrp_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sigLocRefThread (test_fcall_array.cpp:262:5) 

// Thread-local variables
logic [3:0] ss_next0;
logic signed [31:0] t3_next;

// Next-state combinational logic
always_comb begin : sigLocRefThread_comb     // test_fcall_array.cpp:262:5
    sigLocRefThread_func;
end
function void sigLocRefThread_func;
    logic [3:0] l;
    ss_next0 = ss;
    t3_next = t3;
    ss_next0 = 0;
    l = ss;
    t3_next = l;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : sigLocRefThread_ff
    if ( ~rst ) begin
    end
    else begin
        ss <= ss_next0;
        t3 <= t3_next;
    end
end

endmodule


