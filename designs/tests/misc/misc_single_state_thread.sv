//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.14
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: test_mod ()
//
module test_mod // "t"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;
logic signed [31:0] t3;
logic signed [31:0] t4;
logic signed [31:0] t5;
logic signed [31:0] t6;
logic signed [31:0] t7;
logic signed [31:0] t7a;
logic signed [31:0] t8;
logic signed [31:0] t9;

//------------------------------------------------------------------------------
// Clocked THREAD: single_state_thread0 (test_single_state_thread.cpp:71:5) 

// Thread-local variables
logic signed [31:0] x;
logic signed [31:0] x_next;
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : single_state_thread0_comb     // test_single_state_thread.cpp:71:5
    single_state_thread0_func;
end
function void single_state_thread0_func;
    t0_next = t0;
    x_next = x;
    x_next++;
    t0_next = x_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_state_thread0_ff
    if ( ~rstn ) begin
        x <= 0;
    end
    else begin
        x <= x_next;
        t0 <= t0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: single_state_thread1 (test_single_state_thread.cpp:82:5) 

// Thread-local variables
logic signed [31:0] x0;
logic signed [31:0] x_next0;
logic signed [31:0] t1_next;

// Next-state combinational logic
always_comb begin : single_state_thread1_comb     // test_single_state_thread.cpp:82:5
    single_state_thread1_func;
end
function void single_state_thread1_func;
    t1_next = t1;
    x_next0 = x0;
    t1_next = x_next0++;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_state_thread1_ff
    if ( ~rstn ) begin
        x0 <= 0;
    end
    else begin
        x0 <= x_next0;
        t1 <= t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: single_state_thread2 (test_single_state_thread.cpp:92:5) 

// Thread-local variables
logic signed [31:0] x1;
logic signed [31:0] x_next1;
logic signed [31:0] t2_next;

// Next-state combinational logic
always_comb begin : single_state_thread2_comb     // test_single_state_thread.cpp:92:5
    single_state_thread2_func;
end
function void single_state_thread2_func;
    t2_next = t2;
    x_next1 = x1;
    x_next1++;
    t2_next = x_next1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_state_thread2_ff
    if ( ~rstn ) begin
        x1 <= 0;
    end
    else begin
        x1 <= x_next1;
        t2 <= t2_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: single_state_thread3 (test_single_state_thread.cpp:103:5) 

// Thread-local variables
logic signed [31:0] x2;
logic signed [31:0] x_next2;
logic signed [31:0] t3_next;

// Next-state combinational logic
always_comb begin : single_state_thread3_comb     // test_single_state_thread.cpp:103:5
    single_state_thread3_func;
end
function void single_state_thread3_func;
    t3_next = t3;
    x_next2 = x2;
    t3_next = x_next2++;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_state_thread3_ff
    if ( ~rstn ) begin
        x2 <= 0;
    end
    else begin
        x2 <= x_next2;
        t3 <= t3_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: single_state_thread4 (test_single_state_thread.cpp:116:5) 

// Thread-local variables
logic signed [31:0] x3;
logic signed [31:0] x_next3;
logic signed [31:0] t4_next;

// Next-state combinational logic
always_comb begin : single_state_thread4_comb     // test_single_state_thread.cpp:116:5
    single_state_thread4_func;
end
function void single_state_thread4_func;
    t4_next = t4;
    x_next3 = x3;
    t4_next = x_next3++;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_state_thread4_ff
    if ( ~rstn ) begin
        x3 <= 0;
    end
    else begin
        x3 <= x_next3;
        t4 <= t4_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread0 (test_single_state_thread.cpp:126:5) 

// Thread-local variables
logic signed [31:0] x4;
logic signed [31:0] x_next4;
logic signed [31:0] t5_next;
logic multistate_thread0_PROC_STATE;
logic multistate_thread0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread0_comb     // test_single_state_thread.cpp:126:5
    multistate_thread0_func;
end
function void multistate_thread0_func;
    t5_next = t5;
    x_next4 = x4;
    multistate_thread0_PROC_STATE_next = multistate_thread0_PROC_STATE;
    
    case (multistate_thread0_PROC_STATE)
        0: begin
            x_next4++;
            x_next4++;
            t5_next = x_next4;
            multistate_thread0_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:132:13;
        end
        1: begin
            x_next4++;
            t5_next = x_next4;
            multistate_thread0_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:132:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread0_ff
    if ( ~rstn ) begin
        x4 <= 0;
        multistate_thread0_PROC_STATE <= 0;    // test_single_state_thread.cpp:128:9;
    end
    else begin
        x4 <= x_next4;
        t5 <= t5_next;
        multistate_thread0_PROC_STATE <= multistate_thread0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread1 (test_single_state_thread.cpp:137:5) 

// Thread-local variables
logic signed [31:0] x5;
logic signed [31:0] x_next5;
logic signed [31:0] t6_next;
logic multistate_thread1_PROC_STATE;
logic multistate_thread1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread1_comb     // test_single_state_thread.cpp:137:5
    multistate_thread1_func;
end
function void multistate_thread1_func;
    t6_next = t6;
    x_next5 = x5;
    multistate_thread1_PROC_STATE_next = multistate_thread1_PROC_STATE;
    
    case (multistate_thread1_PROC_STATE)
        0: begin
            multistate_thread1_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:141:13;
        end
        1: begin
            x_next5++;
            t6_next = x_next5;
            multistate_thread1_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:141:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread1_ff
    if ( ~rstn ) begin
        x5 <= 0;
        multistate_thread1_PROC_STATE <= 0;    // test_single_state_thread.cpp:139:9;
    end
    else begin
        x5 <= x_next5;
        t6 <= t6_next;
        multistate_thread1_PROC_STATE <= multistate_thread1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread2 (test_single_state_thread.cpp:152:5) 

// Thread-local variables
logic signed [31:0] x6;
logic signed [31:0] x_next6;
logic signed [31:0] t7_next;
logic multistate_thread2_PROC_STATE;
logic multistate_thread2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread2_comb     // test_single_state_thread.cpp:152:5
    multistate_thread2_func;
end
function void multistate_thread2_func;
    t7_next = t7;
    x_next6 = x6;
    multistate_thread2_PROC_STATE_next = multistate_thread2_PROC_STATE;
    
    case (multistate_thread2_PROC_STATE)
        0: begin
            // Call wait_method() begin
            multistate_thread2_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:148:9;
            // Call wait_method() end
        end
        1: begin
            x_next6++;
            t7_next = x_next6;
            multistate_thread2_PROC_STATE_next = 0; return;    // test_single_state_thread.cpp:155:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread2_ff
    if ( ~rstn ) begin
        x6 <= 0;
        multistate_thread2_PROC_STATE <= 0;    // test_single_state_thread.cpp:155:13;
    end
    else begin
        x6 <= x_next6;
        t7 <= t7_next;
        multistate_thread2_PROC_STATE <= multistate_thread2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread3 (test_single_state_thread.cpp:163:5) 

// Thread-local variables
logic signed [31:0] x7;
logic signed [31:0] x_next7;
logic signed [31:0] t7a_next;
logic multistate_thread3_PROC_STATE;
logic multistate_thread3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread3_comb     // test_single_state_thread.cpp:163:5
    multistate_thread3_func;
end
function void multistate_thread3_func;
    t7a_next = t7a;
    x_next7 = x7;
    multistate_thread3_PROC_STATE_next = multistate_thread3_PROC_STATE;
    
    case (multistate_thread3_PROC_STATE)
        0: begin
            // Call wait_wrapper() begin
            multistate_thread3_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:32:5;
            // Call wait_wrapper() end
        end
        1: begin
            t7a_next = x_next7++;
            multistate_thread3_PROC_STATE_next = 0; return;    // test_single_state_thread.cpp:166:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread3_ff
    if ( ~rstn ) begin
        x7 <= 0;
        multistate_thread3_PROC_STATE <= 0;    // test_single_state_thread.cpp:166:13;
    end
    else begin
        x7 <= x_next7;
        t7a <= t7a_next;
        multistate_thread3_PROC_STATE <= multistate_thread3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread4 (test_single_state_thread.cpp:173:5) 

// Thread-local variables
logic signed [31:0] x8;
logic signed [31:0] x_next8;
logic signed [31:0] t8_next;
logic signed [31:0] wptr_y;
logic signed [31:0] wptr_y_next;
logic multistate_thread4_PROC_STATE;
logic multistate_thread4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread4_comb     // test_single_state_thread.cpp:173:5
    multistate_thread4_func;
end
function void multistate_thread4_func;
    t8_next = t8;
    wptr_y_next = wptr_y;
    x_next8 = x8;
    multistate_thread4_PROC_STATE_next = multistate_thread4_PROC_STATE;
    
    case (multistate_thread4_PROC_STATE)
        0: begin
            // Call vwait() begin
            wptr_y_next = wptr_y_next + 2;
            multistate_thread4_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:26:9;
            // Call vwait() end
        end
        1: begin
            x_next8++;
            t8_next = x_next8;
            multistate_thread4_PROC_STATE_next = 0; return;    // test_single_state_thread.cpp:176:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread4_ff
    if ( ~rstn ) begin
        x8 <= 0;
        multistate_thread4_PROC_STATE <= 0;    // test_single_state_thread.cpp:176:13;
    end
    else begin
        x8 <= x_next8;
        t8 <= t8_next;
        wptr_y <= wptr_y_next;
        multistate_thread4_PROC_STATE <= multistate_thread4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread5 (test_single_state_thread.cpp:189:5) 

// Thread-local variables
logic signed [31:0] x9;
logic signed [31:0] x_next9;
logic signed [31:0] t9_next;
logic signed [31:0] wd_y;
logic signed [31:0] wd_y_next;
logic multistate_thread5_PROC_STATE;
logic multistate_thread5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread5_comb     // test_single_state_thread.cpp:189:5
    multistate_thread5_func;
end
function void multistate_thread5_func;
    t9_next = t9;
    wd_y_next = wd_y;
    x_next9 = x9;
    multistate_thread5_PROC_STATE_next = multistate_thread5_PROC_STATE;
    
    case (multistate_thread5_PROC_STATE)
        0: begin
            // Call wbase_invoker() begin
            // Call vwait() begin
            wd_y_next = wd_y_next + 2;
            multistate_thread5_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:26:9;
            // Call vwait() end
            // Call wbase_invoker() end
        end
        1: begin
            t9_next = x_next9++;
            multistate_thread5_PROC_STATE_next = 0; return;    // test_single_state_thread.cpp:192:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread5_ff
    if ( ~rstn ) begin
        x9 <= 0;
        multistate_thread5_PROC_STATE <= 0;    // test_single_state_thread.cpp:192:13;
    end
    else begin
        x9 <= x_next9;
        t9 <= t9_next;
        wd_y <= wd_y_next;
        multistate_thread5_PROC_STATE <= multistate_thread5_PROC_STATE_next;
    end
end

endmodule


