//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic [3:0] s;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;

//------------------------------------------------------------------------------
// Method process: no_sens_method (test_fcall_empty.cpp:50:5) 

integer a;
assign a = 1;
assign t0 = a;

//------------------------------------------------------------------------------
// Method process: empty_if_method (test_fcall_empty.cpp:56:5) 

always_comb 
begin : empty_if_method     // test_fcall_empty.cpp:56:5
    integer a_1;
    a_1 = '0;
    if (|s)
    begin
    end
    if (|s)
    begin
    end
    if (|s)
    begin
        a_1 = 1;
    end
    if (|s)
    begin
    end else begin
        a_1 = 2;
    end
    if (|s)
    begin
        a_1 = 3;
    end
    t1 = a_1;
end

//------------------------------------------------------------------------------
// Method process: empty_loop_method (test_fcall_empty.cpp:81:5) 

always_comb 
begin : empty_loop_method     // test_fcall_empty.cpp:81:5
    integer a_1;
    integer j;
    a_1 = '0;
    for (int i = 0; i < 2; ++i)
    begin
    end
    for (int i_1 = 0; i_1 < 3; ++i_1)
    begin
        if (0)
        begin
        end
    end
    j = '0;
    while (j < 3)
    begin
        ++j;
    end
    t2 = a_1 + j;
end

//------------------------------------------------------------------------------
// Clocked THREAD: empty_loop_thread (test_fcall_empty.cpp:99:5) 

// Thread-local variables
logic [1:0] empty_loop_thread_PROC_STATE;
logic [1:0] empty_loop_thread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : empty_loop_thread_comb     // test_fcall_empty.cpp:99:5
    empty_loop_thread_func;
end
function void empty_loop_thread_func;
    integer a_1;
    empty_loop_thread_PROC_STATE_next = empty_loop_thread_PROC_STATE;
    
    case (empty_loop_thread_PROC_STATE)
        0: begin
            a_1 = '0;
            if (|s)
            begin
                empty_loop_thread_PROC_STATE_next = 1; return;    // test_fcall_empty.cpp:105:31;
            end
            empty_loop_thread_PROC_STATE_next = '0; return;    // test_fcall_empty.cpp:106:13;
        end
        1: begin
            if (|s)
            begin
                empty_loop_thread_PROC_STATE_next = 1; return;    // test_fcall_empty.cpp:105:31;
            end
            empty_loop_thread_PROC_STATE_next = '0; return;    // test_fcall_empty.cpp:106:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : empty_loop_thread_ff
    if ( ~nrst ) begin
        empty_loop_thread_PROC_STATE <= '0;    // test_fcall_empty.cpp:101:9;
    end
    else begin
        empty_loop_thread_PROC_STATE <= empty_loop_thread_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Method process: fcall_method (test_fcall_empty.cpp:112:5) 

always_comb 
begin : fcall_method     // test_fcall_empty.cpp:112:5
    // Call f() begin
    // Call f() end
end

//------------------------------------------------------------------------------
// Method process: trace_method (test_fcall_empty.cpp:152:5) 

always_comb 
begin : trace_method     // test_fcall_empty.cpp:152:5
    logic signed [1:0] flit_a;
    logic [2:0] flit_b;
    flit_a = '0;
    flit_b = '0;
    // Call Flit_t() begin
    // Call Flit_t() end
    // Call traceFlit() begin
    if (1)
    begin
    end
    // Call traceFlit() end
    // Call traceFlit2() begin
    if (1)
    begin
    end
    // Call traceFlit2() end
end

//------------------------------------------------------------------------------
// Clocked THREAD: trace_thread (test_fcall_empty.cpp:159:5) 

// Thread-local variables
logic signed [1:0] flit_a0;
logic signed [1:0] flit_a_next;
logic [2:0] flit_b0;
logic [2:0] flit_b_next;

// Next-state combinational logic
always_comb begin : trace_thread_comb     // test_fcall_empty.cpp:159:5
    trace_thread_func;
end
function void trace_thread_func;
    flit_a_next = flit_a0;
    flit_b_next = flit_b0;
    // Call traceFlit2() begin
    if (1)
    begin
    end
    // Call traceFlit2() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : trace_thread_ff
    if ( ~nrst ) begin
        flit_a0 <= '0;
        flit_b0 <= '0;
        // Call Flit_t() begin
        // Call Flit_t() end
        // Call traceFlit() begin
        if (1)
        begin
        end
        // Call traceFlit() end
    end
    else begin
        flit_a0 <= flit_a_next;
        flit_b0 <= flit_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: fcall_thread (test_fcall_empty.cpp:170:5) 

// Next-state combinational logic
always_comb begin : fcall_thread_comb     // test_fcall_empty.cpp:170:5
    fcall_thread_func;
end
function void fcall_thread_func;
    // Call f() begin
    // Call f() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : fcall_thread_ff
    if ( ~nrst ) begin
        // Call f() begin
        // Call f() end
    end
    else begin
    end
end

endmodule


