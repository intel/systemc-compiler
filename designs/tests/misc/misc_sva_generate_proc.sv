//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "test_top.a_mod"
(
    input logic clk,
    input logic rstn
);

// Variables generated for SystemC signals
logic signed [31:0] s;
logic signed [31:0] s_d;
logic signed [31:0] s_d2;
logic signed [31:0] ps;
logic signed [31:0] sarr[3];
logic [2:0] psarr[3];

// Local parameters generated for C++ constants
localparam logic [31:0] N = 2;
localparam logic signed [31:0] M = 3;

//------------------------------------------------------------------------------
// Clocked THREAD: thread_state_call1 (test_sva_generate_proc.cpp:151:5) 

// Thread-local variables
logic signed [31:0] s_next;

// Next-state combinational logic
always_comb begin : thread_state_call1_comb     // test_sva_generate_proc.cpp:151:5
    thread_state_call1_func;
end
function void thread_state_call1_func;
    integer TMP_0;
    integer par;
    logic [2:0] TMP_1;
    logic [7:0] val;
    integer TMP_2;
    s_next = s;
    par = 1;
    // Call f() begin
    val = par;
    // Call w_log2() begin
    TMP_1 = val == s ? 1 : 2;
    // Call w_log2() end
    TMP_0 = TMP_1;
    // Call f() end
    par = 2;
    // Call f() begin
    val = par;
    // Call w_log2() begin
    TMP_1 = val == s ? 1 : 2;
    // Call w_log2() end
    TMP_2 = TMP_1;
    // Call f() end
    s_next = TMP_0 + TMP_2;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread_state_call1_ff
    if ( ~rstn ) begin
    end
    else begin
        s <= s_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine155 : assert property ( |s |=> |s );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_state (test_sva_generate_proc.cpp:188:5) 

// Thread-local variables
logic signed [31:0] l;
logic signed [31:0] l_next;
logic signed [31:0] arr0[2];
logic signed [31:0] arr_next[2];

// Next-state combinational logic
always_comb begin : thread_state_comb     // test_sva_generate_proc.cpp:188:5
    thread_state_func;
end
function void thread_state_func;
    arr_next = arr0;
    l_next = l;
    l_next = s + 2'sd1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread_state_ff
    if ( ~rstn ) begin
        l <= '0;
    end
    else begin
        l <= l_next;
        arr0 <= arr_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine194 : assert property ( l_next == s |=> l_next != s );
        for (int unsigned i = 0; i < 2; i++) begin
            sctAssertLine197 : assert property ( |arr_next[i] |-> |arr_next[i] );
        end
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: zero_width (test_sva_generate_proc.cpp:207:5) 

// Next-state combinational logic
always_comb begin : zero_width_comb     // test_sva_generate_proc.cpp:207:5
    zero_width_func;
end
function void zero_width_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : zero_width_ff
    if ( ~rstn ) begin

    `ifndef INTEL_SVA_OFF
        sctAssertLine209r : assert property ( 1'd0 |-> 1'd0 );
        sctAssertLine210r : assert property ( 1'd0 |-> 1'd0 );
    `endif // INTEL_SVA_OFF
    end
    else begin

    `ifndef INTEL_SVA_OFF
        sctAssertLine209 : assert property ( 1'd0 |-> 1'd0 );
        sctAssertLine210 : assert property ( 1'd0 |-> 1'd0 );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_imm (test_sva_generate_proc.cpp:220:5) 

// Thread-local variables
logic signed [31:0] ii;
logic signed [31:0] ii_next;
logic sct_assert_imm_PROC_STATE;
logic sct_assert_imm_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sct_assert_imm_comb     // test_sva_generate_proc.cpp:220:5
    sct_assert_imm_func;
end
function void sct_assert_imm_func;
    integer mm;
    ii_next = ii;
    sct_assert_imm_PROC_STATE_next = sct_assert_imm_PROC_STATE;
    
    case (sct_assert_imm_PROC_STATE)
        0: begin
            mm = 3;
            `ifndef INTEL_SVA_OFF
                assert (mm != s) else $error("Assertion failed at test_sva_generate_proc.cpp:227:9");
            `endif // INTEL_SVA_OFF
            ii_next = s;
            sct_assert_imm_PROC_STATE_next = 1; return;    // test_sva_generate_proc.cpp:231:13;
        end
        1: begin
            `ifndef INTEL_SVA_OFF
                assert (ii_next == s_d) else $error("Assertion failed at test_sva_generate_proc.cpp:232:13");
            `endif // INTEL_SVA_OFF
            ii_next = s;
            sct_assert_imm_PROC_STATE_next = 1; return;    // test_sva_generate_proc.cpp:231:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_imm_ff
    if ( ~rstn ) begin
        integer kk;
        integer mm;
        ii <= '0;
        kk = 1;
        mm = 2;
        `ifndef INTEL_SVA_OFF
            assert (kk != s) else $error("Assertion failed at test_sva_generate_proc.cpp:223:9");
        `endif // INTEL_SVA_OFF
        sct_assert_imm_PROC_STATE <= '0;    // test_sva_generate_proc.cpp:224:9;
    end
    else begin
        ii <= ii_next;
        sct_assert_imm_PROC_STATE <= sct_assert_imm_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_imm_reg (test_sva_generate_proc.cpp:236:5) 

// Thread-local variables
logic signed [31:0] kk0;
logic signed [31:0] kk_next;
logic signed [31:0] mm0;
logic signed [31:0] mm_next;
logic sct_assert_imm_reg_PROC_STATE;
logic sct_assert_imm_reg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sct_assert_imm_reg_comb     // test_sva_generate_proc.cpp:236:5
    sct_assert_imm_reg_func;
end
function void sct_assert_imm_reg_func;
    kk_next = kk0;
    mm_next = mm0;
    sct_assert_imm_reg_PROC_STATE_next = sct_assert_imm_reg_PROC_STATE;
    
    case (sct_assert_imm_reg_PROC_STATE)
        0: begin
            mm_next = 3;
            `ifndef INTEL_SVA_OFF
                assert (mm_next != s) else $error("Assertion failed at test_sva_generate_proc.cpp:243:9");
            `endif // INTEL_SVA_OFF
            sct_assert_imm_reg_PROC_STATE_next = 1; return;    // test_sva_generate_proc.cpp:246:13;
        end
        1: begin
            `ifndef INTEL_SVA_OFF
                assert (mm_next == kk_next) else $error("Assertion failed at test_sva_generate_proc.cpp:247:13");
            `endif // INTEL_SVA_OFF
            sct_assert_imm_reg_PROC_STATE_next = 1; return;    // test_sva_generate_proc.cpp:246:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_imm_reg_ff
    if ( ~rstn ) begin
        kk0 <= 1;
        mm0 <= 2;
        `ifndef INTEL_SVA_OFF
            assert (kk0 != s) else $error("Assertion failed at test_sva_generate_proc.cpp:239:9");
        `endif // INTEL_SVA_OFF
        sct_assert_imm_reg_PROC_STATE <= '0;    // test_sva_generate_proc.cpp:240:9;
    end
    else begin
        kk0 <= kk_next;
        mm0 <= mm_next;
        sct_assert_imm_reg_PROC_STATE <= sct_assert_imm_reg_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_one (test_sva_generate_proc.cpp:252:5) 

// Next-state combinational logic
always_comb begin : sct_assert_one_comb     // test_sva_generate_proc.cpp:252:5
    sct_assert_one_func;
end
function void sct_assert_one_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_one_ff
    if ( ~rstn ) begin

    `ifndef INTEL_SVA_OFF
        sctAssertLine254r : assert property ( |s |=> |s_d );
    `endif // INTEL_SVA_OFF
    end
    else begin

    `ifndef INTEL_SVA_OFF
        sctAssertLine254 : assert property ( |s |=> |s_d );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_two_same (test_sva_generate_proc.cpp:263:5) 

// Next-state combinational logic
always_comb begin : sct_assert_two_same_comb     // test_sva_generate_proc.cpp:263:5
    sct_assert_two_same_func;
end
function void sct_assert_two_same_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_two_same_ff
    if ( ~rstn ) begin

    `ifndef INTEL_SVA_OFF
        sctAssertLine265r : assert property ( |s |=> |s_d );
    `endif // INTEL_SVA_OFF
    end
    else begin

    `ifndef INTEL_SVA_OFF
        sctAssertLine265 : assert property ( |s |=> |s_d );
        sctAssertLine267 : assert property ( |s |-> ##3 |s_d );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_several (test_sva_generate_proc.cpp:275:5) 

// Thread-local variables
logic a;
logic a_next;
logic [7:0] b;
logic [7:0] b_next;
logic arr[3];
logic arr_next0[3];

// Next-state combinational logic
always_comb begin : sct_assert_several_comb     // test_sva_generate_proc.cpp:275:5
    sct_assert_several_func;
end
function void sct_assert_several_func;
    a_next = a;
    arr_next0 = arr;
    b_next = b;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_several_ff
    if ( ~rstn ) begin
        a <= '0;
        b <= 1;
        arr[2] <= 1'd1;

    `ifndef INTEL_SVA_OFF
        sctAssertLine278r : assert property ( |s |=> s_d == a_next );
        sctAssertLine279r : assert property ( 1 |-> ##[2:3] |s_d2 && (ps == 1) );
        sctAssertLine280r : assert property ( |psarr[1] |-> ##[3:5] sarr[0] != arr_next0[2] );
    `endif // INTEL_SVA_OFF
    end
    else begin
        a <= a_next;
        b <= b_next;
        arr <= arr_next0;

    `ifndef INTEL_SVA_OFF
        sctAssertLine278 : assert property ( |s |=> s_d == a_next );
        sctAssertLine279 : assert property ( 1 |-> ##[2:3] |s_d2 && (ps == 1) );
        sctAssertLine280 : assert property ( |psarr[1] |-> ##[3:5] sarr[0] != arr_next0[2] );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_several_multi1 (test_sva_generate_proc.cpp:289:5) 

// Thread-local variables
logic [1:0] sct_assert_several_multi1_PROC_STATE;
logic [1:0] sct_assert_several_multi1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sct_assert_several_multi1_comb     // test_sva_generate_proc.cpp:289:5
    sct_assert_several_multi1_func;
end
function void sct_assert_several_multi1_func;
    sct_assert_several_multi1_PROC_STATE_next = sct_assert_several_multi1_PROC_STATE;
    
    case (sct_assert_several_multi1_PROC_STATE)
        0: begin
            sct_assert_several_multi1_PROC_STATE_next = 1; return;    // test_sva_generate_proc.cpp:295:13;
        end
        1: begin
            sct_assert_several_multi1_PROC_STATE_next = '0; return;    // test_sva_generate_proc.cpp:297:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_several_multi1_ff
    if ( ~rstn ) begin
        sct_assert_several_multi1_PROC_STATE <= '0;    // test_sva_generate_proc.cpp:292:9;

    `ifndef INTEL_SVA_OFF
        sctAssertLine291r : assert property ( |s |=> |s_d );
    `endif // INTEL_SVA_OFF
    end
    else begin
        sct_assert_several_multi1_PROC_STATE <= sct_assert_several_multi1_PROC_STATE_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine291 : assert property ( |s |=> |s_d );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_several_multi2 (test_sva_generate_proc.cpp:302:5) 

// Thread-local variables
logic [1:0] sct_assert_several_multi2_PROC_STATE;
logic [1:0] sct_assert_several_multi2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sct_assert_several_multi2_comb     // test_sva_generate_proc.cpp:302:5
    sct_assert_several_multi2_func;
end
function void sct_assert_several_multi2_func;
    sct_assert_several_multi2_PROC_STATE_next = sct_assert_several_multi2_PROC_STATE;
    
    case (sct_assert_several_multi2_PROC_STATE)
        0: begin
            if (|s)
            begin
                sct_assert_several_multi2_PROC_STATE_next = 1; return;    // test_sva_generate_proc.cpp:309:17;
            end
            sct_assert_several_multi2_PROC_STATE_next = '0; return;    // test_sva_generate_proc.cpp:312:13;
        end
        1: begin
            sct_assert_several_multi2_PROC_STATE_next = '0; return;    // test_sva_generate_proc.cpp:312:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(negedge clk or negedge rstn) 
begin : sct_assert_several_multi2_ff
    if ( ~rstn ) begin
        sct_assert_several_multi2_PROC_STATE <= '0;    // test_sva_generate_proc.cpp:305:9;

    `ifndef INTEL_SVA_OFF
        sctAssertLine304r : assert property ( |s |=> |s_d );
    `endif // INTEL_SVA_OFF
    end
    else begin
        sct_assert_several_multi2_PROC_STATE <= sct_assert_several_multi2_PROC_STATE_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine304 : assert property ( |s |=> |s_d );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_several_multi3 (test_sva_generate_proc.cpp:317:5) 

// Thread-local variables
logic [1:0] sct_assert_several_multi3_PROC_STATE;
logic [1:0] sct_assert_several_multi3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sct_assert_several_multi3_comb     // test_sva_generate_proc.cpp:317:5
    sct_assert_several_multi3_func;
end
function void sct_assert_several_multi3_func;
    sct_assert_several_multi3_PROC_STATE_next = sct_assert_several_multi3_PROC_STATE;
    
    case (sct_assert_several_multi3_PROC_STATE)
        0: begin
            if (|s)
            begin
                sct_assert_several_multi3_PROC_STATE_next = '0; return;    // test_sva_generate_proc.cpp:327:17;
            end else begin
                sct_assert_several_multi3_PROC_STATE_next = '0; return;    // test_sva_generate_proc.cpp:331:17;
            end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_several_multi3_ff
    if ( ~rstn ) begin
        sct_assert_several_multi3_PROC_STATE <= '0;    // test_sva_generate_proc.cpp:321:9;

    `ifndef INTEL_SVA_OFF
        sctAssertLine320r : assert property ( |s |=> |s_d );
    `endif // INTEL_SVA_OFF
    end
    else begin
        sct_assert_several_multi3_PROC_STATE <= sct_assert_several_multi3_PROC_STATE_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine320 : assert property ( |s |=> |s_d );
        sctAssertLine322 : assert property ( |s |-> ##2 |s_d2 );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_thread_var1 (test_sva_generate_proc.cpp:337:5) 

// Thread-local variables
logic [31:0] c;
logic [31:0] c_next;
logic [15:0] d;
logic [15:0] d_next;

// Next-state combinational logic
always_comb begin : sct_assert_thread_var1_comb     // test_sva_generate_proc.cpp:337:5
    sct_assert_thread_var1_func;
end
function void sct_assert_thread_var1_func;
    c_next = c;
    d_next = d;
    d_next = s_d;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_thread_var1_ff
    if ( ~rstn ) begin
        d <= 7;
        c <= s;

    `ifndef INTEL_SVA_OFF
        sctAssertLine341r : assert property ( |c_next |=> d_next == 1'd1 );
    `endif // INTEL_SVA_OFF
    end
    else begin
        c <= c_next;
        d <= d_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine341 : assert property ( |c_next |=> d_next == 1'd1 );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_thread_var2 (test_sva_generate_proc.cpp:351:5) 

// Thread-local variables
logic [3:0] rec_b;
logic [3:0] rec_b_next;
logic rec_a;
logic rec_a_next;

// Next-state combinational logic
always_comb begin : sct_assert_thread_var2_comb     // test_sva_generate_proc.cpp:351:5
    sct_assert_thread_var2_func;
end
function void sct_assert_thread_var2_func;
    rec_a_next = rec_a;
    rec_b_next = rec_b;
    rec_b_next = s_d;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_thread_var2_ff
    if ( ~rstn ) begin
        rec_a <= '0;
    end
    else begin
        rec_b <= rec_b_next;
        rec_a <= rec_a_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine356 : assert property ( rec_a_next |=> rec_b_next != s );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_thread_loc1 (test_sva_generate_proc.cpp:365:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next;

// Next-state combinational logic
always_comb begin : sct_assert_thread_loc1_comb     // test_sva_generate_proc.cpp:365:5
    sct_assert_thread_loc1_func;
end
function void sct_assert_thread_loc1_func;
    i_next = i0;
    i_next = s;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_thread_loc1_ff
    if ( ~rstn ) begin
        i0 <= '0;

    `ifndef INTEL_SVA_OFF
        sctAssertLine368r : assert property ( |s |=> i_next == s_d );
    `endif // INTEL_SVA_OFF
    end
    else begin
        i0 <= i_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine368 : assert property ( |s |=> i_next == s_d );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_thread_loc2 (test_sva_generate_proc.cpp:378:5) 

// Thread-local variables
logic signed [31:0] i1;
logic signed [31:0] i_next0;

// Next-state combinational logic
always_comb begin : sct_assert_thread_loc2_comb     // test_sva_generate_proc.cpp:378:5
    sct_assert_thread_loc2_func;
end
function void sct_assert_thread_loc2_func;
    i_next0 = i1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_thread_loc2_ff
    if ( ~rstn ) begin
        i1 <= s;

    `ifndef INTEL_SVA_OFF
        sctAssertLine381r : assert property ( |s |-> |i_next0 );
    `endif // INTEL_SVA_OFF
    end
    else begin
        i1 <= i_next0;

    `ifndef INTEL_SVA_OFF
        sctAssertLine381 : assert property ( |s |-> |i_next0 );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_thread_loc3 (test_sva_generate_proc.cpp:389:5) 

// Thread-local variables
logic signed [31:0] i2;
logic signed [31:0] i_next1;
logic j;
logic j_next;
logic k;
logic k_next;
logic signed [31:0] l0;
logic signed [31:0] l_next0;
logic [1:0] sct_assert_thread_loc3_PROC_STATE;
logic [1:0] sct_assert_thread_loc3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sct_assert_thread_loc3_comb     // test_sva_generate_proc.cpp:389:5
    sct_assert_thread_loc3_func;
end
function void sct_assert_thread_loc3_func;
    i_next1 = i2;
    j_next = j;
    k_next = k;
    l_next0 = l0;
    sct_assert_thread_loc3_PROC_STATE_next = sct_assert_thread_loc3_PROC_STATE;
    
    case (sct_assert_thread_loc3_PROC_STATE)
        0: begin
            sct_assert_thread_loc3_PROC_STATE_next = 1; return;    // test_sva_generate_proc.cpp:399:13;
        end
        1: begin
            j_next = i_next1 == s;
            k_next = l_next0 == s;
            sct_assert_thread_loc3_PROC_STATE_next = '0; return;    // test_sva_generate_proc.cpp:403:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_thread_loc3_ff
    if ( ~rstn ) begin
        j <= '0;
        i2 <= '0;
        k <= '0;
        l0 <= '0;
        sct_assert_thread_loc3_PROC_STATE <= '0;    // test_sva_generate_proc.cpp:394:9;

    `ifndef INTEL_SVA_OFF
        sctAssertLine393r : assert property ( 0 |=> |s_d );
    `endif // INTEL_SVA_OFF
    end
    else begin
        i2 <= i_next1;
        j <= j_next;
        k <= k_next;
        l0 <= l_next0;
        sct_assert_thread_loc3_PROC_STATE <= sct_assert_thread_loc3_PROC_STATE_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine393 : assert property ( 0 |=> |s_d );
        sctAssertLine396 : assert property ( k_next || |l_next0 |-> ##[2:3] |s );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_cond (test_sva_generate_proc.cpp:408:5) 

// Next-state combinational logic
always_comb begin : sct_assert_cond_comb     // test_sva_generate_proc.cpp:408:5
    sct_assert_cond_func;
end
function void sct_assert_cond_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_cond_ff
    if ( ~rstn ) begin
    end
    else begin

    `ifndef INTEL_SVA_OFF
        sctAssertLine413 : assert property ( |s |-> ##2 |s_d2 );
    `endif // INTEL_SVA_OFF
    end
end

endmodule


