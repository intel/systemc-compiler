//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.14
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic [3:0] s;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;
logic signed [31:0] t3;
logic signed [31:0] t4;

// Local parameters generated for C++ constants
localparam logic C1 = 1;
localparam logic C2 = 0;
localparam logic arr[3] = '{ 1, 1, 0 };
localparam logic [31:0] DD[2] = '{ 42, 43 };
localparam logic [31:0] SS[3][2] = '{ '{ 42, 43 }, '{ 44, 45 }, '{ 46, 47 } };
localparam logic [31:0] mif_GG[2][2] = '{ '{ 42, 43 }, '{ 42, 43 } };
localparam logic [31:0] mif_PP[2][3][2] = '{ '{ '{ 42, 43 }, '{ 44, 45 }, '{ 46, 47 } }, '{ '{ 42, 43 }, '{ 44, 45 }, '{ 46, 47 } } };
localparam logic signed [31:0] mif_K = 42;
localparam logic [31:0] mif_G[2] = '{ 42, 43 };
localparam logic [31:0] mif_P[3][2] = '{ '{ 42, 43 }, '{ 44, 45 }, '{ 46, 47 } };
localparam logic signed [31:0] B = 42;
localparam logic signed [31:0] E[3] = '{ -7'sd41, 42, 43 };
localparam logic [31:0] D[2] = '{ 42, 43 };
localparam logic [31:0] S[3][2] = '{ '{ 42, 43 }, '{ 44, 45 }, '{ 46, 47 } };
localparam logic [31:0] L[3][2] = '{ '{ 42, 43 }, '{ 44, 45 }, '{ 46, 47 } };
localparam logic [31:0] LL[3][2] = '{ '{ 42, 43 }, '{ 44, 45 }, '{ 46, 47 } };

//------------------------------------------------------------------------------
// Method process: array_method (test_const_array.cpp:75:5) 

always_comb 
begin : array_method     // test_const_array.cpp:75:5
    logic larr[3];
    logic b1;
    logic b2;
    larr[0] = 1; larr[1] = 1; larr[2] = 0;
    b1 = arr[1];
    b1 = larr[1];
    b2 = C1;
    b2 = C2;
    t0 = b1 + b2;
end

//------------------------------------------------------------------------------
// Method process: array_method2 (test_const_array.cpp:87:5) 

always_comb 
begin : array_method2     // test_const_array.cpp:87:5
    integer l;
    l = D[s - 1];
    l = DD[s + 1];
    l = L[0][s];
    l = LL[s][0];
    t1 = l;
    t1 = B + E[1];
end

//------------------------------------------------------------------------------
// Clocked THREAD: array_thrd (test_const_array.cpp:100:5) 

// Thread-local variables
logic signed [31:0] t2_next;
logic array_thrd_PROC_STATE;
logic array_thrd_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : array_thrd_comb     // test_const_array.cpp:100:5
    array_thrd_func;
end
function void array_thrd_func;
    integer i;
    t2_next = t2;
    array_thrd_PROC_STATE_next = array_thrd_PROC_STATE;
    
    case (array_thrd_PROC_STATE)
        0: begin
            t2_next = E[s];
            array_thrd_PROC_STATE_next = 1; return;    // test_const_array.cpp:106:13;
        end
        1: begin
            t2_next = C1 + D[s];
            t2_next = S[s - 1][s + 1];
            t2_next = SS[s - 1][s + 1];
            t2_next = E[s];
            array_thrd_PROC_STATE_next = 1; return;    // test_const_array.cpp:106:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : array_thrd_ff
    if ( ~nrst ) begin
        integer i;
        i = E[1];
        t2 <= i + D[1] + S[0][0] + SS[1][1];
        array_thrd_PROC_STATE <= 0;    // test_const_array.cpp:103:9;
    end
    else begin
        t2 <= t2_next;
        array_thrd_PROC_STATE <= array_thrd_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Method process: mif_method (test_const_array.cpp:115:5) 

always_comb 
begin : mif_method     // test_const_array.cpp:115:5
    integer l;
    integer TMP_0;
    integer indx;
    l = mif_K;
    l = mif_G[0] + mif_G[0];
    l = mif_GG[1][0];
    l = mif_G[0];
    l = mif_GG[s][0];
    l = mif_P[0][s];
    l = mif_PP[s][s - 1][s + 1];
    l = mif_G[s - 1];
    indx = s;
    // Call getG() begin
    TMP_0 = mif_G[indx];
    // Call getG() end
    l = TMP_0;
    t3 = l;
    t3 = mif_G[1];
end

//------------------------------------------------------------------------------
// Clocked THREAD: mif_thrd (test_const_array.cpp:137:5) 

// Thread-local variables
logic signed [31:0] t4_next;

// Next-state combinational logic
always_comb begin : mif_thrd_comb     // test_const_array.cpp:137:5
    mif_thrd_func;
end
function void mif_thrd_func;
    integer unsigned l;
    integer TMP_2;
    integer indx;
    integer TMP_3;
    integer TMP_4;
    t4_next = t4;
    indx = s;
    // Call getG() begin
    TMP_2 = mif_G[indx];
    // Call getG() end
    l = TMP_2;
    indx = s;
    // Call getG() begin
    TMP_3 = mif_G[indx];
    // Call getG() end
    l = l + TMP_3;
    l = mif_P[0][s];
    l = mif_PP[s][s - 1][s + 1];
    t4_next = l;
    t4_next = mif_G[s];
    t4_next = mif_G[s + 1];
    indx = s + 1;
    // Call getG() begin
    TMP_4 = mif_G[indx];
    // Call getG() end
    t4_next = TMP_4;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : mif_thrd_ff
    if ( ~nrst ) begin
        t4 <= 43;
        t4 <= mif_G[0];
        t4 <= 42;
    end
    else begin
        t4 <= t4_next;
    end
end

endmodule


