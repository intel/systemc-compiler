//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.14
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "test_top.a_mod"
(
    input logic clk,
    input logic rstn
);

// Variables generated for SystemC signals
logic signed [31:0] s;
logic signed [31:0] s_d;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_imm (test_sva_generate_proc_off.cpp:109:5) 

// Thread-local variables
logic signed [31:0] ii;
logic signed [31:0] ii_next;
logic sct_assert_imm_PROC_STATE;
logic sct_assert_imm_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sct_assert_imm_comb     // test_sva_generate_proc_off.cpp:109:5
    sct_assert_imm_func;
end
function void sct_assert_imm_func;
    integer kk;
    integer mm;
    ii_next = ii;
    sct_assert_imm_PROC_STATE_next = sct_assert_imm_PROC_STATE;
    
    case (sct_assert_imm_PROC_STATE)
        0: begin
            mm = 3;
            `ifndef INTEL_SVA_OFF
                assert (mm != s) else $error("Assertion failed at test_sva_generate_proc_off.cpp:116:9");
            `endif // INTEL_SVA_OFF
            ii_next = s;
            sct_assert_imm_PROC_STATE_next = 1; return;    // test_sva_generate_proc_off.cpp:120:13;
        end
        1: begin
            `ifndef INTEL_SVA_OFF
                assert (ii_next == s_d) else $error("Assertion failed at test_sva_generate_proc_off.cpp:121:13");
            `endif // INTEL_SVA_OFF
            ii_next = s;
            sct_assert_imm_PROC_STATE_next = 1; return;    // test_sva_generate_proc_off.cpp:120:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_imm_ff
    if ( ~rstn ) begin
        integer kk;
        integer mm;
        ii <= 0;
        kk = 1;
        mm = 2;
        `ifndef INTEL_SVA_OFF
            assert (kk != s) else $error("Assertion failed at test_sva_generate_proc_off.cpp:112:9");
        `endif // INTEL_SVA_OFF
        sct_assert_imm_PROC_STATE <= 0;    // test_sva_generate_proc_off.cpp:113:9;
    end
    else begin
        ii <= ii_next;
        sct_assert_imm_PROC_STATE <= sct_assert_imm_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_imm_reg (test_sva_generate_proc_off.cpp:125:5) 

// Thread-local variables
logic signed [31:0] kk0;
logic signed [31:0] kk_next;
logic signed [31:0] mm0;
logic signed [31:0] mm_next;
logic sct_assert_imm_reg_PROC_STATE;
logic sct_assert_imm_reg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sct_assert_imm_reg_comb     // test_sva_generate_proc_off.cpp:125:5
    sct_assert_imm_reg_func;
end
function void sct_assert_imm_reg_func;
    kk_next = kk0;
    mm_next = mm0;
    sct_assert_imm_reg_PROC_STATE_next = sct_assert_imm_reg_PROC_STATE;
    
    case (sct_assert_imm_reg_PROC_STATE)
        0: begin
            mm_next = 3;
            `ifndef INTEL_SVA_OFF
                assert (mm_next != s) else $error("Assertion failed at test_sva_generate_proc_off.cpp:132:9");
            `endif // INTEL_SVA_OFF
            sct_assert_imm_reg_PROC_STATE_next = 1; return;    // test_sva_generate_proc_off.cpp:135:13;
        end
        1: begin
            `ifndef INTEL_SVA_OFF
                assert (mm_next == kk_next) else $error("Assertion failed at test_sva_generate_proc_off.cpp:136:13");
            `endif // INTEL_SVA_OFF
            sct_assert_imm_reg_PROC_STATE_next = 1; return;    // test_sva_generate_proc_off.cpp:135:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_imm_reg_ff
    if ( ~rstn ) begin
        kk0 <= 1;
        mm0 <= 2;
        `ifndef INTEL_SVA_OFF
            assert (kk0 != s) else $error("Assertion failed at test_sva_generate_proc_off.cpp:128:9");
        `endif // INTEL_SVA_OFF
        sct_assert_imm_reg_PROC_STATE <= 0;    // test_sva_generate_proc_off.cpp:129:9;
    end
    else begin
        kk0 <= kk_next;
        mm0 <= mm_next;
        sct_assert_imm_reg_PROC_STATE <= sct_assert_imm_reg_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_one (test_sva_generate_proc_off.cpp:141:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_two_same (test_sva_generate_proc_off.cpp:152:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_several (test_sva_generate_proc_off.cpp:164:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_several_multi1 (test_sva_generate_proc_off.cpp:177:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_several_multi2 (test_sva_generate_proc_off.cpp:190:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_several_multi3 (test_sva_generate_proc_off.cpp:205:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_thread_var1 (test_sva_generate_proc_off.cpp:226:5) 

// Thread-local variables
logic signed [31:0] t0_next;
logic [15:0] d;

// Next-state combinational logic
always_comb begin : sct_assert_thread_var1_comb     // test_sva_generate_proc_off.cpp:226:5
    sct_assert_thread_var1_func;
end
function void sct_assert_thread_var1_func;
    t0_next = t0;
    d = s_d;
    t0_next = d;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_thread_var1_ff
    if ( ~rstn ) begin
    end
    else begin
        t0 <= t0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_thread_var2 (test_sva_generate_proc_off.cpp:240:5) 

// Thread-local variables
logic rec_a;
logic [3:0] rec_b;

// Next-state combinational logic
always_comb begin : sct_assert_thread_var2_comb     // test_sva_generate_proc_off.cpp:240:5
    sct_assert_thread_var2_func;
end
function void sct_assert_thread_var2_func;
    rec_b = s_d;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_thread_var2_ff
    if ( ~rstn ) begin
        logic rec_a;
        rec_a = 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_thread_loc1 (test_sva_generate_proc_off.cpp:255:5) 

// Thread-local variables
logic signed [31:0] t1_next;

// Next-state combinational logic
always_comb begin : sct_assert_thread_loc1_comb     // test_sva_generate_proc_off.cpp:255:5
    sct_assert_thread_loc1_func;
end
function void sct_assert_thread_loc1_func;
    integer i;
    t1_next = t1;
    i = s;
    t1_next = i;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_thread_loc1_ff
    if ( ~rstn ) begin
        integer i;
        i = 0;
    end
    else begin
        t1 <= t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_thread_loc2 (test_sva_generate_proc_off.cpp:269:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_thread_loc3 (test_sva_generate_proc_off.cpp:281:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic signed [31:0] l;
logic signed [31:0] l_next;
logic signed [31:0] t2_next;
logic [1:0] sct_assert_thread_loc3_PROC_STATE;
logic [1:0] sct_assert_thread_loc3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sct_assert_thread_loc3_comb     // test_sva_generate_proc_off.cpp:281:5
    sct_assert_thread_loc3_func;
end
function void sct_assert_thread_loc3_func;
    logic j;
    logic k;
    i_next = i0;
    l_next = l;
    t2_next = t2;
    sct_assert_thread_loc3_PROC_STATE_next = sct_assert_thread_loc3_PROC_STATE;
    
    case (sct_assert_thread_loc3_PROC_STATE)
        0: begin
            sct_assert_thread_loc3_PROC_STATE_next = 1; return;    // test_sva_generate_proc_off.cpp:291:13;
        end
        1: begin
            j = i_next == s;
            k = l_next == s;
            t2_next = k + j;
            sct_assert_thread_loc3_PROC_STATE_next = 0; return;    // test_sva_generate_proc_off.cpp:296:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : sct_assert_thread_loc3_ff
    if ( ~rstn ) begin
        logic j;
        logic k;
        j = 0;
        i0 <= 0;
        k = 0;
        l <= 0;
        sct_assert_thread_loc3_PROC_STATE <= 0;    // test_sva_generate_proc_off.cpp:286:9;
    end
    else begin
        i0 <= i_next;
        l <= l_next;
        t2 <= t2_next;
        sct_assert_thread_loc3_PROC_STATE <= sct_assert_thread_loc3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_cond (test_sva_generate_proc_off.cpp:301:5) 
// Empty process, no code generated 

endmodule


