//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic req[3];
logic [15:0] data[3];
logic signed [31:0] req2D[3][2];

// Local parameters generated for C++ constants
localparam logic [31:0] N = 3;

//------------------------------------------------------------------------------
// Clocked THREAD: mainProc (test_sc_vector2.cpp:95:5) 

// Thread-local variables
logic req_next[3];
logic [1:0] mainProc_PROC_STATE;
logic [1:0] mainProc_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : mainProc_comb     // test_sc_vector2.cpp:95:5
    mainProc_func;
end
function void mainProc_func;
    req_next = req;
    mainProc_PROC_STATE_next = mainProc_PROC_STATE;
    
    case (mainProc_PROC_STATE)
        0: begin
            req_next[0] = 1'd1;
            mainProc_PROC_STATE_next = 1; return;    // test_sc_vector2.cpp:104:13;
        end
        1: begin
            req_next[0] = '0;
            if (!(|data[1]))
            begin
                mainProc_PROC_STATE_next = 2; return;    // test_sc_vector2.cpp:107:37;
            end
            req_next[1] = 1'd1;
            mainProc_PROC_STATE_next = 3; return;    // test_sc_vector2.cpp:109:13;
        end
        2: begin
            if (!(|data[1]))
            begin
                mainProc_PROC_STATE_next = 2; return;    // test_sc_vector2.cpp:107:37;
            end
            req_next[1] = 1'd1;
            mainProc_PROC_STATE_next = 3; return;    // test_sc_vector2.cpp:109:13;
        end
        3: begin
            req_next[1] = '0;
            req_next[0] = 1'd1;
            mainProc_PROC_STATE_next = 1; return;    // test_sc_vector2.cpp:104:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : mainProc_ff
    if ( ~rstn ) begin
        for (int i = 1; i < N; ++i)
        begin
            req[i] <= '0;
            req2D[i][0] <= i;
        end
        mainProc_PROC_STATE <= '0;    // test_sc_vector2.cpp:100:9;
    end
    else begin
        req <= req_next;
        mainProc_PROC_STATE <= mainProc_PROC_STATE_next;
    end
end


//------------------------------------------------------------------------------
// Child module instances

Producer p
(
  .clk(clk),
  .rstn(rstn),
  .req(req),
  .data(data),
  .req2D(req2D)
);

endmodule



//==============================================================================
//
// Module: Producer (test_sc_vector2.cpp:77:5)
//
module Producer // "top.p"
(
    input logic clk,
    input logic rstn,
    input logic req[3],
    output logic [15:0] data[3],
    input logic signed [31:0] req2D[3][2]
);

// Variables generated for SystemC signals
logic greq;

//------------------------------------------------------------------------------
// Method process: methProc (test_sc_vector2.cpp:40:5) 

always_comb 
begin : methProc     // test_sc_vector2.cpp:40:5
    logic a;
    a = '0;
    for (int i = 0; i < 3; ++i)
    begin
        a = a || req[i] || |req2D[i][0];
    end
    greq = a;
end

//------------------------------------------------------------------------------
// Clocked THREAD: threadProc (test_sc_vector2.cpp:49:5) 

// Thread-local variables
logic [15:0] data_next[3];
logic [3:0] n;
logic [3:0] n_next;

// Next-state combinational logic
always_comb begin : threadProc_comb     // test_sc_vector2.cpp:49:5
    threadProc_func;
end
function void threadProc_func;
    data_next = data;
    n_next = n;
    if (greq)
    begin
        for (int i = 1; i < 3; ++i)
        begin
            data_next[i] = data[i - 1];
        end
    end
    data_next[0] = n_next++;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : threadProc_ff
    if ( ~rstn ) begin
        n <= 1'd1;
        data[0] <= '0;
    end
    else begin
        data <= data_next;
        n <= n_next;
    end
end

endmodule


