//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.30
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic [3:0] s;
logic signed [31:0] t1;
logic signed [31:0] t2;

// Local parameters generated for C++ constants
localparam logic [31:0] E = '0;

//------------------------------------------------------------------------------
// Method process: mif_method (test_static_array.cpp:53:5) 

// Process-local variables
logic [31:0] mif_I;
logic [31:0] mif_JJ[3][2];
logic [31:0] mif_J[2];
logic [31:0] D[2];

always_comb 
begin : mif_method     // test_static_array.cpp:53:5
    integer l;
    l = mif_I;
    l = mif_I;
    l = mif_JJ[0][0];
    l = mif_J[s];
    mif_I = mif_J[0];
    l = D[s];
    t1 = l;
end

//------------------------------------------------------------------------------
// Clocked THREAD: mif_thrd (test_static_array.cpp:66:5) 

// Thread-local variables
logic [31:0] mif_K[2][3];
logic [31:0] mif_K_next[2][3];
logic signed [31:0] t2_next;
logic [31:0] DD[2];
logic [31:0] DD_next[2];

// Next-state combinational logic
always_comb begin : mif_thrd_comb     // test_static_array.cpp:66:5
    mif_thrd_func;
end
function void mif_thrd_func;
    DD_next = DD;
    mif_K_next = mif_K;
    t2_next = 32'(mif_K_next[s + 1][s - 1] + DD_next[s]);
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : mif_thrd_ff
    if ( ~nrst ) begin
        integer unsigned l;
        l = 32'(mif_K[0][1] + E);
        t2 <= l;
    end
    else begin
        mif_K <= mif_K_next;
        t2 <= t2_next;
        DD <= DD_next;
    end
end

endmodule


