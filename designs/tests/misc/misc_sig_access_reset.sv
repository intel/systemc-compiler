//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic s;
logic t;
logic ta;
logic tb;
logic [7:0] r;
logic [7:0] ra;
logic [7:0] rb;
logic signed [31:0] t0;
logic signed [31:0] t1;

// Local parameters generated for C++ constants
localparam logic signed [31:0] b = 11;
localparam logic signed [7:0] d = 7;

//------------------------------------------------------------------------------
// Clocked THREAD: loc_var_reset (test_sig_access_reset.cpp:47:6) 

// Thread-local variables
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : loc_var_reset_comb     // test_sig_access_reset.cpp:47:6
    loc_var_reset_func;
end
function void loc_var_reset_func;
    logic [3:0] j3;
    t0_next = t0;
    j3 = 2;
    t0_next = j3;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_var_reset_ff
    if ( rst ) begin
        logic [3:0] j3;
        j3 = '0;
        t0 <= j3;
    end
    else begin
        t0 <= t0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_var_body (test_sig_access_reset.cpp:64:5) 

// Next-state combinational logic
always_comb begin : loc_var_body_comb     // test_sig_access_reset.cpp:64:5
    loc_var_body_func;
end
function void loc_var_body_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_var_body_ff
    if ( rst ) begin
        logic j1;
        integer j2;
        logic [3:0] j3;
        j1 = 1'd1;
        j2 = 2;
        j3 = j2 + 2'sd1;
        t1 <= j3;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sig_thread (test_sig_access_reset.cpp:76:5) 

// Next-state combinational logic
always_comb begin : sig_thread_comb     // test_sig_access_reset.cpp:76:5
    sig_thread_func;
end
function void sig_thread_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : sig_thread_ff
    if ( rst ) begin
        s <= 1'd1;
        t <= '0;
        r <= '0;
        ta <= '0;
        ra <= '0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: assert_sig (test_sig_access_reset.cpp:87:5) 

// Thread-local variables
logic tb_next;
logic [7:0] rb_next;

// Next-state combinational logic
always_comb begin : assert_sig_comb     // test_sig_access_reset.cpp:87:5
    assert_sig_func;
end
function void assert_sig_func;
    rb_next = rb;
    tb_next = tb;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : assert_sig_ff
    if ( rst ) begin
        tb <= '0;
        rb <= '0;

    `ifndef INTEL_SVA_OFF
        sctAssertLine90r : assert property ( t |-> |r );
        sctAssertLine91r : assert property ( tb |-> |rb );
    `endif // INTEL_SVA_OFF
    end
    else begin
        tb <= tb_next;
        rb <= rb_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine90 : assert property ( t |-> |r );
        sctAssertLine91 : assert property ( tb |-> |rb );
        sctAssertLine93 : assert property ( ta |-> |ra );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: assert_global (test_sig_access_reset.cpp:107:5) 

// Thread-local variables
logic [7:0] c;
logic [7:0] c_next;
logic a;
logic a_next;

// Next-state combinational logic
always_comb begin : assert_global_comb     // test_sig_access_reset.cpp:107:5
    assert_global_func;
end
function void assert_global_func;
    a_next = a;
    c_next = c;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : assert_global_ff
    if ( rst ) begin
        a <= '0;
        c <= 1;

    `ifndef INTEL_SVA_OFF
        sctAssertLine110r : assert property ( a_next |-> |c_next );
    `endif // INTEL_SVA_OFF
    end
    else begin
        c <= c_next;
        a <= a_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine110 : assert property ( a_next |-> |c_next );
        sctAssertLine112 : assert property ( |b |-> d == 1 );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: assert_local (test_sig_access_reset.cpp:120:5) 

// Thread-local variables
logic signed [7:0] h;
logic signed [7:0] h_next;
logic e;
logic e_next;
logic signed [31:0] f;
logic signed [31:0] f_next;
logic [7:0] g;
logic [7:0] g_next;

// Next-state combinational logic
always_comb begin : assert_local_comb     // test_sig_access_reset.cpp:120:5
    assert_local_func;
end
function void assert_local_func;
    e_next = e;
    f_next = f;
    g_next = g;
    h_next = h;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : assert_local_ff
    if ( rst ) begin
        g <= '0;
        h <= '0;

    `ifndef INTEL_SVA_OFF
        sctAssertLine128r : assert property ( e_next |-> h_next == 1 );
    `endif // INTEL_SVA_OFF
    end
    else begin
        h <= h_next;
        e <= e_next;
        f <= f_next;
        g <= g_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine128 : assert property ( e_next |-> h_next == 1 );
        sctAssertLine130 : assert property ( |f_next |-> |g_next );
    `endif // INTEL_SVA_OFF
    end
end

endmodule


