//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk,
    input logic signed [31:0] i1,
    output logic signed [31:0] o1,
    output logic signed [31:0] o2,
    input logic signed [31:0] iarr1[3],
    output logic signed [31:0] oarr1[3],
    input logic signed [31:0] iarr2[3][2],
    output logic signed [31:0] oarr2[3][2],
    input logic signed [31:0] ivec1[3],
    output logic signed [31:0] ovec2[3][2]
);

// Variables generated for SystemC signals
logic nrst;
logic [3:0] s;
logic [3:0] r;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;
logic signed [31:0] tp1;
logic signed [31:0] tp2;
logic signed [31:0] tarr0[3];
logic signed [31:0] tarr1[3];
logic signed [31:0] tarr3[3][2];
logic signed [31:0] tarr4[3][2];
logic signed [31:0] parr1[3];
logic signed [31:0] parr2[3][2];
logic signed [31:0] vec0[3];
logic [3:0] vec1[3];
logic [3:0] vec3[3];
logic signed [31:0] vvec0[3][2];
logic signed [31:0] vvec1[3][2];
logic signed [31:0] vec0t[3];
logic [3:0] vec1t[3];
logic [3:0] vec3t[3];
logic signed [31:0] vvec0t[3][2];
logic signed [31:0] vvec1t[3][2];
logic signed [31:0] tarr0t[3];
logic signed [31:0] tarr1t[3];
logic signed [31:0] tarr4t[3][2];

//------------------------------------------------------------------------------
// Method process: remove_port (test_unused_remove_signal.cpp:124:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Method process: remove_sig (test_unused_remove_signal.cpp:129:5) 

always_comb 
begin : remove_sig     // test_unused_remove_signal.cpp:129:5
    integer i;
    integer j;
    i = 1;
    j = t0;
    t1 = i + j;
    t2 = tp1;
    tp2 = 42;
end

//------------------------------------------------------------------------------
// Method process: remove_sig_arr (test_unused_remove_signal.cpp:138:5) 

always_comb 
begin : remove_sig_arr     // test_unused_remove_signal.cpp:138:5
    integer i;
    i = tarr0[r];
    tarr1[s] = i;
    tarr4[i][i] = 2;
    i = parr1[i];
    parr2[i][s] = tarr3[s][1];
end

//------------------------------------------------------------------------------
// Method process: remove_sig_vec (test_unused_remove_signal.cpp:168:5) 

always_comb 
begin : remove_sig_vec     // test_unused_remove_signal.cpp:168:5
    vec1[vec0[1]] = 2'd2;
    vec3[r] = vvec0[1][1];
    vvec1[1][vec0[1]] = 42;
end

//------------------------------------------------------------------------------
// Clocked THREAD: remove_sig_arr_thread (test_unused_remove_signal.cpp:154:5) 

// Thread-local variables
logic signed [31:0] tarr1t_next[3];
logic signed [31:0] tarr4t_next[3][2];

// Next-state combinational logic
always_comb begin : remove_sig_arr_thread_comb     // test_unused_remove_signal.cpp:154:5
    remove_sig_arr_thread_func;
end
function void remove_sig_arr_thread_func;
    integer i;
    tarr1t_next = tarr1t;
    tarr4t_next = tarr4t;
    i = tarr0t[r];
    tarr1t_next[s] = i;
    tarr4t_next[i][i] = 2;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : remove_sig_arr_thread_ff
    if ( ~nrst ) begin
    end
    else begin
        tarr1t <= tarr1t_next;
        tarr4t <= tarr4t_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: remove_sig_vec_thread (test_unused_remove_signal.cpp:177:5) 

// Thread-local variables
logic [3:0] vec1t_next[3];
logic [3:0] vec3t_next[3];
logic signed [31:0] vvec1t_next[3][2];

// Next-state combinational logic
always_comb begin : remove_sig_vec_thread_comb     // test_unused_remove_signal.cpp:177:5
    remove_sig_vec_thread_func;
end
function void remove_sig_vec_thread_func;
    vec1t_next = vec1t;
    vec3t_next = vec3t;
    vvec1t_next = vvec1t;
    vec1t_next[vec0t[1]] = 2'd2;
    vec3t_next[r] = vvec0t[1][1];
    vvec1t_next[1][vec0t[1]] = 42;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : remove_sig_vec_thread_ff
    if ( ~nrst ) begin
    end
    else begin
        vec1t <= vec1t_next;
        vec3t <= vec3t_next;
        vvec1t <= vvec1t_next;
    end
end

endmodule


