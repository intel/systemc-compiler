//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.26
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B ()
//
module B // "b_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic a_nrst[2];
logic [3:0] a_s[2];
logic signed [31:0] a_t0[2];
logic signed [31:0] a_t1[2];
logic a_clk[2];

// Assignments generated for C++ channel arrays
assign a_clk[0] = clk;
assign a_clk[1] = clk;

//------------------------------------------------------------------------------
// Method process: a_removeMeth (test_unused_remove_mif.cpp:33:5) 

// Process-local variables
logic signed [31:0] a_m2[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : a_removeMeth_sct_i 

    always_comb 
    begin : a_removeMeth     // test_unused_remove_mif.cpp:33:5
        logic [3:0] y;
        logic [3:0] yn;
        integer i;
        integer j;
        y = '0;
        y = a_s[sct_i];
        yn = y + 1'd1;
        a_t0[sct_i] = yn;
        i = 1;
        j = 32'(i + 2'sd1);
        a_t0[sct_i] = j;
        a_m2[sct_i] = 42;
        a_t0[sct_i] = 32'(a_m2[sct_i] + 2'sd1);
    end

end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: a_removeThrd (test_unused_remove_mif.cpp:55:5) 

// Thread-local variables
logic signed [31:0] a_t1_next[2];
logic signed [31:0] a_m3[2];
logic signed [31:0] a_m3_next[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : a_removeThrd_sct_i 

    // Next-state combinational logic
    always_comb begin : a_removeThrd_comb     // test_unused_remove_mif.cpp:55:5
        a_removeThrd_func;
    end
    function void a_removeThrd_func;
        a_m3_next[sct_i] = a_m3[sct_i];
        a_t1_next[sct_i] = a_t1[sct_i];
        a_m3_next[sct_i] = 32'(a_m3_next[sct_i] + 2'sd1);
        a_t1_next[sct_i] = a_m3_next[sct_i];
    endfunction

    // Synchronous register update
    always_ff @(posedge a_clk[sct_i] or negedge a_nrst[sct_i]) 
    begin : a_removeThrd_ff
        if ( ~a_nrst[sct_i] ) begin
            a_t1[sct_i] <= '0;
            a_m3[sct_i] <= '0;
        end
        else begin
            a_t1[sct_i] <= a_t1_next[sct_i];
            a_m3[sct_i] <= a_m3_next[sct_i];
        end
    end

end
endgenerate

endmodule


