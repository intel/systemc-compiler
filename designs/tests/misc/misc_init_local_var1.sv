//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.26
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic signed [31:0] s;
logic signed [31:0] t0;
logic signed [31:0] t1;

//------------------------------------------------------------------------------
// Method process: var1 (test_init_local_var1.cpp:38:5) 

always_comb 
begin : var1     // test_init_local_var1.cpp:38:5
    logic a;
    integer i;
    logic [3:0] x;
    logic aa;
    integer ii;
    integer sum;
    logic b;
    integer j;
    a = '0;
    i = '0;
    b = '0;
    j = '0;
    x = '0;
    aa = 1;
    ii = 42;
    sum = 32'(32'(32'(a + i) + aa) + ii) + x;
    if (|s)
    begin
        sum = 32'(b + j);
    end
    t0 = sum;
end

//------------------------------------------------------------------------------
// Method process: var1_unused (test_init_local_var1.cpp:56:5) 

always_comb 
begin : var1_unused     // test_init_local_var1.cpp:56:5
    logic a;
    integer i;
    logic [3:0] x;
    logic aa;
    integer ii;
    logic b;
    integer j;
    a = '0;
    i = '0;
    b = '0;
    j = '0;
    x = '0;
    aa = 1;
    ii = 42;
    if (|s)
    begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: var2 (test_init_local_var1.cpp:73:5) 

// Thread-local variables
logic b0;
logic b_next;
logic d;
logic d_next;
logic signed [31:0] sum0;
logic signed [31:0] sum_next;
logic signed [63:0] n;
logic signed [63:0] n_next;
logic signed [31:0] t1_next;
logic var2_PROC_STATE;
logic var2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : var2_comb     // test_init_local_var1.cpp:73:5
    var2_func;
end
function void var2_func;
    logic bb;
    integer j;
    integer jj;
    integer jjj;
    logic [3:0] y;
    logic c;
    integer unsigned k;
    logic d_1;
    logic signed [63:0] n_1;
    c = '0;
    k = '0;
    d_1 = '0;
    n_1 = '0;
    b_next = b0;
    d_next = d;
    n_next = n;
    sum_next = sum0;
    t1_next = t1;
    var2_PROC_STATE_next = var2_PROC_STATE;
    
    case (var2_PROC_STATE)
        0: begin
            if (|s)
            begin
                sum_next = 64'(d_1 + n_1);
            end
            sum_next = 32'(b_next + c + k);
            t1_next = sum_next;
            var2_PROC_STATE_next = 1; return;    // test_init_local_var1.cpp:100:13;
        end
        1: begin
            sum_next = 64'(32'(sum_next + d_next) + n_next);
            if (|s)
            begin
                sum_next = 64'(d_1 + n_1);
            end
            sum_next = 32'(b_next + c + k);
            t1_next = sum_next;
            var2_PROC_STATE_next = 1; return;    // test_init_local_var1.cpp:100:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : var2_ff
    if ( ~rstn ) begin
        logic bb;
        integer j;
        integer jj;
        integer jjj;
        logic [3:0] y;
        bb = 1;
        jjj = 42;
        y = 32'(32'(jjj + jj) + 2'sd1);
        sum0 <= '0;
        var2_PROC_STATE <= '0;    // test_init_local_var1.cpp:81:9;
    end
    else begin
        b0 <= b_next;
        d <= d_next;
        sum0 <= sum_next;
        n <= n_next;
        t1 <= t1_next;
        var2_PROC_STATE <= var2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: var2_unused (test_init_local_var1.cpp:106:5) 

// Next-state combinational logic
always_comb begin : var2_unused_comb     // test_init_local_var1.cpp:106:5
    var2_unused_func;
end
function void var2_unused_func;
    logic b;
    integer j;
    logic c;
    integer unsigned k;
    logic d_1;
    logic signed [63:0] n_1;
    c = '0;
    k = '0;
    d_1 = '0;
    n_1 = '0;
    if (|s)
    begin
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : var2_unused_ff
    if ( ~rstn ) begin
        logic b;
        integer j;
    end
    else begin
    end
end

endmodule


