//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "tb_inst.top_inst"
(
    input logic clk,
    input logic rst
);

// Variables generated for SystemC signals
logic minst_s[2];
logic signed [31:0] minst_t0[2];
logic signed [31:0] minst_t1[2];
logic signed [31:0] minst_t2[2];
logic signed [31:0] minst_t3[2];
logic signed [31:0] minst_t4[2];
logic signed [31:0] minst_t5[2];
logic minst_clk[2];
logic minst_rst[2];

// Assignments generated for C++ channel arrays
assign minst_clk[0] = clk;
assign minst_clk[1] = clk;
assign minst_rst[0] = rst;
assign minst_rst[1] = rst;

//------------------------------------------------------------------------------
// Method process: minst_metProc (test_mif_array2.cpp:55:5) 

// Process-local variables
logic [2:0] minst_v[2];
logic [3:0] minst_vv[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_metProc_sct_i 

    always_comb 
    begin : minst_metProc     // test_mif_array2.cpp:55:5
        logic d;
        minst_v[sct_i] = 1;
        minst_vv[sct_i] = 2;
        d = |minst_vv[sct_i];
        minst_v[sct_i] = minst_s[sct_i] ? 0 : 1;
        d = !minst_s[sct_i] && |minst_v[sct_i];
        minst_t0[sct_i] = d;
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: minst_locRecMeth (test_mif_array2.cpp:70:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_locRecMeth_sct_i 

    always_comb 
    begin : minst_locRecMeth     // test_mif_array2.cpp:70:5
        logic t_a;
        logic [3:0] t_b;
        logic tt_a;
        logic [3:0] tt_b;
        logic [3:0] x;
        t_b = '0;
        tt_b = '0;
        t_a = '0;
        t_b = 4;
        tt_a = 1;
        tt_b = 5;
        x = t_b + tt_b;
        minst_t1[sct_i] = x;
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: minst_locRecArrMeth (test_mif_array2.cpp:86:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_locRecArrMeth_sct_i 

    always_comb 
    begin : minst_locRecArrMeth     // test_mif_array2.cpp:86:5
        logic t_a[2];
        logic [3:0] t_b[2];
        logic tt_a[3];
        logic [3:0] tt_b[3];
        logic [3:0] x;
        t_a[1] = '0;
        t_b[1] = 4;
        for (int i = 0; i < 3; ++i)
        begin
            tt_a[i] = i == 0;
            tt_b[i] = i;
            if (i < 2)
            begin
                t_b[i] = tt_b[i] + 1'd1;
            end
        end
        x = t_b[1] + tt_b[2];
        minst_t2[sct_i] = x;
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: minst_memRecMeth (test_mif_array2.cpp:107:5) 

// Process-local variables
logic minst_r_a[2];
logic [3:0] minst_r_b[2];
logic minst_rr_a[2];
logic [3:0] minst_rr_b[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_memRecMeth_sct_i 

    always_comb 
    begin : minst_memRecMeth     // test_mif_array2.cpp:107:5
        logic [3:0] x;
        minst_r_a[sct_i] = '0;
        minst_r_b[sct_i] = 4;
        minst_rr_a[sct_i] = 1;
        minst_rr_b[sct_i] = 5;
        x = minst_r_b[sct_i] + minst_rr_b[sct_i];
        minst_t3[sct_i] = x;
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: minst_memRecArrMeth (test_mif_array2.cpp:121:5) 

// Process-local variables
logic minst_p_a[2][2];
logic [3:0] minst_p_b[2][2];
logic minst_pp_a[2][3];
logic [3:0] minst_pp_b[2][3];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_memRecArrMeth_sct_i 

    always_comb 
    begin : minst_memRecArrMeth     // test_mif_array2.cpp:121:5
        logic [3:0] x;
        minst_p_a[sct_i][1] = '0;
        minst_p_b[sct_i][1] = 4;
        minst_pp_a[sct_i][2] = '0;
        minst_pp_b[sct_i][2] = 4;
        x = minst_p_b[sct_i][1] + minst_pp_b[sct_i][2];
        minst_t4[sct_i] = x;
    end

end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: minst_thrProc (test_mif_array2.cpp:133:5) 

// Thread-local variables
logic minst_s_next[2];
logic [2:0] i0[2];
logic [2:0] i_next[2];
logic [4:0] minst_vvv[2];
logic [4:0] minst_vvv_next[2];
logic signed [31:0] minst_t5_next[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_thrProc_sct_i 

    // Next-state combinational logic
    always_comb begin : minst_thrProc_comb     // test_mif_array2.cpp:133:5
        minst_thrProc_func;
    end
    function void minst_thrProc_func;
        logic [2:0] j;
        i_next[sct_i] = i0[sct_i];
        minst_s_next[sct_i] = minst_s[sct_i];
        minst_t5_next[sct_i] = minst_t5[sct_i];
        minst_vvv_next[sct_i] = minst_vvv[sct_i];
        minst_s_next[sct_i] = |(i_next[sct_i]++);
        j = minst_vvv_next[sct_i]++;
        minst_t5_next[sct_i] = j;
    endfunction

    // Synchronous register update
    always_ff @(posedge minst_clk[sct_i] or posedge minst_rst[sct_i]) 
    begin : minst_thrProc_ff
        if ( minst_rst[sct_i] ) begin
            logic [2:0] j;
            i0[sct_i] <= '0;
            j = 1'd1;
            minst_s[sct_i] <= '0;
            minst_vvv[sct_i] <= '0;
        end
        else begin
            minst_s[sct_i] <= minst_s_next[sct_i];
            i0[sct_i] <= i_next[sct_i];
            minst_vvv[sct_i] <= minst_vvv_next[sct_i];
            minst_t5[sct_i] <= minst_t5_next[sct_i];
        end
    end

end
endgenerate

endmodule


