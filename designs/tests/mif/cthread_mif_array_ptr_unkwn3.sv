//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.14
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic signed [31:0] sig;
logic [3:0] minst_s[2][1];
logic [3:0] minst_as[2][1][3];
logic [3:0] minst_asp[2][1][3];
logic minst_clk[2][1];
logic minst_rst[2][1];

// Local parameters generated for C++ constants
localparam logic [3:0] minst_w[2][1] = '{ '{ 0 }, '{ 0 } };

// Assignments generated for C++ channel arrays
assign minst_clk[0][0] = clk;
assign minst_clk[1][0] = clk;
assign minst_rst[0][0] = rst;
assign minst_rst[1][0] = rst;

//------------------------------------------------------------------------------
// Clocked THREAD: minst_thread_member_sig (test_cthread_mif_array_ptr_unkwn3.cpp:44:5) 

// Thread-local variables
logic signed [31:0] j[2][1];
logic signed [31:0] j_next[2][1];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_thread_member_sig_sct_i 
for (genvar sct_j = 0; sct_j != 1; sct_j = sct_j + 1) 
begin : minst_thread_member_sig_sct_j 

    // Next-state combinational logic
    always_comb begin : minst_thread_member_sig_comb     // test_cthread_mif_array_ptr_unkwn3.cpp:44:5
        minst_thread_member_sig_func;
    end
    function void minst_thread_member_sig_func;
        integer k;
        j_next[sct_i][sct_j] = j[sct_i][sct_j];
        k = minst_as[sct_i][sct_j][j_next[sct_i][sct_j] + 1];
    endfunction

    // Synchronous register update
    always_ff @(posedge minst_clk[sct_i][sct_j] or posedge minst_rst[sct_i][sct_j]) 
    begin : minst_thread_member_sig_ff
        if ( minst_rst[sct_i][sct_j] ) begin
            integer k;
            j[sct_i][sct_j] <= minst_s[sct_i][sct_j];
            k = minst_as[sct_i][sct_j][j[sct_i][sct_j]];
        end
        else begin
            j[sct_i][sct_j] <= j_next[sct_i][sct_j];
        end
    end

end
end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: minst_thread_member_comb (test_cthread_mif_array_ptr_unkwn3.cpp:61:5) 

// Thread-local variables
logic [3:0] minst_v[2][1];
logic signed [31:0] minst_av[2][1][2];
logic signed [31:0] minst_avv[2][1][2][3];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_thread_member_comb_sct_i 
for (genvar sct_j = 0; sct_j != 1; sct_j = sct_j + 1) 
begin : minst_thread_member_comb_sct_j 

    // Next-state combinational logic
    always_comb begin : minst_thread_member_comb_comb     // test_cthread_mif_array_ptr_unkwn3.cpp:61:5
        minst_thread_member_comb_func;
    end
    function void minst_thread_member_comb_func;
        integer j_1;
        integer k;
        minst_v[sct_i][sct_j] = 1;
        minst_av[sct_i][sct_j][0] = minst_v[sct_i][sct_j];
        minst_avv[sct_i][sct_j][1][2] = minst_v[sct_i][sct_j];
        k = minst_av[sct_i][sct_j][0] + minst_avv[sct_i][sct_j][1][2];
    endfunction

    // Synchronous register update
    always_ff @(posedge minst_clk[sct_i][sct_j] or posedge minst_rst[sct_i][sct_j]) 
    begin : minst_thread_member_comb_ff
        if ( minst_rst[sct_i][sct_j] ) begin
            integer j_1;
            logic [3:0] minst_v;
            integer minst_av[2];
            integer minst_avv[2][3];
            j_1 = minst_s[sct_i][sct_j];
            minst_v = minst_as[sct_i][sct_j][1];
            minst_av[0] = minst_v + minst_asp[sct_i][sct_j][j_1];
            minst_avv[1][j_1] = minst_av[0];
        end
        else begin
        end
    end

end
end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: minst_thread_member_reg (test_cthread_mif_array_ptr_unkwn3.cpp:81:5) 

// Thread-local variables
logic [3:0] minst_as_next[2][1][3];
logic [3:0] minst_asp_next[2][1][3];
logic signed [31:0] j0[2][1];
logic signed [31:0] j_next0[2][1];
logic signed [31:0] minst_aw[2][1][2];
logic signed [31:0] minst_aw_next[2][1][2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_thread_member_reg_sct_i 
for (genvar sct_j = 0; sct_j != 1; sct_j = sct_j + 1) 
begin : minst_thread_member_reg_sct_j 

    // Next-state combinational logic
    always_comb begin : minst_thread_member_reg_comb     // test_cthread_mif_array_ptr_unkwn3.cpp:81:5
        minst_thread_member_reg_func;
    end
    function void minst_thread_member_reg_func;
        integer l;
        j_next0[sct_i][sct_j] = j0[sct_i][sct_j];
        minst_as_next[sct_i][sct_j] = minst_as[sct_i][sct_j];
        minst_asp_next[sct_i][sct_j] = minst_asp[sct_i][sct_j];
        minst_aw_next[sct_i][sct_j] = minst_aw[sct_i][sct_j];
        l = minst_w[sct_i][sct_j] + minst_aw_next[sct_i][sct_j][j_next0[sct_i][sct_j]] + minst_as[sct_i][sct_j][j_next0[sct_i][sct_j] + 1] + minst_asp[sct_i][sct_j][j_next0[sct_i][sct_j] + 2];
    endfunction

    // Synchronous register update
    always_ff @(posedge minst_clk[sct_i][sct_j] or posedge minst_rst[sct_i][sct_j]) 
    begin : minst_thread_member_reg_ff
        if ( minst_rst[sct_i][sct_j] ) begin
            j0[sct_i][sct_j] <= minst_s[sct_i][sct_j];
            minst_as[sct_i][sct_j][0] <= j0[sct_i][sct_j];
            minst_asp[sct_i][sct_j][j0[sct_i][sct_j]] <= 0;
        end
        else begin
            minst_as[sct_i][sct_j] <= minst_as_next[sct_i][sct_j];
            minst_asp[sct_i][sct_j] <= minst_asp_next[sct_i][sct_j];
            j0[sct_i][sct_j] <= j_next0[sct_i][sct_j];
            minst_aw[sct_i][sct_j] <= minst_aw_next[sct_i][sct_j];
        end
    end

end
end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread_comb (test_cthread_mif_array_ptr_unkwn3.cpp:119:5) 

// Thread-local variables
logic signed [31:0] j1;
logic signed [31:0] j_next1;
logic [3:0] minst_y[2][1];
logic signed [31:0] minst_ay[2][1][3];

// Next-state combinational logic
always_comb begin : top_thread_comb_comb     // test_cthread_mif_array_ptr_unkwn3.cpp:119:5
    top_thread_comb_func;
end
function void top_thread_comb_func;
    integer i_1;
    j_next1 = j1;
    minst_y[1][0] = minst_asp[j_next1][0][0];
    i_1 = minst_y[1][0];
    minst_ay[0][0][1] = minst_as[j_next1][j_next1 + 1][j_next1];
    i_1 = minst_ay[0][0][1];
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_comb_ff
    if ( rst ) begin
        logic [3:0] minst_y[2][1];
        integer minst_ay[2][1][3];
        for (integer i = 0; i < 2; i++)
        begin
            minst_y[i][0] = i;
            for (integer k = 0; k < 2; k++)
            begin
                minst_ay[i][0][k] = i + k;
            end
        end
        j1 <= sig;
    end
    else begin
        j1 <= j_next1;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread_reg (test_cthread_mif_array_ptr_unkwn3.cpp:142:5) 

// Thread-local variables
logic signed [31:0] j2;
logic signed [31:0] j_next2;
logic [3:0] minst_z[2][1];
logic [3:0] minst_z_next[2][1];
logic signed [31:0] minst_az[2][1][2];
logic signed [31:0] minst_az_next[2][1][2];

// Next-state combinational logic
always_comb begin : top_thread_reg_comb     // test_cthread_mif_array_ptr_unkwn3.cpp:142:5
    top_thread_reg_func;
end
function void top_thread_reg_func;
    integer i;
    j_next2 = j2;
    minst_az_next = minst_az;
    minst_z_next = minst_z;
    minst_z_next[j_next2][j_next2 + 1] = 2;
    i = minst_z_next[j_next2][j_next2 + 1];
    minst_az_next[0][0][j_next2 + 1] = 3;
    i = minst_az_next[0][0][1];
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_reg_ff
    if ( rst ) begin
        j2 <= minst_s[0][0];
    end
    else begin
        j2 <= j_next2;
        minst_z <= minst_z_next;
        minst_az <= minst_az_next;
    end
end

endmodule


