//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.17
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic pp_req[2][3];
logic [15:0] pp_s[2][3];
logic [3:0] pp_sv[2][3][2];
logic [4:0] pp_sa[2][3][2];
logic [15:0] t;
logic pp_clk[2][3];
logic pp_rstn[2][3];
logic cc_req[2][3];
logic [31:0] cc_resp[2][3];

// Assignments generated for C++ channel arrays
assign pp_clk[0][0] = clk;
assign pp_clk[0][1] = clk;
assign pp_clk[0][2] = clk;
assign pp_clk[1][0] = clk;
assign pp_clk[1][1] = clk;
assign pp_clk[1][2] = clk;
assign pp_rstn[0][0] = rstn;
assign pp_rstn[0][1] = rstn;
assign pp_rstn[0][2] = rstn;
assign pp_rstn[1][0] = rstn;
assign pp_rstn[1][1] = rstn;
assign pp_rstn[1][2] = rstn;
assign cc_req = pp_req;

//------------------------------------------------------------------------------
// Clocked THREAD: pp_threadProc (test_sc_vector_mif_2d.cpp:33:5) 

// Thread-local variables
logic pp_req_next[2][3];
logic [31:0] pp_a[2][3][2];
logic [31:0] pp_a_next[2][3][2];
logic [3:0] pp_sv_next[2][3][2];
logic signed [31:0] pp_m[2][3];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : pp_threadProc_sct_i 
for (genvar sct_j = 0; sct_j != 3; sct_j = sct_j + 1) 
begin : pp_threadProc_sct_j 

    // Next-state combinational logic
    always_comb begin : pp_threadProc_comb     // test_sc_vector_mif_2d.cpp:33:5
        pp_threadProc_func;
    end
    function void pp_threadProc_func;
        pp_a_next[sct_i][sct_j] = pp_a[sct_i][sct_j];
        pp_req_next[sct_i][sct_j] = pp_req[sct_i][sct_j];
        pp_sv_next[sct_i][sct_j] = pp_sv[sct_i][sct_j];
        pp_req_next[sct_i][sct_j] = 0;
        if (|(pp_s[sct_i][sct_j] % 3))
        begin
            pp_req_next[sct_i][sct_j] = 1;
        end
        pp_m[sct_i][sct_j] = pp_s[sct_i][sct_j];
        pp_sv_next[sct_i][sct_j][pp_s[sct_i][sct_j]] = pp_sa[sct_i][sct_j][pp_a_next[sct_i][sct_j][pp_m[sct_i][sct_j]]];
    endfunction

    // Synchronous register update
    always_ff @(posedge pp_clk[sct_i][sct_j] or negedge pp_rstn[sct_i][sct_j]) 
    begin : pp_threadProc_ff
        if ( ~pp_rstn[sct_i][sct_j] ) begin
            pp_req[sct_i][sct_j] <= 0;
        end
        else begin
            pp_req[sct_i][sct_j] <= pp_req_next[sct_i][sct_j];
            pp_a[sct_i][sct_j] <= pp_a_next[sct_i][sct_j];
            pp_sv[sct_i][sct_j] <= pp_sv_next[sct_i][sct_j];
        end
    end

end
end
endgenerate

//------------------------------------------------------------------------------
// Method process: cc_methProc (test_sc_vector_mif_2d.cpp:64:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : cc_methProc_sct_i 
for (genvar sct_j = 0; sct_j != 3; sct_j = sct_j + 1) 
begin : cc_methProc_sct_j 

    always_comb 
    begin : cc_methProc     // test_sc_vector_mif_2d.cpp:64:5
        cc_resp[sct_i][sct_j] = 1;
        if (cc_req[sct_i][sct_j])
        begin
            cc_resp[sct_i][sct_j] = 2;
        end
    end

end
end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: mainProc (test_sc_vector_mif_2d.cpp:102:5) 

// Thread-local variables
logic [15:0] pp_s_next[2][3];
logic [4:0] pp_sa_next[2][3][2];
logic [15:0] t_next;

// Next-state combinational logic
always_comb begin : mainProc_comb     // test_sc_vector_mif_2d.cpp:102:5
    mainProc_func;
end
function void mainProc_func;
    integer unsigned u;
    logic [15:0] TMP_0;
    pp_s_next = pp_s;
    pp_sa_next = pp_sa;
    t_next = t;
    u = t;
    pp_s_next[0][0] = pp_sa[0][0][0];
    pp_s_next[u][u] = pp_sa[u][u][u + 1];
    pp_sa_next[u][u][1] = pp_sv[u][u][u];
    // Call getData() begin
    TMP_0 = pp_s[u][u + 1];
    // Call getData() end
    t_next = TMP_0;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : mainProc_ff
    if ( ~rstn ) begin
    end
    else begin
        pp_s <= pp_s_next;
        pp_sa <= pp_sa_next;
        t <= t_next;
    end
end

endmodule


