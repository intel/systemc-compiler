//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic signed [31:0] x;
logic signed [31:0] y;
logic signed [31:0] t;
logic signed [31:0] z;
logic signed [31:0] minst_sig[2];
logic minst_clk[2];
logic minst_rst[2];
logic signed [31:0] minst_min[2];
logic signed [31:0] minst_mout[2];
logic signed [31:0] minst_in[2];
logic signed [31:0] minst_out[2];

// Local parameters generated for C++ constants
localparam logic [31:0] minst_A[2] = '{ 1, 1 };
localparam logic [31:0] minst_m[2] = '{ 0, 0 };
localparam logic [31:0] minst_n[2] = '{ 0, 0 };
localparam logic [31:0] minst_B = 2;

// Assignments generated for C++ channel arrays
assign minst_clk[0] = clk;
assign minst_clk[1] = clk;
assign minst_rst[0] = rst;
assign minst_rst[1] = rst;
assign minst_min[0] = x;
assign minst_min[1] = y;
assign y = minst_mout[1];
assign minst_in[0] = t;
assign minst_in[1] = z;
assign t = minst_out[0];

//------------------------------------------------------------------------------
// Method process: minst_meth (test_mif_array_with_ports.cpp:41:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_meth_sct_i 

    always_comb 
    begin : minst_meth     // test_mif_array_with_ports.cpp:41:5
        integer i;
        i = minst_m[sct_i] + minst_A[sct_i] + minst_B;
        minst_mout[sct_i] = minst_min[sct_i] + i;
    end

end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: minst_thrd (test_mif_array_with_ports.cpp:47:5) 

// Thread-local variables
logic signed [31:0] minst_out_next[2];
logic signed [31:0] a[2];
logic signed [31:0] a_next[2];
logic signed [31:0] minst_sig_next[2];
logic thrd_PROC_STATE[2];
logic thrd_PROC_STATE_next[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_thrd_sct_i 

    // Next-state combinational logic
    always_comb begin : minst_thrd_comb     // test_mif_array_with_ports.cpp:47:5
        minst_thrd_func;
    end
    function void minst_thrd_func;
        integer i;
        a_next[sct_i] = a[sct_i];
        minst_out_next[sct_i] = minst_out[sct_i];
        minst_sig_next[sct_i] = minst_sig[sct_i];
        thrd_PROC_STATE_next[sct_i] = thrd_PROC_STATE[sct_i];
    
        case (thrd_PROC_STATE[sct_i])
            0: begin
                i = minst_n[sct_i] + minst_A[sct_i] + minst_B;
                a_next[sct_i] = minst_in[sct_i] + i;
                thrd_PROC_STATE_next[sct_i] = 1; return;    // test_mif_array_with_ports.cpp:54:13;
            end
            1: begin
                minst_sig_next[sct_i] = a_next[sct_i];
                i = minst_n[sct_i] + minst_A[sct_i] + minst_B;
                a_next[sct_i] = minst_in[sct_i] + i;
                thrd_PROC_STATE_next[sct_i] = 1; return;    // test_mif_array_with_ports.cpp:54:13;
            end
        endcase
    endfunction

    // Synchronous register update
    always_ff @(posedge minst_clk[sct_i] or posedge minst_rst[sct_i]) 
    begin : minst_thrd_ff
        if ( minst_rst[sct_i] ) begin
            minst_out[sct_i] <= '0;
            thrd_PROC_STATE[sct_i] <= '0;    // test_mif_array_with_ports.cpp:49:9;
        end
        else begin
            minst_out[sct_i] <= minst_out_next[sct_i];
            a[sct_i] <= a_next[sct_i];
            minst_sig[sct_i] <= minst_sig_next[sct_i];
            thrd_PROC_STATE[sct_i] <= thrd_PROC_STATE_next[sct_i];
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: top_meth (test_mif_array_with_ports.cpp:95:5) 

always_comb 
begin : top_meth     // test_mif_array_with_ports.cpp:95:5
    integer i;
    i = t + y;
end

endmodule


