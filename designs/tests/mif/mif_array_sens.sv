//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic [31:0] t;
logic [31:0] minst_s1[3];
logic [31:0] minst_s1a[3];
logic [31:0] minst_s2[3];
logic [31:0] minst_s3[3];
logic [31:0] minst_r[3];
logic signed [31:0] minst_t0[3];
logic signed [31:0] minst_t[3];
logic signed [31:0] t0;

// Local parameters generated for C++ constants
localparam logic signed [31:0] L[3] = '{ 1, 2, 3 };
localparam logic BA[3] = '{ 1, 1, 0 };
localparam logic signed [3:0] mmd[3] = '{ 5, -4'sd5, 0 };
localparam logic [31:0] minst_B[3] = '{ 10, 11, 12 };
localparam logic [31:0] minst_BR[3][2] = '{ '{ 32, 33 }, '{ 32, 33 }, '{ 32, 33 } };
localparam logic [31:0] minst_C[3] = '{ 10, 11, 12 };
localparam logic [31:0] minst_A = 12;
localparam logic [31:0] minst_AR[2] = '{ 22, 23 };
localparam logic [31:0] SA[3] = '{ 22, 23, 24 };
localparam logic SB[3] = '{ 1, 1, 0 };
localparam logic COUPLED_BLOCK_DOMAIN[1] = '{ 1 };

//------------------------------------------------------------------------------
// Method process: minst_mifMeth (test_mif_array_sens.cpp:47:5) 

// Process-local variables
logic [31:0] minst_br[3][2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 3; sct_i = sct_i + 1) 
begin : minst_mifMeth_sct_i 

    always_comb 
    begin : minst_mifMeth     // test_mif_array_sens.cpp:47:5
        integer unsigned l;
        minst_s1[sct_i] = '0;
        l = minst_A;
        l = minst_B[sct_i];
        l = minst_C[sct_i];
        l = minst_AR[1] + minst_BR[sct_i][1];
        l = minst_AR[minst_r[sct_i]] + minst_BR[sct_i][minst_r[sct_i]];
        l = minst_B[sct_i];
        l = minst_BR[sct_i][0] + minst_br[sct_i][0];
        minst_t0[sct_i] = l;
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: top_method1 (test_mif_array_sens.cpp:122:5) 

always_comb 
begin : top_method1     // test_mif_array_sens.cpp:122:5
    integer unsigned i;
    i = t;
    // Call f1() begin
    minst_s1a[i] = 1'd1;
    // Call f1() end
end

//------------------------------------------------------------------------------
// Method process: top_method2 (test_mif_array_sens.cpp:127:5) 

// Process-local variables
logic [31:0] minst_par[3];

always_comb 
begin : top_method2     // test_mif_array_sens.cpp:127:5
    integer unsigned i;
    i = t;
    // Call f2() begin
    minst_s2[2] = 1'd1;
    minst_par[2] = minst_r[2];
    minst_t[2] = minst_par[2];
    // Call f2() end
    // Call f2() begin
    if (|minst_B[i])
    begin
        minst_s2[i] = 1'd1;
    end else begin
        minst_s2[i] = minst_r[i];
    end
    minst_par[i] = minst_r[i];
    minst_t[i] = minst_par[i];
    // Call f2() end
end

//------------------------------------------------------------------------------
// Method process: top_method3 (test_mif_array_sens.cpp:141:5) 

always_comb 
begin : top_method3     // test_mif_array_sens.cpp:141:5
    integer unsigned i;
    i = t;
    // Call f3() begin
    if (minst_C[i] == 4'd12)
    begin
        minst_s3[i] = 1'd1;
    end else begin
        minst_s3[i] = minst_r[i];
    end
    // Call f3() end
end

//------------------------------------------------------------------------------
// Method process: top_method4 (test_mif_array_sens.cpp:158:5) 

always_comb 
begin : top_method4     // test_mif_array_sens.cpp:158:5
    integer unsigned i;
    integer unsigned lu;
    logic signed [7:0] bi;
    i = t;
    bi = '0;
    lu = minst_BR[i][0];
    lu = L[1] + BA[2];
    lu = SA[1] + SB[2] + COUPLED_BLOCK_DOMAIN[0];
    t0 = lu;
    bi = mmd[0] + mmd[1] + 2'sd1;
    t0 = 32'(bi);
end

endmodule


