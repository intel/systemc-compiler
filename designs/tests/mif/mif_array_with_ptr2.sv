//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic signed [31:0] t;
logic signed [31:0] z;
logic signed [31:0] minst_p[2];
logic signed [31:0] minst_q[2];
logic minst_clk[2];
logic minst_rst[2];
logic signed [31:0] minst_in[2];
logic signed [31:0] minst_out[2];

// Assignments generated for C++ channel arrays
assign minst_clk[0] = clk;
assign minst_clk[1] = clk;
assign minst_rst[0] = rst;
assign minst_rst[1] = rst;
assign minst_in[0] = t;
assign minst_in[1] = z;

//------------------------------------------------------------------------------
// Method process: minst_ptrProc (test_mif_array_with_ptr2.cpp:41:5) 

// Process-local variables
logic [3:0] minst_vp[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_ptrProc_sct_i 

    always_comb 
    begin : minst_ptrProc     // test_mif_array_with_ptr2.cpp:41:5
        minst_out[sct_i] = minst_in[sct_i];
        minst_out[sct_i] = minst_p[sct_i];
        minst_vp[sct_i] = 3;
    end

end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: minst_thrProc (test_mif_array_with_ptr2.cpp:47:5) 

// Thread-local variables
logic signed [31:0] minst_p_next[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_thrProc_sct_i 

    // Next-state combinational logic
    always_comb begin : minst_thrProc_comb     // test_mif_array_with_ptr2.cpp:47:5
        minst_thrProc_func;
    end
    function void minst_thrProc_func;
        minst_p_next[sct_i] = minst_p[sct_i];
        minst_p_next[sct_i] = minst_in[sct_i];
    endfunction

    // Synchronous register update
    always_ff @(posedge minst_clk[sct_i] or posedge minst_rst[sct_i]) 
    begin : minst_thrProc_ff
        if ( minst_rst[sct_i] ) begin
            minst_p[sct_i] <= 2;
        end
        else begin
            minst_p[sct_i] <= minst_p_next[sct_i];
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: top_method (test_mif_array_with_ptr2.cpp:94:5) 

always_comb 
begin : top_method     // test_mif_array_with_ptr2.cpp:94:5
    integer j;
    integer TMP_0;
    j = '0;
    for (int i = 0; i < 2; i++)
    begin
        // Call getP() begin
        TMP_0 = minst_p[i];
        // Call getP() end
        j = j + TMP_0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread (test_mif_array_with_ptr2.cpp:102:5) 

// Thread-local variables
logic signed [31:0] minst_q_next[2];

// Next-state combinational logic
always_comb begin : top_thread_comb     // test_mif_array_with_ptr2.cpp:102:5
    top_thread_func;
end
function void top_thread_func;
    integer j;
    integer TMP_0;
    integer val;
    minst_q_next = minst_q;
    for (int i_1 = 0; i_1 < 2; i_1++)
    begin
        val = i_1;
        // Call setQ() begin
        minst_q_next[i_1] = val;
        // Call setQ() end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_ff
    if ( rst ) begin
        integer j;
        integer TMP_0;
        j = '0;
        for (int i = 0; i < 2; i++)
        begin
            // Call getP() begin
            TMP_0 = minst_p[i];
            // Call getP() end
            j = j + TMP_0;
        end
    end
    else begin
        minst_q <= minst_q_next;
    end
end

endmodule


