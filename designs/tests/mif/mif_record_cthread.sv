//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.7.00
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic minst_nrst;
logic minst_s;
logic signed [31:0] minst_t0;
logic signed [31:0] minst_t1;
logic signed [31:0] minst_t2;
logic signed [31:0] minst_t3;
logic signed [31:0] minst_t4;
logic ninst_nrst;
logic ninst_s;
logic signed [31:0] ninst_t0;
logic signed [31:0] ninst_t1;
logic signed [31:0] ninst_t2;
logic signed [31:0] ninst_t3;
logic signed [31:0] ninst_t4;
logic minst_clk;
logic ninst_clk;

// Assignments generated for C++ channel arrays
assign minst_clk = clk;
assign ninst_clk = clk;

//------------------------------------------------------------------------------
// Clocked THREAD: minst_localRecThread (test_record_cthread.cpp:44:5) 

// Thread-local variables
logic [3:0] t_b;
logic [3:0] t_b_next;
logic signed [31:0] minst_t0_next;
logic localRecThread_PROC_STATE;
logic localRecThread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : minst_localRecThread_comb     // test_record_cthread.cpp:44:5
    minst_localRecThread_func;
end
function void minst_localRecThread_func;
    logic t_a;
    logic tt_a;
    logic [3:0] tt_b;
    integer i;
    minst_t0_next = minst_t0;
    t_b_next = t_b;
    localRecThread_PROC_STATE_next = localRecThread_PROC_STATE;
    
    case (localRecThread_PROC_STATE)
        0: begin
            tt_a = minst_s;
            tt_b = tt_a ? t_b_next : 4'd0;
            i = t_b_next + tt_b;
            minst_t0_next = i;
            localRecThread_PROC_STATE_next = 1; return;    // test_record_cthread.cpp:56:13;
        end
        1: begin
            t_b_next = t_b_next + 1'd1;
            tt_a = minst_s;
            tt_b = tt_a ? t_b_next : 4'd0;
            i = t_b_next + tt_b;
            minst_t0_next = i;
            localRecThread_PROC_STATE_next = 1; return;    // test_record_cthread.cpp:56:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge minst_clk or negedge minst_nrst) 
begin : minst_localRecThread_ff
    if ( ~minst_nrst ) begin
        logic t_a;
        logic tt_a;
        logic [3:0] tt_b;
        t_b <= '0;
        tt_b = '0;
        t_a = '0;
        t_b <= 1;
        localRecThread_PROC_STATE <= '0;    // test_record_cthread.cpp:49:9;
    end
    else begin
        t_b <= t_b_next;
        minst_t0 <= minst_t0_next;
        localRecThread_PROC_STATE <= localRecThread_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: minst_localRecArrThread (test_record_cthread.cpp:64:5) 

// Thread-local variables
logic [3:0] v_b[2];
logic [3:0] v_b_next[2];
logic signed [31:0] minst_t1_next;

// Next-state combinational logic
always_comb begin : minst_localRecArrThread_comb     // test_record_cthread.cpp:64:5
    minst_localRecArrThread_func;
end
function void minst_localRecArrThread_func;
    logic v_a[2];
    logic vv_a[4];
    logic [3:0] vv_b[4];
    integer sum;
    minst_t1_next = minst_t1;
    v_b_next = v_b;
    vv_a[1] = minst_s;
    vv_b[2] = vv_a[1] ? v_b_next[0] : v_b_next[1];
    sum = '0;
    for (int i_1 = 0; i_1 < 4; ++i_1)
    begin
        vv_b[i_1] = (i_1 < 2) ? v_b_next[i_1] : 4'(i_1);
        sum = sum + signed'({1'b0, vv_b[i_1]});
    end
    minst_t1_next = sum;
endfunction

// Synchronous register update
always_ff @(posedge minst_clk or negedge minst_nrst) 
begin : minst_localRecArrThread_ff
    if ( ~minst_nrst ) begin
        logic v_a[2];
        logic vv_a[4];
        logic [3:0] vv_b[4];
        for (int i = 0; i < 2; ++i)
        begin
            v_a[i] = '0;
            v_b[i] <= 32'(i + 2'sd1);
        end
    end
    else begin
        v_b <= v_b_next;
        minst_t1 <= minst_t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: minst_memRecThread (test_record_cthread.cpp:92:5) 

// Thread-local variables
logic [3:0] minst_r_b;
logic [3:0] minst_r_b_next;
logic signed [31:0] minst_t2_next;
logic minst_r_a;
logic minst_rr_a;
logic [3:0] minst_rr_b;
logic memRecThread_PROC_STATE;
logic memRecThread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : minst_memRecThread_comb     // test_record_cthread.cpp:92:5
    minst_memRecThread_func;
end
function void minst_memRecThread_func;
    integer i;
    minst_r_b_next = minst_r_b;
    minst_t2_next = minst_t2;
    memRecThread_PROC_STATE_next = memRecThread_PROC_STATE;
    
    case (memRecThread_PROC_STATE)
        0: begin
            minst_rr_a = minst_s;
            minst_rr_b = minst_rr_a ? minst_r_b_next : 4'd0;
            i = minst_r_b_next + minst_rr_b;
            minst_t2_next = i;
            memRecThread_PROC_STATE_next = 1; return;    // test_record_cthread.cpp:102:13;
        end
        1: begin
            minst_r_b_next = minst_r_b_next + 1'd1;
            minst_rr_a = minst_s;
            minst_rr_b = minst_rr_a ? minst_r_b_next : 4'd0;
            i = minst_r_b_next + minst_rr_b;
            minst_t2_next = i;
            memRecThread_PROC_STATE_next = 1; return;    // test_record_cthread.cpp:102:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge minst_clk or negedge minst_nrst) 
begin : minst_memRecThread_ff
    if ( ~minst_nrst ) begin
        logic minst_r_a;
        minst_r_a = '0;
        minst_r_b <= 1;
        memRecThread_PROC_STATE <= '0;    // test_record_cthread.cpp:95:9;
    end
    else begin
        minst_r_b <= minst_r_b_next;
        minst_t2 <= minst_t2_next;
        memRecThread_PROC_STATE <= memRecThread_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: minst_memRecArrThread (test_record_cthread.cpp:112:5) 

// Thread-local variables
logic [3:0] minst_w_b[2];
logic [3:0] minst_w_b_next[2];
logic signed [31:0] minst_t3_next;
logic minst_w_a[2];
logic minst_ww_a[4];
logic [3:0] minst_ww_b[4];

// Next-state combinational logic
always_comb begin : minst_memRecArrThread_comb     // test_record_cthread.cpp:112:5
    minst_memRecArrThread_func;
end
function void minst_memRecArrThread_func;
    integer sum;
    minst_t3_next = minst_t3;
    minst_w_b_next = minst_w_b;
    minst_ww_a[1] = minst_s;
    minst_ww_b[2] = minst_ww_a[1] ? minst_w_b_next[0] : minst_w_b_next[1];
    sum = '0;
    for (int i_1 = 0; i_1 < 4; ++i_1)
    begin
        minst_ww_b[i_1] = (i_1 < 2) ? minst_w_b_next[i_1] : 4'(i_1);
        sum = sum + signed'({1'b0, minst_ww_b[i_1]});
    end
    minst_t3_next = sum;
endfunction

// Synchronous register update
always_ff @(posedge minst_clk or negedge minst_nrst) 
begin : minst_memRecArrThread_ff
    if ( ~minst_nrst ) begin
        logic minst_w_a[2];
        for (int i = 0; i < 2; ++i)
        begin
            minst_w_a[i] = '0;
            minst_w_b[i] <= 32'(i + 2'sd1);
        end
    end
    else begin
        minst_w_b <= minst_w_b_next;
        minst_t3 <= minst_t3_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: minst_record_init_thrd (test_record_cthread.cpp:137:5) 

// Thread-local variables
logic [3:0] minst_mem_b[2];
logic [3:0] minst_mem_b_next[2];
logic [3:0] loc_b;
logic [3:0] loc_b_next;
logic signed [31:0] minst_t4_next;
logic minst_mem_a[2];

// Next-state combinational logic
always_comb begin : minst_record_init_thrd_comb     // test_record_cthread.cpp:137:5
    minst_record_init_thrd_func;
end
function void minst_record_init_thrd_func;
    logic loc_a;
    logic TMP_0_a;
    logic [3:0] TMP_0_b;
    logic TMP_1_a;
    logic [3:0] TMP_1_b;
    logic TMP_2_a;
    logic [3:0] TMP_2_b;
    logic TMP_3_a;
    logic [3:0] TMP_3_b;
    loc_b_next = loc_b;
    minst_mem_b_next = minst_mem_b;
    minst_t4_next = minst_t4;
    minst_t4_next = loc_b_next + minst_mem_b_next[minst_s];
    TMP_2_b = '0;
    loc_a = TMP_2_a; loc_b_next = TMP_2_b;
    TMP_3_b = '0;
    minst_mem_a[minst_s] = TMP_3_a; minst_mem_b_next[minst_s] = TMP_3_b;
endfunction

// Synchronous register update
always_ff @(posedge minst_clk or negedge minst_nrst) 
begin : minst_record_init_thrd_ff
    if ( ~minst_nrst ) begin
        logic loc_a;
        logic TMP_0_a;
        logic [3:0] TMP_0_b;
        logic TMP_1_a;
        logic [3:0] TMP_1_b;
        logic minst_mem_a[2];
        loc_b <= '0;
        TMP_0_b = '0;
        loc_a = TMP_0_a; loc_b <= TMP_0_b;
        TMP_1_b = '0;
        minst_mem_a[1] = TMP_1_a; minst_mem_b[1] <= TMP_1_b;
    end
    else begin
        minst_mem_b <= minst_mem_b_next;
        loc_b <= loc_b_next;
        minst_t4 <= minst_t4_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ninst_localRecThread (test_record_cthread.cpp:44:5) 

// Thread-local variables
logic [3:0] t_b0;
logic [3:0] t_b_next0;
logic signed [31:0] ninst_t0_next;
logic localRecThread_PROC_STATE0;
logic localRecThread_PROC_STATE_next0;

// Next-state combinational logic
always_comb begin : ninst_localRecThread_comb     // test_record_cthread.cpp:44:5
    ninst_localRecThread_func;
end
function void ninst_localRecThread_func;
    logic t_a;
    logic tt_a;
    logic [3:0] tt_b;
    integer i;
    ninst_t0_next = ninst_t0;
    t_b_next0 = t_b0;
    localRecThread_PROC_STATE_next0 = localRecThread_PROC_STATE0;
    
    case (localRecThread_PROC_STATE0)
        0: begin
            tt_a = ninst_s;
            tt_b = tt_a ? t_b_next0 : 4'd0;
            i = t_b_next0 + tt_b;
            ninst_t0_next = i;
            localRecThread_PROC_STATE_next0 = 1; return;    // test_record_cthread.cpp:56:13;
        end
        1: begin
            t_b_next0 = t_b_next0 + 1'd1;
            tt_a = ninst_s;
            tt_b = tt_a ? t_b_next0 : 4'd0;
            i = t_b_next0 + tt_b;
            ninst_t0_next = i;
            localRecThread_PROC_STATE_next0 = 1; return;    // test_record_cthread.cpp:56:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge ninst_clk or negedge ninst_nrst) 
begin : ninst_localRecThread_ff
    if ( ~ninst_nrst ) begin
        logic t_a;
        logic tt_a;
        logic [3:0] tt_b;
        t_b0 <= '0;
        tt_b = '0;
        t_a = '0;
        t_b0 <= 1;
        localRecThread_PROC_STATE0 <= '0;    // test_record_cthread.cpp:49:9;
    end
    else begin
        t_b0 <= t_b_next0;
        ninst_t0 <= ninst_t0_next;
        localRecThread_PROC_STATE0 <= localRecThread_PROC_STATE_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ninst_localRecArrThread (test_record_cthread.cpp:64:5) 

// Thread-local variables
logic [3:0] v_b0[2];
logic [3:0] v_b_next0[2];
logic signed [31:0] ninst_t1_next;

// Next-state combinational logic
always_comb begin : ninst_localRecArrThread_comb     // test_record_cthread.cpp:64:5
    ninst_localRecArrThread_func;
end
function void ninst_localRecArrThread_func;
    logic v_a[2];
    logic vv_a[4];
    logic [3:0] vv_b[4];
    integer sum;
    ninst_t1_next = ninst_t1;
    v_b_next0 = v_b0;
    vv_a[1] = ninst_s;
    vv_b[2] = vv_a[1] ? v_b_next0[0] : v_b_next0[1];
    sum = '0;
    for (int i_1 = 0; i_1 < 4; ++i_1)
    begin
        vv_b[i_1] = (i_1 < 2) ? v_b_next0[i_1] : 4'(i_1);
        sum = sum + signed'({1'b0, vv_b[i_1]});
    end
    ninst_t1_next = sum;
endfunction

// Synchronous register update
always_ff @(posedge ninst_clk or negedge ninst_nrst) 
begin : ninst_localRecArrThread_ff
    if ( ~ninst_nrst ) begin
        logic v_a[2];
        logic vv_a[4];
        logic [3:0] vv_b[4];
        for (int i = 0; i < 2; ++i)
        begin
            v_a[i] = '0;
            v_b0[i] <= 32'(i + 2'sd1);
        end
    end
    else begin
        v_b0 <= v_b_next0;
        ninst_t1 <= ninst_t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ninst_memRecThread (test_record_cthread.cpp:92:5) 

// Thread-local variables
logic [3:0] ninst_r_b;
logic [3:0] ninst_r_b_next;
logic signed [31:0] ninst_t2_next;
logic ninst_r_a;
logic ninst_rr_a;
logic [3:0] ninst_rr_b;
logic memRecThread_PROC_STATE0;
logic memRecThread_PROC_STATE_next0;

// Next-state combinational logic
always_comb begin : ninst_memRecThread_comb     // test_record_cthread.cpp:92:5
    ninst_memRecThread_func;
end
function void ninst_memRecThread_func;
    integer i;
    ninst_r_b_next = ninst_r_b;
    ninst_t2_next = ninst_t2;
    memRecThread_PROC_STATE_next0 = memRecThread_PROC_STATE0;
    
    case (memRecThread_PROC_STATE0)
        0: begin
            ninst_rr_a = ninst_s;
            ninst_rr_b = ninst_rr_a ? ninst_r_b_next : 4'd0;
            i = ninst_r_b_next + ninst_rr_b;
            ninst_t2_next = i;
            memRecThread_PROC_STATE_next0 = 1; return;    // test_record_cthread.cpp:102:13;
        end
        1: begin
            ninst_r_b_next = ninst_r_b_next + 1'd1;
            ninst_rr_a = ninst_s;
            ninst_rr_b = ninst_rr_a ? ninst_r_b_next : 4'd0;
            i = ninst_r_b_next + ninst_rr_b;
            ninst_t2_next = i;
            memRecThread_PROC_STATE_next0 = 1; return;    // test_record_cthread.cpp:102:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge ninst_clk or negedge ninst_nrst) 
begin : ninst_memRecThread_ff
    if ( ~ninst_nrst ) begin
        logic ninst_r_a;
        ninst_r_a = '0;
        ninst_r_b <= 1;
        memRecThread_PROC_STATE0 <= '0;    // test_record_cthread.cpp:95:9;
    end
    else begin
        ninst_r_b <= ninst_r_b_next;
        ninst_t2 <= ninst_t2_next;
        memRecThread_PROC_STATE0 <= memRecThread_PROC_STATE_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ninst_memRecArrThread (test_record_cthread.cpp:112:5) 

// Thread-local variables
logic [3:0] ninst_w_b[2];
logic [3:0] ninst_w_b_next[2];
logic signed [31:0] ninst_t3_next;
logic ninst_w_a[2];
logic ninst_ww_a[4];
logic [3:0] ninst_ww_b[4];

// Next-state combinational logic
always_comb begin : ninst_memRecArrThread_comb     // test_record_cthread.cpp:112:5
    ninst_memRecArrThread_func;
end
function void ninst_memRecArrThread_func;
    integer sum;
    ninst_t3_next = ninst_t3;
    ninst_w_b_next = ninst_w_b;
    ninst_ww_a[1] = ninst_s;
    ninst_ww_b[2] = ninst_ww_a[1] ? ninst_w_b_next[0] : ninst_w_b_next[1];
    sum = '0;
    for (int i_1 = 0; i_1 < 4; ++i_1)
    begin
        ninst_ww_b[i_1] = (i_1 < 2) ? ninst_w_b_next[i_1] : 4'(i_1);
        sum = sum + signed'({1'b0, ninst_ww_b[i_1]});
    end
    ninst_t3_next = sum;
endfunction

// Synchronous register update
always_ff @(posedge ninst_clk or negedge ninst_nrst) 
begin : ninst_memRecArrThread_ff
    if ( ~ninst_nrst ) begin
        logic ninst_w_a[2];
        for (int i = 0; i < 2; ++i)
        begin
            ninst_w_a[i] = '0;
            ninst_w_b[i] <= 32'(i + 2'sd1);
        end
    end
    else begin
        ninst_w_b <= ninst_w_b_next;
        ninst_t3 <= ninst_t3_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ninst_record_init_thrd (test_record_cthread.cpp:137:5) 

// Thread-local variables
logic [3:0] ninst_mem_b[2];
logic [3:0] ninst_mem_b_next[2];
logic [3:0] loc_b0;
logic [3:0] loc_b_next0;
logic signed [31:0] ninst_t4_next;
logic ninst_mem_a[2];

// Next-state combinational logic
always_comb begin : ninst_record_init_thrd_comb     // test_record_cthread.cpp:137:5
    ninst_record_init_thrd_func;
end
function void ninst_record_init_thrd_func;
    logic loc_a;
    logic TMP_0_a;
    logic [3:0] TMP_0_b;
    logic TMP_1_a;
    logic [3:0] TMP_1_b;
    logic TMP_2_a;
    logic [3:0] TMP_2_b;
    logic TMP_3_a;
    logic [3:0] TMP_3_b;
    loc_b_next0 = loc_b0;
    ninst_mem_b_next = ninst_mem_b;
    ninst_t4_next = ninst_t4;
    ninst_t4_next = loc_b_next0 + ninst_mem_b_next[ninst_s];
    TMP_2_b = '0;
    loc_a = TMP_2_a; loc_b_next0 = TMP_2_b;
    TMP_3_b = '0;
    ninst_mem_a[ninst_s] = TMP_3_a; ninst_mem_b_next[ninst_s] = TMP_3_b;
endfunction

// Synchronous register update
always_ff @(posedge ninst_clk or negedge ninst_nrst) 
begin : ninst_record_init_thrd_ff
    if ( ~ninst_nrst ) begin
        logic loc_a;
        logic TMP_0_a;
        logic [3:0] TMP_0_b;
        logic TMP_1_a;
        logic [3:0] TMP_1_b;
        logic ninst_mem_a[2];
        loc_b0 <= '0;
        TMP_0_b = '0;
        loc_a = TMP_0_a; loc_b0 <= TMP_0_b;
        TMP_1_b = '0;
        ninst_mem_a[1] = TMP_1_a; ninst_mem_b[1] <= TMP_1_b;
    end
    else begin
        ninst_mem_b <= ninst_mem_b_next;
        loc_b0 <= loc_b_next0;
        ninst_t4 <= ninst_t4_next;
    end
end

endmodule


