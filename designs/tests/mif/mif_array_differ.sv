//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.14
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
);

// Variables generated for SystemC signals
logic signed [31:0] a1_s;
logic signed [31:0] a1_mif1_tt;
logic signed [31:0] a1_mif2_tt;
logic signed [31:0] a1_mif_arr_tt[2];
logic signed [31:0] a1_t2;
logic signed [31:0] a1_t0;
logic signed [31:0] a1_t1;
logic signed [31:0] a2_s;
logic signed [31:0] a2_mif1_tt;
logic signed [31:0] a2_mif2_tt;
logic signed [31:0] a2_mif_arr_tt[2];
logic signed [31:0] a2_t2;
logic signed [31:0] a2_t0;
logic signed [31:0] a2_t1;
logic signed [31:0] ar_s[2];
logic signed [31:0] ar_mif1_tt[2];
logic signed [31:0] ar_mif2_tt[2];
logic signed [31:0] ar_mif_arr_tt[2][2];
logic signed [31:0] ar_t2[2];
logic signed [31:0] ar_t0[2];
logic signed [31:0] ar_t1[2];

// Local parameters generated for C++ constants
localparam logic [31:0] a1_mif1_M = 42;
localparam logic [31:0] a1_mif1_AR[2] = '{ 42, 42 };
localparam logic [31:0] a1_mif2_M = 43;
localparam logic [31:0] a1_mif2_AR[2] = '{ 43, 43 };
localparam logic [31:0] a1_mif_arr_M[2] = '{ 42, 42 };
localparam logic [31:0] a1_mif_arr_AR[2][2] = '{ '{ 42, 42 }, '{ 42, 42 } };
localparam logic [15:0] a1_X = 42;
localparam logic signed [31:0] a1_V = 42;
localparam logic [31:0] a1_W = 42;
localparam logic a1_Z = 0;
localparam logic [31:0] a1_C = 42;
localparam logic signed [31:0] a1_BR[2] = '{ 1, 1 };
localparam logic [31:0] a2_mif1_M = 43;
localparam logic [31:0] a2_mif1_AR[2] = '{ 43, 43 };
localparam logic [31:0] a2_mif2_M = 44;
localparam logic [31:0] a2_mif2_AR[2] = '{ 44, 44 };
localparam logic [31:0] a2_mif_arr_M[2] = '{ 43, 43 };
localparam logic [31:0] a2_mif_arr_AR[2][2] = '{ '{ 43, 43 }, '{ 43, 43 } };
localparam logic [15:0] a2_X = 42;
localparam logic signed [31:0] a2_V = 43;
localparam logic [31:0] a2_W = 42;
localparam logic a2_Z = 0;
localparam logic [31:0] a2_C = 43;
localparam logic signed [31:0] a2_BR[2] = '{ 1, 1 };
localparam logic [31:0] ar_mif1_M[2] = '{ 1, 1 };
localparam logic [31:0] ar_mif1_AR[2][2] = '{ '{ 1, 1 }, '{ 1, 1 } };
localparam logic [31:0] ar_mif2_M[2] = '{ 2, 2 };
localparam logic [31:0] ar_mif2_AR[2][2] = '{ '{ 2, 2 }, '{ 2, 2 } };
localparam logic [31:0] ar_mif_arr_M[2][2] = '{ '{ 1, 1 }, '{ 1, 1 } };
localparam logic [31:0] ar_mif_arr_AR[2][2][2] = '{ '{ '{ 1, 1 }, '{ 1, 1 } }, '{ '{ 1, 1 }, '{ 1, 1 } } };
localparam logic [15:0] ar_X[2] = '{ 42, 42 };
localparam logic signed [31:0] ar_V[2] = '{ 1, 2 };
localparam logic [31:0] ar_W[2] = '{ 42, 42 };
localparam logic ar_Z[2] = '{ 1, 1 };
localparam logic [31:0] ar_C[2] = '{ 1, 1 };
localparam logic signed [31:0] ar_BR[2][2] = '{ '{ 1, 1 }, '{ 1, 1 } };

//------------------------------------------------------------------------------
// Method process: mif1_mif_proc (test_mif_array_differ.cpp:37:5) 

always_comb 
begin : mif1_mif_proc     // test_mif_array_differ.cpp:37:5
    a1_mif1_tt = a1_mif1_AR[0];
    a1_mif1_tt = a1_mif1_AR[1];
end

//------------------------------------------------------------------------------
// Method process: mif2_mif_proc (test_mif_array_differ.cpp:37:5) 

always_comb 
begin : mif2_mif_proc     // test_mif_array_differ.cpp:37:5
    a1_mif2_tt = a1_mif2_AR[0];
end

//------------------------------------------------------------------------------
// Method process: mif_arr_mif_proc (test_mif_array_differ.cpp:37:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : mif_arr_mif_proc_sct_i 

    always_comb 
    begin : mif_arr_mif_proc     // test_mif_array_differ.cpp:37:5
        a1_mif_arr_tt[sct_i] = a1_mif_arr_AR[sct_i][0];
        a1_mif_arr_tt[sct_i] = a1_mif_arr_AR[sct_i][1];
        if (a1_mif_arr_AR[sct_i][0] == 2)
        begin
            a1_mif_arr_tt[sct_i] = 0;
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: a1_cpa_issue (test_mif_array_differ.cpp:86:5) 

always_comb 
begin : a1_cpa_issue     // test_mif_array_differ.cpp:86:5
    a1_t2 = 0;
    a1_t2 = 1;
    a1_t2 = 2;
    a1_t2 = 3;
    if (|a1_BR[a1_s])
    begin
        a1_t2 = 1;
    end
    a1_t2 = 0;
end

//------------------------------------------------------------------------------
// Method process: a1_proc1 (test_mif_array_differ.cpp:97:5) 

always_comb 
begin : a1_proc1     // test_mif_array_differ.cpp:97:5
    integer unsigned l;
    l = a1_X;
    l = a1_V;
    l = a1_W + 1;
    l = 2;
    a1_t0 = l;
end

//------------------------------------------------------------------------------
// Method process: a1_proc2 (test_mif_array_differ.cpp:107:5) 

always_comb 
begin : a1_proc2     // test_mif_array_differ.cpp:107:5
    integer unsigned l;
    l = a1_X + 1;
    a1_t1 = l;
end

//------------------------------------------------------------------------------
// Method process: mif1_mif_proc0 (test_mif_array_differ.cpp:37:5) 

always_comb 
begin : mif1_mif_proc0     // test_mif_array_differ.cpp:37:5
    a2_mif1_tt = a2_mif1_AR[0];
end

//------------------------------------------------------------------------------
// Method process: mif2_mif_proc0 (test_mif_array_differ.cpp:37:5) 

always_comb 
begin : mif2_mif_proc0     // test_mif_array_differ.cpp:37:5
    a2_mif2_tt = a2_mif2_AR[0];
end

//------------------------------------------------------------------------------
// Method process: mif_arr_mif_proc0 (test_mif_array_differ.cpp:37:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : mif_arr_mif_proc0_sct_i 

    always_comb 
    begin : mif_arr_mif_proc0     // test_mif_array_differ.cpp:37:5
        a2_mif_arr_tt[sct_i] = a2_mif_arr_AR[sct_i][0];
        if (a2_mif_arr_AR[sct_i][0] == 2)
        begin
            a2_mif_arr_tt[sct_i] = 0;
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: a2_cpa_issue (test_mif_array_differ.cpp:86:5) 

always_comb 
begin : a2_cpa_issue     // test_mif_array_differ.cpp:86:5
    a2_t2 = 0;
    a2_t2 = 1;
    a2_t2 = 2;
    a2_t2 = 3;
    if (|a2_BR[a2_s])
    begin
        a2_t2 = 1;
    end
    a2_t2 = 0;
end

//------------------------------------------------------------------------------
// Method process: a2_proc1 (test_mif_array_differ.cpp:97:5) 

always_comb 
begin : a2_proc1     // test_mif_array_differ.cpp:97:5
    integer unsigned l;
    l = a2_X;
    l = a2_V;
    l = a2_W + 1;
    l = 2;
    a2_t0 = l;
end

//------------------------------------------------------------------------------
// Method process: a2_proc2 (test_mif_array_differ.cpp:107:5) 

always_comb 
begin : a2_proc2     // test_mif_array_differ.cpp:107:5
    integer unsigned l;
    l = a2_X + 1;
    a2_t1 = l;
end

//------------------------------------------------------------------------------
// Method process: mif1_mif_proc1 (test_mif_array_differ.cpp:37:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : mif1_mif_proc1_sct_i 

    always_comb 
    begin : mif1_mif_proc1     // test_mif_array_differ.cpp:37:5
        ar_mif1_tt[sct_i] = ar_mif1_AR[sct_i][0];
        if (ar_mif1_AR[sct_i][0] == 2)
        begin
            ar_mif1_tt[sct_i] = 0;
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: mif2_mif_proc1 (test_mif_array_differ.cpp:37:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : mif2_mif_proc1_sct_i 

    always_comb 
    begin : mif2_mif_proc1     // test_mif_array_differ.cpp:37:5
        ar_mif2_tt[sct_i] = ar_mif2_AR[sct_i][0];
        if (ar_mif2_AR[sct_i][0] == 2)
        begin
            ar_mif2_tt[sct_i] = 0;
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: mif_arr_mif_proc1 (test_mif_array_differ.cpp:37:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : mif_arr_mif_proc1_sct_i 
for (genvar sct_j = 0; sct_j != 2; sct_j = sct_j + 1) 
begin : mif_arr_mif_proc1_sct_j 

    always_comb 
    begin : mif_arr_mif_proc1     // test_mif_array_differ.cpp:37:5
        ar_mif_arr_tt[sct_i][sct_j] = ar_mif_arr_AR[sct_i][sct_j][0];
        if (ar_mif_arr_AR[sct_i][sct_j][0] == 2)
        begin
            ar_mif_arr_tt[sct_i][sct_j] = 0;
        end
    end

end
end
endgenerate

//------------------------------------------------------------------------------
// Method process: ar_cpa_issue (test_mif_array_differ.cpp:86:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : ar_cpa_issue_sct_i 

    always_comb 
    begin : ar_cpa_issue     // test_mif_array_differ.cpp:86:5
        ar_t2[sct_i] = 0;
        ar_t2[sct_i] = 1;
        ar_t2[sct_i] = 2;
        ar_t2[sct_i] = 3;
        if (|ar_BR[sct_i][ar_s[sct_i]])
        begin
            ar_t2[sct_i] = 1;
        end
        if (|ar_BR[sct_i][0])
        begin
            ar_t2[sct_i] = 0;
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: ar_proc1 (test_mif_array_differ.cpp:97:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : ar_proc1_sct_i 

    always_comb 
    begin : ar_proc1     // test_mif_array_differ.cpp:97:5
        integer unsigned l;
        l = ar_X[sct_i];
        l = ar_V[sct_i];
        l = 42;
        l = 1;
        ar_t0[sct_i] = l;
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: ar_proc2 (test_mif_array_differ.cpp:107:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : ar_proc2_sct_i 

    always_comb 
    begin : ar_proc2     // test_mif_array_differ.cpp:107:5
        integer unsigned l;
        l = ar_X[sct_i] + 1;
        ar_t1[sct_i] = l;
    end

end
endgenerate

endmodule


