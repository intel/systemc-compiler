//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.7.00
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic minst_nrst[2];
logic minst_s[2];
logic signed [31:0] minst_t0[2];
logic signed [31:0] minst_t1[2];
logic signed [31:0] minst_t4[2];
logic minst_clk[2];

// Assignments generated for C++ channel arrays
assign minst_clk[0] = clk;
assign minst_clk[1] = clk;

//------------------------------------------------------------------------------
// Clocked THREAD: minst_memRecThread (test_array_record_cthread.cpp:54:5) 

// Thread-local variables
logic signed [31:0] minst_rr_rec_arr_c[2][2];
logic signed [31:0] minst_rr_rec_arr_c_next[2][2];
logic [3:0] minst_r_b[2][3];
logic [3:0] minst_r_b_next[2][3];
logic signed [31:0] minst_t0_next[2];
logic signed [31:0] minst_r_rec_c[2];
logic minst_rr_a[2];
logic [3:0] minst_rr_b[2][3];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_memRecThread_sct_i 

    // Next-state combinational logic
    always_comb begin : minst_memRecThread_comb     // test_array_record_cthread.cpp:54:5
        minst_memRecThread_func;
    end
    function void minst_memRecThread_func;
        integer i;
        minst_r_b_next[sct_i] = minst_r_b[sct_i];
        minst_rr_rec_arr_c_next[sct_i] = minst_rr_rec_arr_c[sct_i];
        minst_t0_next[sct_i] = minst_t0[sct_i];
        minst_r_b_next[sct_i][0] = 1;
        minst_r_rec_c[sct_i] = 2;
        minst_rr_a[sct_i] = minst_s[sct_i];
        minst_rr_b[sct_i][2] = 3;
        minst_rr_rec_arr_c_next[sct_i][1] = 4;
        i = minst_rr_rec_arr_c_next[sct_i][0] + minst_r_b_next[sct_i][1];
        minst_t0_next[sct_i] = i;
    endfunction

    // Synchronous register update
    always_ff @(posedge minst_clk[sct_i] or negedge minst_nrst[sct_i]) 
    begin : minst_memRecThread_ff
        if ( ~minst_nrst[sct_i] ) begin
        end
        else begin
            minst_rr_rec_arr_c[sct_i] <= minst_rr_rec_arr_c_next[sct_i];
            minst_r_b[sct_i] <= minst_r_b_next[sct_i];
            minst_t0[sct_i] <= minst_t0_next[sct_i];
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: minst_memRecArrThread (test_array_record_cthread.cpp:76:5) 

// Thread-local variables
logic signed [31:0] minst_w_rec_c[2][2];
logic signed [31:0] minst_w_rec_c_next[2][2];
logic signed [31:0] minst_ww_rec_c[2][3];
logic signed [31:0] minst_ww_rec_c_next[2][3];
logic signed [31:0] minst_t1_next[2];
logic minst_w_a[2][2];
logic [3:0] minst_w_b[2][2][3];
logic signed [31:0] minst_w_rec_arr_c[2][2][2];
logic signed [31:0] minst_ww_rec_arr_c[2][3][2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_memRecArrThread_sct_i 

    // Next-state combinational logic
    always_comb begin : minst_memRecArrThread_comb     // test_array_record_cthread.cpp:76:5
        minst_memRecArrThread_func;
    end
    function void minst_memRecArrThread_func;
        integer i;
        minst_t1_next[sct_i] = minst_t1[sct_i];
        minst_w_rec_c_next[sct_i] = minst_w_rec_c[sct_i];
        minst_ww_rec_c_next[sct_i] = minst_ww_rec_c[sct_i];
        minst_w_a[sct_i][0] = minst_s[sct_i];
        minst_w_b[sct_i][0][1] = 1;
        minst_w_rec_c_next[sct_i][1] = 2;
        minst_w_rec_arr_c[sct_i][0][1] = 3;
        minst_ww_rec_arr_c[sct_i][0][1] = 4;
        i = 32'(32'(32'(minst_w_rec_arr_c[sct_i][0][1] + minst_ww_rec_arr_c[sct_i][0][1]) + minst_w_rec_c_next[sct_i][0]) + minst_ww_rec_c_next[sct_i][0]);
        minst_t1_next[sct_i] = i;
    endfunction

    // Synchronous register update
    always_ff @(posedge minst_clk[sct_i] or negedge minst_nrst[sct_i]) 
    begin : minst_memRecArrThread_ff
        if ( ~minst_nrst[sct_i] ) begin
        end
        else begin
            minst_w_rec_c[sct_i] <= minst_w_rec_c_next[sct_i];
            minst_ww_rec_c[sct_i] <= minst_ww_rec_c_next[sct_i];
            minst_t1[sct_i] <= minst_t1_next[sct_i];
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: minst_record_init_thrd (test_array_record_cthread.cpp:102:5) 

// Thread-local variables
logic [3:0] minst_mem_b[2][2][3];
logic [3:0] minst_mem_b_next[2][2][3];
logic [3:0] loc_b[2][3];
logic [3:0] loc_b_next[2][3];
logic signed [31:0] minst_t4_next[2];
logic [7:0] minst_mem_a[2][2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_record_init_thrd_sct_i 

    // Next-state combinational logic
    always_comb begin : minst_record_init_thrd_comb     // test_array_record_cthread.cpp:102:5
        minst_record_init_thrd_func;
    end
    function void minst_record_init_thrd_func;
        logic [7:0] loc_a;
        logic [7:0] TMP_0_a;
        logic [3:0] TMP_0_b[3];
        logic [7:0] TMP_1_a;
        logic [3:0] TMP_1_b[3];
        logic [7:0] TMP_2_a;
        logic [3:0] TMP_2_b[3];
        logic [7:0] TMP_3_a;
        logic [3:0] TMP_3_b[3];
        loc_b_next[sct_i] = loc_b[sct_i];
        minst_mem_b_next[sct_i] = minst_mem_b[sct_i];
        minst_t4_next[sct_i] = minst_t4[sct_i];
        minst_t4_next[sct_i] = loc_b_next[sct_i][minst_s[sct_i]] + minst_mem_b_next[sct_i][minst_s[sct_i]][1];
        TMP_2_a = 1'd1;
        TMP_2_b[0] = 0; TMP_2_b[1] = 0; TMP_2_b[2] = 0;
        loc_a = TMP_2_a; loc_b_next[sct_i] = TMP_2_b;
        TMP_3_a = 1'd1;
        TMP_3_b[0] = 0; TMP_3_b[1] = 0; TMP_3_b[2] = 0;
        minst_mem_a[sct_i][minst_s[sct_i]] = TMP_3_a; minst_mem_b_next[sct_i][minst_s[sct_i]] = TMP_3_b;
    endfunction

    // Synchronous register update
    always_ff @(posedge minst_clk[sct_i] or negedge minst_nrst[sct_i]) 
    begin : minst_record_init_thrd_ff
        if ( ~minst_nrst[sct_i] ) begin
            logic [7:0] loc_a;
            logic [7:0] TMP_0_a;
            logic [3:0] TMP_0_b[3];
            logic [7:0] TMP_1_a;
            logic [3:0] TMP_1_b[3];
            logic [7:0] minst_mem_a[2];
            loc_a = 1'd1;
            loc_b[sct_i][0] <= 0; loc_b[sct_i][1] <= 0; loc_b[sct_i][2] <= 0;
            TMP_0_a = 1'd1;
            TMP_0_b[0] = 0; TMP_0_b[1] = 0; TMP_0_b[2] = 0;
            loc_a = TMP_0_a; loc_b[sct_i] <= TMP_0_b;
            TMP_1_a = 1'd1;
            TMP_1_b[0] = 0; TMP_1_b[1] = 0; TMP_1_b[2] = 0;
            minst_mem_a[sct_i][1] = TMP_1_a; minst_mem_b[sct_i][1] <= TMP_1_b;
        end
        else begin
            minst_mem_b[sct_i] <= minst_mem_b_next[sct_i];
            loc_b[sct_i] <= loc_b_next[sct_i];
            minst_t4[sct_i] <= minst_t4_next[sct_i];
        end
    end

end
endgenerate

endmodule


