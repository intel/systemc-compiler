//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.14
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Dut ()
//
module Dut // "dut"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic a2_rst;
logic [3:0] a2_s;
logic [3:0] a2_ss;
logic signed [31:0] a2_t0;
logic signed [31:0] a2_t1;
logic a2_clk;

// Assignments generated for C++ channel arrays
assign a2_clk = clk;

//------------------------------------------------------------------------------
// Clocked THREAD: a2_thread1 (test_cthread_mif.cpp:36:5) 

// Thread-local variables
logic [3:0] a2_s_next;
logic signed [31:0] a2_t0_next;
logic [3:0] a2_v;

// Next-state combinational logic
always_comb begin : a2_thread1_comb     // test_cthread_mif.cpp:36:5
    a2_thread1_func;
end
function void a2_thread1_func;
    logic [63:0] a;
    a2_s_next = a2_s;
    a2_t0_next = a2_t0;
    a2_v = 3;
    a2_s_next = 4;
    a = a2_v + a2_s;
    a2_t0_next = a;
endfunction

// Synchronous register update
always_ff @(posedge a2_clk or posedge a2_rst) 
begin : a2_thread1_ff
    if ( a2_rst ) begin
        logic [3:0] a2_v;
        a2_s <= 1;
        a2_v = 2;
    end
    else begin
        a2_s <= a2_s_next;
        a2_t0 <= a2_t0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: a2_thread2 (test_cthread_mif.cpp:52:5) 

// Thread-local variables
logic signed [31:0] a2_t1_next;

// Next-state combinational logic
always_comb begin : a2_thread2_comb     // test_cthread_mif.cpp:52:5
    a2_thread2_func;
end
function void a2_thread2_func;
    logic [3:0] a;
    a2_t1_next = a2_t1;
    a = a2_ss;
    a2_t1_next = a;
endfunction

// Synchronous register update
always_ff @(posedge a2_clk or posedge a2_rst) 
begin : a2_thread2_ff
    if ( a2_rst ) begin
    end
    else begin
        a2_t1 <= a2_t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread (test_cthread_mif.cpp:80:5) 

// Thread-local variables
logic [3:0] a2_ss_next;

// Next-state combinational logic
always_comb begin : top_thread_comb     // test_cthread_mif.cpp:80:5
    top_thread_func;
end
function void top_thread_func;
    a2_ss_next = a2_ss;
    a2_ss_next = 3;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_ff
    if ( rst ) begin
        a2_ss <= 1;
    end
    else begin
        a2_ss <= a2_ss_next;
    end
end

endmodule


