//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic aminst_rst[2];
logic signed [31:0] aminst_t[2];
logic signed [31:0] s;
logic rst;
logic aminst_clk[2];

// Local parameters generated for C++ constants
localparam logic [31:0] aminst_C[2] = '{ 54, 54 };
localparam logic [31:0] aminst_A = 52;
localparam logic [31:0] aminst_B = 53;

// Assignments generated for C++ channel arrays
assign aminst_clk[0] = clk;
assign aminst_clk[1] = clk;

//------------------------------------------------------------------------------
// Clocked THREAD: aminst_mifProc (test_mif_const1.cpp:29:5) 

// Thread-local variables
logic [31:0] lr[2];
logic [31:0] lr_next[2];
logic [31:0] i[2];
logic [31:0] i_next[2];
logic [31:0] LB[2];
logic [31:0] LB_next[2];
logic signed [31:0] aminst_t_next[2];
logic mifProc_PROC_STATE[2];
logic mifProc_PROC_STATE_next[2];

// Thread-local constants
logic [31:0] LR[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : aminst_mifProc_sct_i 

    // Next-state combinational logic
    always_comb begin : aminst_mifProc_comb     // test_mif_const1.cpp:29:5
        aminst_mifProc_func;
    end
    function void aminst_mifProc_func;
        integer unsigned LA;
        integer unsigned LC;
        integer unsigned j;
        LB_next[sct_i] = LB[sct_i];
        aminst_t_next[sct_i] = aminst_t[sct_i];
        i_next[sct_i] = i[sct_i];
        lr_next[sct_i] = lr[sct_i];
        mifProc_PROC_STATE_next[sct_i] = mifProc_PROC_STATE[sct_i];
    
        case (mifProc_PROC_STATE[sct_i])
            0: begin
                LB_next[sct_i] = 6'd58;
                LC = 6'd59;
                j = aminst_A + aminst_B + aminst_C[sct_i] + LR[sct_i] + lr_next[sct_i];
                aminst_t_next[sct_i] = j + i_next[sct_i] + LC;
                mifProc_PROC_STATE_next[sct_i] = 1; return;    // test_mif_const1.cpp:41:13;
            end
            1: begin
                aminst_t_next[sct_i] = LB_next[sct_i];
                LB_next[sct_i] = 6'd58;
                LC = 6'd59;
                j = aminst_A + aminst_B + aminst_C[sct_i] + LR[sct_i] + lr_next[sct_i];
                aminst_t_next[sct_i] = j + i_next[sct_i] + LC;
                mifProc_PROC_STATE_next[sct_i] = 1; return;    // test_mif_const1.cpp:41:13;
            end
        endcase
    endfunction

    // Synchronous register update
    always_ff @(posedge aminst_clk[sct_i] or negedge aminst_rst[sct_i]) 
    begin : aminst_mifProc_ff
        if ( ~aminst_rst[sct_i] ) begin
            integer unsigned LA;
            lr[sct_i] <= 6'd55;
            LR[sct_i] = 6'd56;
            LA = 6'd57;
            i[sct_i] <= aminst_A + aminst_B + aminst_C[sct_i] + LA;
            mifProc_PROC_STATE[sct_i] <= '0;    // test_mif_const1.cpp:35:9;
        end
        else begin
            lr[sct_i] <= lr_next[sct_i];
            i[sct_i] <= i_next[sct_i];
            LB[sct_i] <= LB_next[sct_i];
            aminst_t[sct_i] <= aminst_t_next[sct_i];
            mifProc_PROC_STATE[sct_i] <= mifProc_PROC_STATE_next[sct_i];
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: topProc (test_mif_const1.cpp:67:5) 

// Thread-local variables
logic signed [31:0] sum;
logic signed [31:0] sum_next;
logic signed [31:0] s_next;

// Next-state combinational logic
always_comb begin : topProc_comb     // test_mif_const1.cpp:67:5
    topProc_func;
end
function void topProc_func;
    integer i_2;
    s_next = s;
    sum_next = sum;
    i_2 = s;
    sum_next = sum_next + (signed'({1'b0, aminst_A + aminst_B + aminst_C[i_2]}));
    s_next = sum_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : topProc_ff
    if ( ~rst ) begin
        integer k;
        k = '0;
        for (int i_1 = 0; i_1 < 2; ++i_1)
        begin
            k = k + (signed'({1'b0, aminst_A + aminst_B + aminst_C[i_1]}));
        end
        sum <= k;
    end
    else begin
        sum <= sum_next;
        s <= s_next;
    end
end

endmodule


