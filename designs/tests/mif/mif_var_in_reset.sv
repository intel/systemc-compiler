//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.26
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic [3:0] minst_s[2];
logic minst_clk[2];
logic minst_nrst[2];

// Assignments generated for C++ channel arrays
assign minst_clk[0] = clk;
assign minst_clk[1] = clk;
assign minst_nrst[0] = nrst;
assign minst_nrst[1] = nrst;

//------------------------------------------------------------------------------
// Clocked THREAD: minst_threadProc (test_var_in_reset.cpp:31:5) 

// Thread-local variables
logic [3:0] minst_s_next[2];
logic signed [31:0] b[2];
logic signed [31:0] b_next[2];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 2; sct_i = sct_i + 1) 
begin : minst_threadProc_sct_i 

    // Next-state combinational logic
    always_comb begin : minst_threadProc_comb     // test_var_in_reset.cpp:31:5
        minst_threadProc_func;
    end
    function void minst_threadProc_func;
        b_next[sct_i] = b[sct_i];
        minst_s_next[sct_i] = minst_s[sct_i];
        minst_s_next[sct_i] = minst_s[sct_i] + b_next[sct_i];
    endfunction

    // Synchronous register update
    always_ff @(posedge minst_clk[sct_i] or negedge minst_nrst[sct_i]) 
    begin : minst_threadProc_ff
        if ( ~minst_nrst[sct_i] ) begin
            logic a;
            logic [3:0] c;
            a = 1;
            b[sct_i] <= 42;
            c = b[sct_i] >>> 4;
            minst_s[sct_i] <= c + 1'd1;
        end
        else begin
            minst_s[sct_i] <= minst_s_next[sct_i];
            b[sct_i] <= b_next[sct_i];
        end
    end

end
endgenerate

endmodule


