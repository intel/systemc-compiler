//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.16
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
);

// Variables generated for SystemC signals
logic clk;
logic enable;
logic [15:0] data_in;
logic rstn;
logic arstn;
logic sreset;
logic [15:0] q_pos_out;
logic [15:0] q_neg_out;
logic [15:0] q_one_out;
logic [15:0] q_zero_out;
logic [15:0] async_rst_dff_out;
logic [15:0] sync_rst_dff_out;
logic [15:0] async_rst_tff_out;
logic [15:0] sync_rst_tff_out;
logic [15:0] async_rst_tff_out2;
logic [15:0] async_rst_tff_out3;


//------------------------------------------------------------------------------
// Child module instances

A a_mod
(
  .clk(clk),
  .enable(enable),
  .data_in(data_in),
  .rstn(rstn),
  .q_pos_out(q_pos_out),
  .q_neg_out(q_neg_out),
  .q_one_out(q_one_out),
  .q_zero_out(q_zero_out),
  .async_rst_dff_out(async_rst_dff_out),
  .sync_rst_dff_out(sync_rst_dff_out),
  .async_rst_tff_out(async_rst_tff_out),
  .sync_rst_tff_out(sync_rst_tff_out),
  .async_rst_tff_out2(async_rst_tff_out2),
  .async_rst_tff_out3(async_rst_tff_out3),
  .arstn(arstn),
  .sreset(sreset)
);

endmodule



//==============================================================================
//
// Module: A (test_ff_latch.cpp:212:5)
//
module A // "b_mod.a_mod"
(
    input logic clk,
    input logic enable,
    input logic [15:0] data_in,
    input logic rstn,
    output logic [15:0] q_pos_out,
    output logic [15:0] q_neg_out,
    output logic [15:0] q_one_out,
    output logic [15:0] q_zero_out,
    output logic [15:0] async_rst_dff_out,
    output logic [15:0] sync_rst_dff_out,
    output logic [15:0] async_rst_tff_out,
    output logic [15:0] sync_rst_tff_out,
    output logic [15:0] async_rst_tff_out2,
    output logic [15:0] async_rst_tff_out3,
    input logic arstn,
    input logic sreset
);

//------------------------------------------------------------------------------
// Method process: positive_latch (test_ff_latch.cpp:67:5) 

always_latch 
begin : positive_latch     // test_ff_latch.cpp:67:5
    if (!rstn)
    begin
        q_pos_out = 0;
    end else begin
        if (enable)
        begin
            q_pos_out = data_in;
        end
    end
end

//------------------------------------------------------------------------------
// Method process: negative_latch (test_ff_latch.cpp:77:5) 

always_latch 
begin : negative_latch     // test_ff_latch.cpp:77:5
    if (!rstn)
    begin
        q_neg_out = 0;
    end else begin
        if (!enable)
        begin
            q_neg_out = data_in;
        end
    end
end

//------------------------------------------------------------------------------
// Method process: latch_one (test_ff_latch.cpp:87:5) 

always_latch 
begin : latch_one     // test_ff_latch.cpp:87:5
    if (!rstn)
    begin
        q_one_out = 0;
    end else begin
        if (enable)
        begin
            q_one_out = 'hFFFF;
        end
    end
end

//------------------------------------------------------------------------------
// Method process: latch_zero (test_ff_latch.cpp:97:5) 

always_latch 
begin : latch_zero     // test_ff_latch.cpp:97:5
    if (!rstn)
    begin
        q_zero_out = 'hFFFF;
    end else begin
        if (enable)
        begin
            q_zero_out = 0;
        end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: async_rst_dff (test_ff_latch.cpp:108:5) 

// Thread-local variables
logic [15:0] async_rst_dff_out_next;

// Next-state combinational logic
always_comb begin : async_rst_dff_comb     // test_ff_latch.cpp:108:5
    async_rst_dff_func;
end
function void async_rst_dff_func;
    async_rst_dff_out_next = async_rst_dff_out;
    async_rst_dff_out_next = data_in;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : async_rst_dff_ff
    if ( ~arstn ) begin
        async_rst_dff_out <= 0;
    end
    else begin
        async_rst_dff_out <= async_rst_dff_out_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sync_rst_dff (test_ff_latch.cpp:118:5) 

// Thread-local variables
logic [15:0] sync_rst_dff_out_next;

// Next-state combinational logic
always_comb begin : sync_rst_dff_comb     // test_ff_latch.cpp:118:5
    sync_rst_dff_func;
end
function void sync_rst_dff_func;
    sync_rst_dff_out_next = sync_rst_dff_out;
    sync_rst_dff_out_next = data_in;
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync sreset*/) 
begin : sync_rst_dff_ff
    if ( ~sreset ) begin
        sync_rst_dff_out <= 1;
    end
    else begin
        sync_rst_dff_out <= sync_rst_dff_out_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: async_rst_tff (test_ff_latch.cpp:128:5) 

// Thread-local variables
logic [15:0] async_rst_tff_out_next;
logic [15:0] async_rst_tff_out2_next;
logic [15:0] async_rst_tff_out3_next;
logic [15:0] b;
logic [15:0] b_next;

// Next-state combinational logic
always_comb begin : async_rst_tff_comb     // test_ff_latch.cpp:128:5
    async_rst_tff_func;
end
function void async_rst_tff_func;
    logic [15:0] a;
    async_rst_tff_out2_next = async_rst_tff_out2;
    async_rst_tff_out3_next = async_rst_tff_out3;
    async_rst_tff_out_next = async_rst_tff_out;
    b_next = b;
    a = async_rst_tff_out;
    async_rst_tff_out2_next = data_in ^ async_rst_tff_out2;
    for (integer i = 0; i < 16; i++)
    begin
        if (data_in[i])
        begin
            a[i] = !async_rst_tff_out[i];
        end
    end
    async_rst_tff_out_next = a;
    for (integer i_1 = 0; i_1 < 16; i_1++)
    begin
        if (data_in[i_1])
        begin
            b_next[i_1] = !async_rst_tff_out3[i_1];
        end
    end
    async_rst_tff_out3_next = b_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : async_rst_tff_ff
    if ( ~arstn ) begin
        b <= 0;
        async_rst_tff_out <= 0;
        async_rst_tff_out2 <= 0;
        async_rst_tff_out3 <= 0;
    end
    else begin
        async_rst_tff_out <= async_rst_tff_out_next;
        async_rst_tff_out2 <= async_rst_tff_out2_next;
        async_rst_tff_out3 <= async_rst_tff_out3_next;
        b <= b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sync_rst_tff (test_ff_latch.cpp:162:5) 

// Thread-local variables
logic [15:0] sync_rst_tff_out_next;

// Next-state combinational logic
always_comb begin : sync_rst_tff_comb     // test_ff_latch.cpp:162:5
    sync_rst_tff_func;
end
function void sync_rst_tff_func;
    logic [15:0] a;
    sync_rst_tff_out_next = sync_rst_tff_out;
    a = sync_rst_tff_out;
    for (integer i = 0; i < 16; i++)
    begin
        if (data_in[i])
        begin
            a[i] = !sync_rst_tff_out[i];
        end
    end
    sync_rst_tff_out_next = a;
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync sreset*/) 
begin : sync_rst_tff_ff
    if ( ~sreset ) begin
        logic [15:0] a;
        a = 0;
        sync_rst_tff_out <= 0;
    end
    else begin
        sync_rst_tff_out <= sync_rst_tff_out_next;
    end
end

endmodule


