//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "top_inst"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] t0;
logic signed [31:0] t1;

// Local parameters generated for C++ constants
localparam logic [3:0] mrec1_b = 4;
localparam logic [3:0] mrec2_b = 5;
localparam logic [15:0] B = 42;
localparam logic signed [64:0] BB = 64'hFFFFFFFFFFFFFFD5;
localparam logic [15:0] BBB = 43;
localparam logic [31:0] C = 1;
localparam logic signed [31:0] ARR[3] = '{ 1, 2, 3 };
localparam logic signed [7:0] ARRI[3] = '{ 4, -4'sd5, 6 };

//------------------------------------------------------------------------------
// Method process: const_cond_stmt (test_const_static_mem.cpp:55:5) 

always_comb 
begin : const_cond_stmt     // test_const_static_mem.cpp:55:5
    integer j;
    j = 4'd1;
    `ifndef INTEL_SVA_OFF
        assert (j == 1) else $error("Assertion failed at test_const_static_mem.cpp:52:24>");
    `endif // INTEL_SVA_OFF
    j = 4'd2;
    `ifndef INTEL_SVA_OFF
        assert (j == 2) else $error("Assertion failed at test_const_static_mem.cpp:52:24>");
    `endif // INTEL_SVA_OFF
end

//------------------------------------------------------------------------------
// Method process: const_method (test_const_static_mem.cpp:72:5) 

always_comb 
begin : const_method     // test_const_static_mem.cpp:72:5
    integer a;
    integer unsigned b;
    a = B;
    a = 32'(BB);
    `ifndef INTEL_SVA_OFF
        assert (a == -7'sd43) else $error("Assertion failed at test_const_static_mem.cpp:52:24>");
    `endif // INTEL_SVA_OFF
    a = BBB;
    `ifndef INTEL_SVA_OFF
        assert (a == 43) else $error("Assertion failed at test_const_static_mem.cpp:52:24>");
    `endif // INTEL_SVA_OFF
    a = ARR[1];
    `ifndef INTEL_SVA_OFF
        assert (a == 2) else $error("Assertion failed at test_const_static_mem.cpp:52:24>");
    `endif // INTEL_SVA_OFF
    a = ARRI[1];
    `ifndef INTEL_SVA_OFF
        assert (a == -4'sd5) else $error("Assertion failed at test_const_static_mem.cpp:52:24>");
    `endif // INTEL_SVA_OFF
    a = 1;    // Call of getvar()
    b = a + C;
    `ifndef INTEL_SVA_OFF
        assert (b == 2) else $error("Assertion failed at test_const_static_mem.cpp:52:24>");
    `endif // INTEL_SVA_OFF
end

//------------------------------------------------------------------------------
// Method process: const_record_method (test_const_static_mem.cpp:93:5) 

always_comb 
begin : const_record_method     // test_const_static_mem.cpp:93:5
    logic a;
    logic [3:0] b;
    logic rec_a;
    logic [3:0] rec_b;
    integer j;
    a = 1; b = 1;
    rec_a = a;
    rec_b = b;
    // Call Simple() begin
    // Call Simple() end
    j = rec_b + mrec1_b;
    `ifndef INTEL_SVA_OFF
        assert (j == 5) else $error("Assertion failed at test_const_static_mem.cpp:52:24>");
    `endif // INTEL_SVA_OFF
    j = rec_b;
    `ifndef INTEL_SVA_OFF
        assert (j == 1) else $error("Assertion failed at test_const_static_mem.cpp:52:24>");
    `endif // INTEL_SVA_OFF
    j = mrec1_b;
    `ifndef INTEL_SVA_OFF
        assert (j == 4) else $error("Assertion failed at test_const_static_mem.cpp:52:24>");
    `endif // INTEL_SVA_OFF
end

//------------------------------------------------------------------------------
// Method process: const_record_arr_method (test_const_static_mem.cpp:109:5) 

always_comb 
begin : const_record_arr_method     // test_const_static_mem.cpp:109:5
    logic a;
    logic [3:0] b;
    logic rec_a;
    logic [3:0] rec_b;
    logic arec_a[2];
    logic [3:0] arec_b[2];
    integer j;
    a = 0; b = 1;
    rec_a = a;
    rec_b = b;
    // Call Simple() begin
    // Call Simple() end
    j = rec_b + arec_b[0];
    t0 = j;
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_record_thread (test_const_static_mem.cpp:121:5) 

// Thread-local variables
logic signed [31:0] t1_next;

// Thread-local constants
logic [3:0] rec_b0;
logic [4:0] A;

// Next-state combinational logic
always_comb begin : const_record_thread_comb     // test_const_static_mem.cpp:121:5
    const_record_thread_func;
end
function void const_record_thread_func;
    logic [4:0] V;
    logic a;
    logic [3:0] b;
    logic rec_a;
    t1_next = t1;
    t1_next = rec_b0;
    t1_next = mrec2_b;
    t1_next = A;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : const_record_thread_ff
    if ( ~nrst ) begin
        logic [4:0] V;
        logic a;
        logic [3:0] b;
        logic rec_a;
        V = 42;
        A = V;
        a = 0; b = V;
        rec_a = a;
        rec_b0 = b;
        // Call Simple() begin
        // Call Simple() end
    end
    else begin
        t1 <= t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_record_thread2 (test_const_static_mem.cpp:137:5) 

// Thread-local constants
logic [3:0] rec_b1;

// Next-state combinational logic
always_comb begin : const_record_thread2_comb     // test_const_static_mem.cpp:137:5
    const_record_thread2_func;
end
function void const_record_thread2_func;
    logic a;
    logic [3:0] b;
    logic rec_a;
    integer j;
    j = rec_b1 + B;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : const_record_thread2_ff
    if ( ~nrst ) begin
        logic a;
        logic [3:0] b;
        logic rec_a;
        a = 1; b = 2;
        rec_a = a;
        rec_b1 = b;
        // Call Simple() begin
        // Call Simple() end
    end
    else begin
    end
end

endmodule


