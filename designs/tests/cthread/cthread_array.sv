//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.6
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
    input logic clk
);

// Variables generated for SystemC signals
logic arstn;
logic a;
logic ps;
logic arbt_req[1];
logic chans[3];
logic chans2d[3][3];
logic [1:0] fifo_source;
logic [1:0] master_resp_data_[3];
logic signed [31:0] t0;
logic pwrout_nenable;
logic pwrin_nenable;
logic renbl;
logic [1:0] addr;
logic [15:0] wdata;
logic pwrout_;
logic signed [31:0] t1;
logic signed [31:0] t2;

// Local parameters generated for C++ constants
localparam logic [31:0] DOMAIN_NUM = 1;
localparam logic [31:0] ECC_NUM = 0;

//------------------------------------------------------------------------------
// Clocked THREAD: bug_in_array_index2 (test_cthread_array.cpp:93:5) 

// Thread-local variables
logic [1:0] master_resp_data__next[3];

// Next-state combinational logic
always_comb begin : bug_in_array_index2_comb     // test_cthread_array.cpp:93:5
    bug_in_array_index2_func;
end
function void bug_in_array_index2_func;
    logic [1:0] reqSource;
    logic reqOper;
    master_resp_data__next = master_resp_data_;
    reqSource = fifo_source;
    reqOper = a;
    master_resp_data__next[reqSource] = {1'd0, 1'd0, 1'(ps), 5'd0, 1'(ps), 1'(ps), 1'(ps), 1'(ps), 1'(ps), 1'(ps), 1'(ps), 1'(ps), 1'(reqOper), 1'(reqOper)};
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : bug_in_array_index2_ff
    if ( ~arstn ) begin
    end
    else begin
        master_resp_data_ <= master_resp_data__next;
    end
end

//------------------------------------------------------------------------------
// Method process: array_of_pointers (test_cthread_array.cpp:133:5) 

always_comb 
begin : array_of_pointers     // test_cthread_array.cpp:133:5
    for (integer i = 0; i < DOMAIN_NUM; i++)
    begin
        arbt_req[i] = 0;
    end
end

//------------------------------------------------------------------------------
// Method process: chan_array_read (test_cthread_array.cpp:141:5) 

always_comb 
begin : chan_array_read     // test_cthread_array.cpp:141:5
    logic b;
    for (integer i = 0; i < DOMAIN_NUM; i++)
    begin
        b = chans[i];
        b = chans[i];
        b = !chans[i];
        for (integer j = 0; j < DOMAIN_NUM; j++)
        begin
            b = chans2d[i][j];
            b = !chans2d[i][j];
        end
        t0 = b;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: operProc (test_cthread_array.cpp:170:5) 

// Thread-local variables
logic [15:0] block_memory[4];
logic [15:0] block_memory_next[4];
logic pwrout_nenable_next;
logic pwrout__next;
logic signed [31:0] t1_next;

// Next-state combinational logic
always_comb begin : operProc_comb     // test_cthread_array.cpp:170:5
    operProc_func;
end
function void operProc_func;
    logic [15:0] readData;
    block_memory_next = block_memory;
    pwrout__next = pwrout_;
    pwrout_nenable_next = pwrout_nenable;
    t1_next = t1;
    pwrout_nenable_next = pwrout_;
    pwrout__next = pwrin_nenable;
    if (!pwrout_nenable)
    begin
        if (renbl)
        begin
            readData = block_memory_next[addr];
            t1_next = readData;
        end else begin
            block_memory_next[addr] = wdata;
        end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk) 
begin : operProc_ff
    begin
        block_memory <= block_memory_next;
        pwrout_nenable <= pwrout_nenable_next;
        pwrout_ <= pwrout__next;
        t1 <= t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: array_of_pointers2 (test_cthread_array.cpp:191:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic signed [31:0] m[3];
logic signed [31:0] m_next[3];
logic signed [31:0] n[3][3];
logic signed [31:0] n_next[3][3];
logic signed [31:0] t2_next;
logic array_of_pointers2_PROC_STATE;
logic array_of_pointers2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : array_of_pointers2_comb     // test_cthread_array.cpp:191:5
    array_of_pointers2_func;
end
function void array_of_pointers2_func;
    i_next = i0;
    m_next = m;
    n_next = n;
    t2_next = t2;
    array_of_pointers2_PROC_STATE_next = array_of_pointers2_PROC_STATE;
    
    case (array_of_pointers2_PROC_STATE)
        0: begin
            m_next[1] = m_next[0] + i_next;
            array_of_pointers2_PROC_STATE_next = 1; return;    // test_cthread_array.cpp:198:13;
        end
        1: begin
            n_next[0][1] = m_next[1];
            t2_next = n_next[1][i_next];
            m_next[1] = m_next[0] + i_next;
            array_of_pointers2_PROC_STATE_next = 1; return;    // test_cthread_array.cpp:198:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : array_of_pointers2_ff
    if ( ~arstn ) begin
        for (integer i = 0; i < 3; ++i)
        begin
            m[i] <= 0;
        end
        i0 <= m[0];
        array_of_pointers2_PROC_STATE <= 0;    // test_cthread_array.cpp:194:9;
    end
    else begin
        i0 <= i_next;
        m <= m_next;
        n <= n_next;
        t2 <= t2_next;
        array_of_pointers2_PROC_STATE <= array_of_pointers2_PROC_STATE_next;
    end
end

endmodule


