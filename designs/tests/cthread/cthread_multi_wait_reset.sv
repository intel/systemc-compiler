//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
    input logic clk
);

// Variables generated for SystemC signals
logic arstn;
logic [30:0] a;
logic [30:0] b;
logic signed [31:0] s0;
logic signed [31:0] s1;

//------------------------------------------------------------------------------
// Clocked THREAD: wait_in_reset1 (test_cthread_multi_wait_reset.cpp:33:5) 

// Thread-local variables
logic [30:0] a_next;
logic [30:0] b_next;
logic [2:0] wait_in_reset1_PROC_STATE;
logic [2:0] wait_in_reset1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_in_reset1_comb     // test_cthread_multi_wait_reset.cpp:33:5
    wait_in_reset1_func;
end
function void wait_in_reset1_func;
    a_next = a;
    b_next = b;
    wait_in_reset1_PROC_STATE_next = wait_in_reset1_PROC_STATE;
    
    case (wait_in_reset1_PROC_STATE)
        0: begin
            a_next = 1'd1;
            b_next = 1'd1;
            wait_in_reset1_PROC_STATE_next = 1; return;    // test_cthread_multi_wait_reset.cpp:40:9;
        end
        1: begin
            a_next = 2'd2;
            b_next = 2'd3;
            wait_in_reset1_PROC_STATE_next = 2; return;    // test_cthread_multi_wait_reset.cpp:43:9;
        end
        2: begin
            a_next = a + 1'd1;
            wait_in_reset1_PROC_STATE_next = 3; return;    // test_cthread_multi_wait_reset.cpp:48:13;
        end
        3: begin
            b_next = a + b;
            wait_in_reset1_PROC_STATE_next = 2; return;    // test_cthread_multi_wait_reset.cpp:50:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : wait_in_reset1_ff
    if ( ~arstn ) begin
        a <= '0;
        b <= '0;
        wait_in_reset1_PROC_STATE <= '0;    // test_cthread_multi_wait_reset.cpp:37:9;
    end
    else begin
        a <= a_next;
        b <= b_next;
        wait_in_reset1_PROC_STATE <= wait_in_reset1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_in_reset2 (test_cthread_multi_wait_reset.cpp:55:5) 

// Thread-local variables
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [3:0] x[3];
logic [3:0] x_next[3];
logic signed [31:0] s0_next;
logic [1:0] wait_in_reset2_PROC_STATE;
logic [1:0] wait_in_reset2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_in_reset2_comb     // test_cthread_multi_wait_reset.cpp:55:5
    wait_in_reset2_func;
end
function void wait_in_reset2_func;
    i_next = i;
    s0_next = s0;
    x_next = x;
    wait_in_reset2_PROC_STATE_next = wait_in_reset2_PROC_STATE;
    
    case (wait_in_reset2_PROC_STATE)
        0: begin
            x_next[1] = i_next++;
            wait_in_reset2_PROC_STATE_next = 1; return;    // test_cthread_multi_wait_reset.cpp:62:9;
        end
        1: begin
            x_next[2] = i_next++;
            wait_in_reset2_PROC_STATE_next = 2; return;    // test_cthread_multi_wait_reset.cpp:67:9;
        end
        2: begin
            s0_next = i_next++;
            wait_in_reset2_PROC_STATE_next = 2; return;    // test_cthread_multi_wait_reset.cpp:72:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : wait_in_reset2_ff
    if ( ~arstn ) begin
        i <= 1;
        x[0] <= 0; x[1] <= 0; x[2] <= 0;
        wait_in_reset2_PROC_STATE <= '0;    // test_cthread_multi_wait_reset.cpp:59:9;
    end
    else begin
        i <= i_next;
        x <= x_next;
        s0 <= s0_next;
        wait_in_reset2_PROC_STATE <= wait_in_reset2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_in_reset3 (test_cthread_multi_wait_reset.cpp:77:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic signed [31:0] k;
logic signed [31:0] k_next;
logic [3:0] x0[3];
logic [3:0] x_next0[3];
logic signed [31:0] s1_next;
logic [1:0] wait_in_reset3_PROC_STATE;
logic [1:0] wait_in_reset3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_in_reset3_comb     // test_cthread_multi_wait_reset.cpp:77:5
    wait_in_reset3_func;
end
function void wait_in_reset3_func;
    i_next0 = i0;
    k_next = k;
    s1_next = s1;
    x_next0 = x0;
    wait_in_reset3_PROC_STATE_next = wait_in_reset3_PROC_STATE;
    
    case (wait_in_reset3_PROC_STATE)
        0: begin
            ++i_next0;
            if (i_next0 < 3)
            begin
                x_next0[i_next0] = i_next0;
                wait_in_reset3_PROC_STATE_next = '0; return;    // test_cthread_multi_wait_reset.cpp:83:13;
            end
            k_next = '0;
            wait_in_reset3_PROC_STATE_next = 1; return;    // test_cthread_multi_wait_reset.cpp:86:9;
        end
        1: begin
            s1_next = x_next0[k_next];
            k_next = (k_next == 2) ? 0 : k_next + 2'sd1;
            wait_in_reset3_PROC_STATE_next = 1; return;    // test_cthread_multi_wait_reset.cpp:92:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : wait_in_reset3_ff
    if ( ~arstn ) begin
        x0[0] <= 0; x0[1] <= 0; x0[2] <= 0;
        i0 <= '0;
        x0[i0] <= i0;
        wait_in_reset3_PROC_STATE <= '0;    // test_cthread_multi_wait_reset.cpp:83:13;
    end
    else begin
        i0 <= i_next0;
        k <= k_next;
        x0 <= x_next0;
        s1 <= s1_next;
        wait_in_reset3_PROC_STATE <= wait_in_reset3_PROC_STATE_next;
    end
end

endmodule


