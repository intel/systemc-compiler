//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.14
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
    input logic clk
);

// Variables generated for SystemC signals
logic arstn;
logic a;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t1a;
logic [2:0] s1;
logic signed [31:0] t2;
logic s2[3];
logic signed [31:0] t3;
logic signed [31:0] t4;
logic [2:0] s3;
logic signed [31:0] t5;
logic signed [31:0] s10;
logic signed [31:0] s10a;
logic [2:0] s4;
logic [2:0] s5;
logic signed [31:0] s7;
logic signed [31:0] t6;
logic signed [31:0] t7;
logic signed [31:0] t8;
logic signed [31:0] t9;
logic signed [31:0] t10;
logic signed [31:0] t11;
logic arr2[3];

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_test (test_cthread_reset.cpp:97:5) 

// Thread-local variables
logic c;
logic c_next;

// Next-state combinational logic
always_comb begin : sct_assert_test_comb     // test_cthread_reset.cpp:97:5
    sct_assert_test_func;
end
function void sct_assert_test_func;
    c_next = c;
endfunction

// Synchronous register update
always_ff @(negedge clk or negedge arstn) 
begin : sct_assert_test_ff
    if ( ~arstn ) begin
        c <= 0;
        t0 <= c;

    `ifndef INTEL_SVA_OFF
        sctAssertLine100r : assert property ( a |=> c_next );
    `endif // INTEL_SVA_OFF
    end
    else begin
        c <= c_next;

    `ifndef INTEL_SVA_OFF
        sctAssertLine100 : assert property ( a |=> c_next );
    `endif // INTEL_SVA_OFF
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: var_in_reset_only1 (test_cthread_reset.cpp:111:5) 

// Thread-local variables
logic signed [31:0] t1_next;
logic var_in_reset_only1_PROC_STATE;
logic var_in_reset_only1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : var_in_reset_only1_comb     // test_cthread_reset.cpp:111:5
    var_in_reset_only1_func;
end
function void var_in_reset_only1_func;
    logic [15:0] C;
    integer kk;
    t1_next = t1;
    var_in_reset_only1_PROC_STATE_next = var_in_reset_only1_PROC_STATE;
    
    case (var_in_reset_only1_PROC_STATE)
        0: begin
            var_in_reset_only1_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:122:13;
        end
        1: begin
            if (a)
            begin
                kk = 1;
                t1_next = kk;
            end
            var_in_reset_only1_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:122:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : var_in_reset_only1_ff
    if ( ~arstn ) begin
        integer ii;
        logic signed [7:0] jj;
        logic [15:0] C;
        jj = 1;
        C = 42;
        ii = jj + C;
        t1 <= ii;
        var_in_reset_only1_PROC_STATE <= 0;    // test_cthread_reset.cpp:119:9;
    end
    else begin
        t1 <= t1_next;
        var_in_reset_only1_PROC_STATE <= var_in_reset_only1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: common_wait1 (test_cthread_reset.cpp:135:5) 

// Thread-local variables
logic signed [31:0] t1a_next;

// Next-state combinational logic
always_comb begin : common_wait1_comb     // test_cthread_reset.cpp:135:5
    common_wait1_func;
end
function void common_wait1_func;
    integer kk;
    t1a_next = t1a;
    if (a)
    begin
        kk = 1;
        t1a_next = kk;
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : common_wait1_ff
    if ( ~arstn ) begin
    end
    else begin
        t1a <= t1a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: common_wait2 (test_cthread_reset.cpp:149:5) 

// Thread-local variables
logic [2:0] y;
logic [2:0] y_next;
logic [2:0] s1_next;
logic signed [31:0] t2_next;

// Next-state combinational logic
always_comb begin : common_wait2_comb     // test_cthread_reset.cpp:149:5
    common_wait2_func;
end
function void common_wait2_func;
    s1_next = s1;
    t2_next = t2;
    y_next = y;
    if (a)
    begin
        s1_next = 1;
        y_next++;
    end
    t2_next = y_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : common_wait2_ff
    if ( ~arstn ) begin
        y <= 0;
        s1 <= 0;
    end
    else begin
        y <= y_next;
        s1 <= s1_next;
        t2 <= t2_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: common_wait3 (test_cthread_reset.cpp:168:5) 

// Thread-local variables
logic [2:0] y0;
logic [2:0] y_next0;
logic s2_next[3];
logic signed [31:0] t3_next;
logic common_wait3_PROC_STATE;
logic common_wait3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : common_wait3_comb     // test_cthread_reset.cpp:168:5
    common_wait3_func;
end
function void common_wait3_func;
    s2_next = s2;
    t3_next = t3;
    y_next0 = y0;
    common_wait3_PROC_STATE_next = common_wait3_PROC_STATE;
    
    case (common_wait3_PROC_STATE)
        0: begin
            if (a)
            begin
                s2_next[s1] = 1;
                y_next0++;
                common_wait3_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:183:17;
            end
            t3_next = y_next0;
            common_wait3_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:178:13;
        end
        1: begin
            t3_next = y_next0;
            common_wait3_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:178:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : common_wait3_ff
    if ( ~arstn ) begin
        y0 <= 0;
        for (integer i = 0; i < 3; i++)
        begin
            s2[i] <= 0;
        end
        t3 <= s2[0];
        common_wait3_PROC_STATE <= 0;    // test_cthread_reset.cpp:178:13;
    end
    else begin
        y0 <= y_next0;
        s2 <= s2_next;
        t3 <= t3_next;
        common_wait3_PROC_STATE <= common_wait3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: common_wait4 (test_cthread_reset.cpp:190:5) 

// Thread-local variables
logic [2:0] x;
logic [2:0] x_next;
logic signed [31:0] t4_next;
logic [1:0] common_wait4_PROC_STATE;
logic [1:0] common_wait4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : common_wait4_comb     // test_cthread_reset.cpp:190:5
    common_wait4_func;
end
function void common_wait4_func;
    t4_next = t4;
    x_next = x;
    common_wait4_PROC_STATE_next = common_wait4_PROC_STATE;
    
    case (common_wait4_PROC_STATE)
        0: begin
            x_next = s2[x_next];
            if (!(|s1))
            begin
                common_wait4_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:201:32;
            end
            x_next++;
            t4_next = x_next;
            common_wait4_PROC_STATE_next = 2; return;    // test_cthread_reset.cpp:205:13;
        end
        1: begin
            if (!(|s1))
            begin
                common_wait4_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:201:32;
            end
            x_next++;
            t4_next = x_next;
            common_wait4_PROC_STATE_next = 2; return;    // test_cthread_reset.cpp:205:13;
        end
        2: begin
            common_wait4_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:197:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : common_wait4_ff
    if ( ~arstn ) begin
        x <= 0;
        x <= 1;
        common_wait4_PROC_STATE <= 0;    // test_cthread_reset.cpp:197:13;
    end
    else begin
        x <= x_next;
        t4 <= t4_next;
        common_wait4_PROC_STATE <= common_wait4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: common_wait5 (test_cthread_reset.cpp:211:5) 

// Thread-local variables
logic [2:0] s3_next;
logic common_wait5_PROC_STATE;
logic common_wait5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : common_wait5_comb     // test_cthread_reset.cpp:211:5
    common_wait5_func;
end
function void common_wait5_func;
    s3_next = s3;
    common_wait5_PROC_STATE_next = common_wait5_PROC_STATE;
    
    case (common_wait5_PROC_STATE)
        0: begin
            if (!(|s1))
            begin
                common_wait5_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:217:32;
            end
            s3_next = 1;
            common_wait5_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:216:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : common_wait5_ff
    if ( ~arstn ) begin
        s3 <= 0;
        common_wait5_PROC_STATE <= 0;    // test_cthread_reset.cpp:216:13;
    end
    else begin
        s3 <= s3_next;
        common_wait5_PROC_STATE <= common_wait5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset1 (test_cthread_reset.cpp:235:5) 

// Thread-local variables
logic signed [31:0] t5_next;

// Next-state combinational logic
always_comb begin : no_reset1_comb     // test_cthread_reset.cpp:235:5
    no_reset1_func;
end
function void no_reset1_func;
    integer jj;
    integer kk;
    t5_next = t5;
    jj = 42;
    kk = 43;
    t5_next = kk;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : no_reset1_ff
    if ( ~arstn ) begin
        integer jj;
        integer kk;
        jj = 42;
        kk = 43;
        t5 <= kk;
    end
    else begin
        t5 <= t5_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset10 (test_cthread_reset.cpp:235:5) 

// Thread-local variables
logic signed [31:0] t5_next0;

// Next-state combinational logic
always_comb begin : no_reset10_comb     // test_cthread_reset.cpp:235:5
    no_reset10_func;
end
function void no_reset10_func;
    integer jj;
    integer kk;
    t5_next0 = t5;
    jj = 42;
    kk = 43;
    t5_next0 = kk;
endfunction

// Synchronous register update
always_ff @(posedge clk) 
begin : no_reset10_ff
    begin
        t5 <= t5_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset2 (test_cthread_reset.cpp:249:5) 

// Thread-local variables
logic signed [31:0] ll;
logic signed [31:0] ll_next;
logic signed [31:0] s10_next;

// Next-state combinational logic
always_comb begin : no_reset2_comb     // test_cthread_reset.cpp:249:5
    no_reset2_func;
end
function void no_reset2_func;
    ll_next = ll;
    s10_next = s10;
    s10_next = ll_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : no_reset2_ff
    if ( ~arstn ) begin
        ll <= 0;
        s10 <= ll;
    end
    else begin
        ll <= ll_next;
        s10 <= s10_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset3 (test_cthread_reset.cpp:260:5) 

// Thread-local variables
logic [2:0] v;
logic [2:0] v_next;
logic signed [31:0] s10a_next;
logic no_reset3_PROC_STATE;
logic no_reset3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : no_reset3_comb     // test_cthread_reset.cpp:260:5
    no_reset3_func;
end
function void no_reset3_func;
    s10a_next = s10a;
    v_next = v;
    no_reset3_PROC_STATE_next = no_reset3_PROC_STATE;
    
    case (no_reset3_PROC_STATE)
        0: begin
            v_next = v_next + s3;
            s10a_next = v_next;
            no_reset3_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:268:13;
        end
        1: begin
            v_next = 0;
            no_reset3_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:264:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : no_reset3_ff
    if ( ~arstn ) begin
        v <= 0;
        no_reset3_PROC_STATE <= 0;    // test_cthread_reset.cpp:264:13;
    end
    else begin
        v <= v_next;
        s10a <= s10a_next;
        no_reset3_PROC_STATE <= no_reset3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset4 (test_cthread_reset.cpp:277:5) 

// Thread-local variables
logic [2:0] s4_next;
logic no_reset4_PROC_STATE;
logic no_reset4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : no_reset4_comb     // test_cthread_reset.cpp:277:5
    no_reset4_func;
end
function void no_reset4_func;
    integer TMP_0;
    integer val;
    integer w;
    logic [2:0] z;
    s4_next = s4;
    no_reset4_PROC_STATE_next = no_reset4_PROC_STATE;
    
    case (no_reset4_PROC_STATE)
        0: begin
            val = s3;
            // Call g() begin
            TMP_0 = val + 1;
            // Call g() end
            w = TMP_0;
            z = w + 1;
            s4_next = z;
            no_reset4_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:286:13;
        end
        1: begin
            s4_next = 0;
            no_reset4_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:281:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : no_reset4_ff
    if ( ~arstn ) begin
        s4 <= 0;
        no_reset4_PROC_STATE <= 0;    // test_cthread_reset.cpp:281:13;
    end
    else begin
        s4 <= s4_next;
        no_reset4_PROC_STATE <= no_reset4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset5 (test_cthread_reset.cpp:291:5) 

// Thread-local variables
logic [2:0] z0;
logic [2:0] z_next;
logic [2:0] s5_next;
logic no_reset5_PROC_STATE;
logic no_reset5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : no_reset5_comb     // test_cthread_reset.cpp:291:5
    no_reset5_func;
end
function void no_reset5_func;
    s5_next = s5;
    z_next = z0;
    no_reset5_PROC_STATE_next = no_reset5_PROC_STATE;
    
    case (no_reset5_PROC_STATE)
        0: begin
            s5_next = s1 + 1;
            z_next = s3;
            if (!(|s1))
            begin
                no_reset5_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:298:32;
            end
            s5_next = z_next;
            no_reset5_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:294:13;
        end
        1: begin
            if (!(|s1))
            begin
                no_reset5_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:298:32;
            end
            s5_next = z_next;
            no_reset5_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:294:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : no_reset5_ff
    if ( ~arstn ) begin
        no_reset5_PROC_STATE <= 0;    // test_cthread_reset.cpp:294:13;
    end
    else begin
        z0 <= z_next;
        s5 <= s5_next;
        no_reset5_PROC_STATE <= no_reset5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: var_fcall_in_reset_only (test_cthread_reset.cpp:319:5) 

// Next-state combinational logic
always_comb begin : var_fcall_in_reset_only_comb     // test_cthread_reset.cpp:319:5
    var_fcall_in_reset_only_func;
end
function void var_fcall_in_reset_only_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : var_fcall_in_reset_only_ff
    if ( ~arstn ) begin
        integer i;
        integer l;
        i = 0;    // Call of f()
        // Call f1() begin
        l = i + 1;
        i = l;
        // Call f1() end
        s7 <= i;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: comb_init_in_reset (test_cthread_reset.cpp:336:5) 

// Thread-local variables
logic signed [31:0] t6_next;

// Next-state combinational logic
always_comb begin : comb_init_in_reset_comb     // test_cthread_reset.cpp:336:5
    comb_init_in_reset_func;
end
function void comb_init_in_reset_func;
    integer k;
    t6_next = t6;
    k = 1;
    t6_next = k;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : comb_init_in_reset_ff
    if ( ~arstn ) begin
        integer k;
        k = 1;
        a <= |k;
        t6 <= a;
    end
    else begin
        t6 <= t6_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: not_used (test_cthread_reset.cpp:357:5) 

// Thread-local variables
logic [3:0] kk0;
logic [3:0] kk_next;
logic signed [31:0] t7_next;

// Next-state combinational logic
always_comb begin : not_used_comb     // test_cthread_reset.cpp:357:5
    not_used_func;
end
function void not_used_func;
    kk_next = kk0;
    t7_next = t7;
    t7_next = kk_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : not_used_ff
    if ( ~arstn ) begin
        kk0 <= 0;
    end
    else begin
        kk0 <= kk_next;
        t7 <= t7_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: comb_assign_in_reset (test_cthread_reset.cpp:370:5) 

// Next-state combinational logic
always_comb begin : comb_assign_in_reset_comb     // test_cthread_reset.cpp:370:5
    comb_assign_in_reset_func;
end
function void comb_assign_in_reset_func;
    integer k;
    integer l;
    logic [1:0] x_1;
    k = 1;
    l = 1;
    x_1 = 1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : comb_assign_in_reset_ff
    if ( ~arstn ) begin
        integer k;
        integer l;
        logic [1:0] x_1;
        k = 2;
        a <= |k;
        l = 0;
        l = l - 1;
        x_1 = 0;
        x_1 = x_1 + 1;
        t8 <= x_1 + l;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: reg_init_in_reset (test_cthread_reset.cpp:396:5) 

// Thread-local variables
logic a_next1;
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic signed [31:0] j;
logic signed [31:0] j_next;
logic signed [31:0] k0;
logic signed [31:0] k_next;

// Next-state combinational logic
always_comb begin : reg_init_in_reset_comb     // test_cthread_reset.cpp:396:5
    reg_init_in_reset_func;
end
function void reg_init_in_reset_func;
    a_next1 = a;
    i_next = i0;
    j_next = j;
    k_next = k0;
    a_next1 = |i_next;
    a_next1 = |j_next;
    a_next1 = |k_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : reg_init_in_reset_ff
    if ( ~arstn ) begin
        j <= 1;
        k0 <= 2;
        a <= |k0;
    end
    else begin
        a <= a_next1;
        i0 <= i_next;
        j <= j_next;
        k0 <= k_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: reg_assign_in_reset (test_cthread_reset.cpp:416:5) 

// Thread-local variables
logic a_next2;
logic signed [31:0] i1;
logic signed [31:0] i_next0;
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic signed [31:0] k1;
logic signed [31:0] k_next0;
logic signed [31:0] l0;
logic signed [31:0] l_next;
logic [1:0] x0;
logic [1:0] x_next0;
logic signed [31:0] arr0[3];
logic signed [31:0] arr0_next[3];

// Next-state combinational logic
always_comb begin : reg_assign_in_reset_comb     // test_cthread_reset.cpp:416:5
    reg_assign_in_reset_func;
end
function void reg_assign_in_reset_func;
    a_next2 = a;
    arr0_next = arr0;
    i_next0 = i1;
    j_next0 = j0;
    k_next0 = k1;
    l_next = l0;
    x_next0 = x0;
    a_next2 = |i_next0;
    a_next2 = |j_next0;
    a_next2 = |k_next0;
    a_next2 = |l_next;
    a_next2 = |x_next0;
    a_next2 = |arr0_next[1];
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : reg_assign_in_reset_ff
    if ( ~arstn ) begin
        j0 <= 1;
        k1 <= 2;
        a <= |k1;
        l0 <= 0;
        x0 <= 0;
        x0 <= 1;
        arr0[1] <= 0;
        arr0[2] <= 1;
        t9 <= arr0[2] + x0;
    end
    else begin
        a <= a_next2;
        i1 <= i_next0;
        j0 <= j_next0;
        k1 <= k_next0;
        l0 <= l_next;
        x0 <= x_next0;
        arr0 <= arr0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: read_only_in_reset (test_cthread_reset.cpp:446:5) 

// Thread-local variables
logic signed [31:0] aa;

// Next-state combinational logic
always_comb begin : read_only_in_reset_comb     // test_cthread_reset.cpp:446:5
    read_only_in_reset_func;
end
function void read_only_in_reset_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : read_only_in_reset_ff
    if ( ~arstn ) begin
        integer jj;
        integer aaa;
        integer aa;
        aa = 1;
        jj = 0;
        aaa = jj + aa;
        t10 <= aaa;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: write_only_in_reset (test_cthread_reset.cpp:462:5) 

// Next-state combinational logic
always_comb begin : write_only_in_reset_comb     // test_cthread_reset.cpp:462:5
    write_only_in_reset_func;
end
function void write_only_in_reset_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : write_only_in_reset_ff
    if ( ~arstn ) begin
        t11 <= 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: array_init_in_reset (test_cthread_reset.cpp:482:5) 

// Thread-local variables
logic arr2_next[3];
logic signed [31:0] arr4[2];
logic signed [31:0] arr4_next[2];
logic a_next3;
logic signed [1:0] arr1[3];

// Next-state combinational logic
always_comb begin : array_init_in_reset_comb     // test_cthread_reset.cpp:482:5
    array_init_in_reset_func;
end
function void array_init_in_reset_func;
    a_next3 = a;
    arr2_next = arr2;
    arr4_next = arr4;
    arr1[0] = 1;
    arr1[s7] = 2;
    a_next3 = |arr1[0];
    a_next3 = |(arr2[1] + arr4_next[s7]);
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : array_init_in_reset_ff
    if ( ~arstn ) begin
        integer arr3[2];
        logic signed [1:0] arr1[3];
        arr1[0] = 1;
        arr2[1] <= 1;
        arr3[0] = 1; arr3[1] = 2;
        for (integer i = 0; i < 2; ++i)
        begin
            arr4[i] <= arr3[i];
        end
    end
    else begin
        arr2 <= arr2_next;
        arr4 <= arr4_next;
        a <= a_next3;
    end
end

endmodule


