//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.16
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
);

// Variables generated for SystemC signals
logic clk;
logic arstn;
logic signed [31:0] in;
logic signed [31:0] out;
logic signed [31:0] out1;
logic signed [31:0] out2;
logic signed [31:0] out3;

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs1 (test_cthread_concat.cpp:78:5) 

// Thread-local variables
logic signed [31:0] out_next;
logic [2:0] x;
logic [2:0] x_next;
logic [2:0] a;
logic [2:0] a_next;

// Next-state combinational logic
always_comb begin : concat_lhs1_comb     // test_cthread_concat.cpp:78:5
    concat_lhs1_func;
end
function void concat_lhs1_func;
    a_next = a;
    out_next = out;
    x_next = x;
    {x_next, a_next} = 42;
    out_next = x_next + a_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs1_ff
    if ( ~arstn ) begin
        out <= 0;
        x <= 0;
        a <= 3;
    end
    else begin
        out <= out_next;
        x <= x_next;
        a <= a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs1a (test_cthread_concat.cpp:93:5) 

// Thread-local variables
logic signed [31:0] out1_next;
logic [2:0] x0;
logic [2:0] x_next0;
logic [1:0] y;
logic [1:0] y_next;

// Next-state combinational logic
always_comb begin : concat_lhs1a_comb     // test_cthread_concat.cpp:93:5
    concat_lhs1a_func;
end
function void concat_lhs1a_func;
    out1_next = out1;
    x_next0 = x0;
    y_next = y;
    {x_next0, y_next} = 42;
    x_next0 = y_next + 1;
    out1_next = x_next0 + y_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs1a_ff
    if ( ~arstn ) begin
        out1 <= 0;
        x0 <= 0;
        y <= 0;
    end
    else begin
        out1 <= out1_next;
        x0 <= x_next0;
        y <= y_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs2 (test_cthread_concat.cpp:109:5) 

// Thread-local variables
logic signed [31:0] out2_next;
logic [3:0] b;
logic [3:0] b_next;
logic [2:0] x1;
logic [2:0] x_next1;
logic [3:0] l;
logic [3:0] l_next;

// Next-state combinational logic
always_comb begin : concat_lhs2_comb     // test_cthread_concat.cpp:109:5
    concat_lhs2_func;
end
function void concat_lhs2_func;
    b_next = b;
    l_next = l;
    out2_next = out2;
    x_next1 = x1;
    {b_next, x_next1} = l_next;
    out2_next = b_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs2_ff
    if ( ~arstn ) begin
        out2 <= 0;
        x1 <= 0;
        l <= 0;
        {x1, l} = 42;
    end
    else begin
        out2 <= out2_next;
        b <= b_next;
        x1 <= x_next1;
        l <= l_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs3 (test_cthread_concat.cpp:125:5) 

// Thread-local variables
logic [2:0] x2;
logic [2:0] x_next2;
logic [4:0] c;

// Next-state combinational logic
always_comb begin : concat_lhs3_comb     // test_cthread_concat.cpp:125:5
    concat_lhs3_func;
end
function void concat_lhs3_func;
    x_next2 = x2;
    c = 3;
    {x_next2, c} = 1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs3_ff
    if ( ~arstn ) begin
        logic [4:0] c;
        c = 0;
        x2 <= 0;
    end
    else begin
        x2 <= x_next2;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs4 (test_cthread_concat.cpp:139:5) 

// Thread-local variables
logic [5:0] d;
logic [5:0] d_next;

// Next-state combinational logic
always_comb begin : concat_lhs4_comb     // test_cthread_concat.cpp:139:5
    concat_lhs4_func;
end
function void concat_lhs4_func;
    logic [2:0] x_1;
    d_next = d;
    x_1 = 1;
    {d_next, x_1} = in;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs4_ff
    if ( ~arstn ) begin
        logic [2:0] x_1;
        x_1 = 0;
    end
    else begin
        d <= d_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs_rhs (test_cthread_concat.cpp:152:5) 

// Thread-local variables
logic [2:0] x3;
logic [2:0] x_next3;

// Next-state combinational logic
always_comb begin : concat_lhs_rhs_comb     // test_cthread_concat.cpp:152:5
    concat_lhs_rhs_func;
end
function void concat_lhs_rhs_func;
    logic [2:0] y_1;
    x_next3 = x3;
    y_1 = 0;
    {x_next3, y_1} = {x_next3, y_1};
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs_rhs_ff
    if ( ~arstn ) begin
        x3 <= 4;
    end
    else begin
        x3 <= x_next3;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs_rhs2 (test_cthread_concat.cpp:164:5) 

// Thread-local variables
logic [3:0] x4;
logic [3:0] x_next4;
logic [2:0] y0;
logic [2:0] y_next0;

// Next-state combinational logic
always_comb begin : concat_lhs_rhs2_comb     // test_cthread_concat.cpp:164:5
    concat_lhs_rhs2_func;
end
function void concat_lhs_rhs2_func;
    x_next4 = x4;
    y_next0 = y0;
    {x_next4, y_next0} = y_next0;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs_rhs2_ff
    if ( ~arstn ) begin
        x4 <= 4;
        y0 <= 5;
    end
    else begin
        x4 <= x_next4;
        y0 <= y_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs_rhs3 (test_cthread_concat.cpp:176:5) 

// Thread-local variables
logic [2:0] x5;
logic [2:0] x_next5;
logic [2:0] y1;
logic [2:0] y_next1;
logic concat_lhs_rhs3_PROC_STATE;
logic concat_lhs_rhs3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : concat_lhs_rhs3_comb     // test_cthread_concat.cpp:176:5
    concat_lhs_rhs3_func;
end
function void concat_lhs_rhs3_func;
    logic [5:0] z;
    x_next5 = x5;
    y_next1 = y1;
    concat_lhs_rhs3_PROC_STATE_next = concat_lhs_rhs3_PROC_STATE;
    
    case (concat_lhs_rhs3_PROC_STATE)
        0: begin
            y_next1 = 0;
            z = 0;
            z = {x_next5, 3'd0};
            concat_lhs_rhs3_PROC_STATE_next = 1; return;    // test_cthread_concat.cpp:185:13;
        end
        1: begin
            {x_next5, y_next1} = {x_next5, y_next1};
            y_next1 = 0;
            z = 0;
            z = {x_next5, 3'd0};
            concat_lhs_rhs3_PROC_STATE_next = 1; return;    // test_cthread_concat.cpp:185:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs_rhs3_ff
    if ( ~arstn ) begin
        x5 <= 0;
        concat_lhs_rhs3_PROC_STATE <= 0;    // test_cthread_concat.cpp:179:9;
    end
    else begin
        x5 <= x_next5;
        y1 <= y_next1;
        concat_lhs_rhs3_PROC_STATE <= concat_lhs_rhs3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs_multi (test_cthread_concat.cpp:191:5) 

// Thread-local variables
logic [2:0] xx;
logic [2:0] xx_next;
logic [2:0] zz;
logic [2:0] zz_next;
logic [3:0] tt;
logic [3:0] tt_next;
logic concat_lhs_multi_PROC_STATE;
logic concat_lhs_multi_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : concat_lhs_multi_comb     // test_cthread_concat.cpp:191:5
    concat_lhs_multi_func;
end
function void concat_lhs_multi_func;
    logic [3:0] yy;
    tt_next = tt;
    xx_next = xx;
    zz_next = zz;
    concat_lhs_multi_PROC_STATE_next = concat_lhs_multi_PROC_STATE;
    
    case (concat_lhs_multi_PROC_STATE)
        0: begin
            yy = 0;
            tt_next = 0;
            {zz_next, tt_next} = 42; {xx_next, yy} = {zz_next, tt_next};
            concat_lhs_multi_PROC_STATE_next = 1; return;    // test_cthread_concat.cpp:201:13;
        end
        1: begin
            yy = tt_next;
            yy = 0;
            tt_next = 0;
            {zz_next, tt_next} = 42; {xx_next, yy} = {zz_next, tt_next};
            concat_lhs_multi_PROC_STATE_next = 1; return;    // test_cthread_concat.cpp:201:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs_multi_ff
    if ( ~arstn ) begin
        xx <= 0;
        zz <= 0;
        concat_lhs_multi_PROC_STATE <= 0;    // test_cthread_concat.cpp:195:9;
    end
    else begin
        xx <= xx_next;
        zz <= zz_next;
        tt <= tt_next;
        concat_lhs_multi_PROC_STATE <= concat_lhs_multi_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs_range (test_cthread_concat.cpp:207:5) 

// Thread-local variables
logic [2:0] r1;
logic [2:0] r1_next;
logic [2:0] r2;
logic [2:0] r2_next;
logic signed [31:0] out3_next;

// Next-state combinational logic
always_comb begin : concat_lhs_range_comb     // test_cthread_concat.cpp:207:5
    concat_lhs_range_func;
end
function void concat_lhs_range_func;
    logic [2:0] r3;
    out3_next = out3;
    r1_next = r1;
    r2_next = r2;
    r3 = 0;
    {r1_next[1 : 0], r3} = 42;
    {r3, r2_next[1]} = 12;
    out3_next = r1_next + r2_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs_range_ff
    if ( ~arstn ) begin
        r1 <= 0;
        r2 <= 3;
    end
    else begin
        r1 <= r1_next;
        r2 <= r2_next;
        out3 <= out3_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: concat_lhs_cast (test_cthread_concat.cpp:222:5) 

// Thread-local variables
logic [2:0] t1;
logic [2:0] t1_next;
logic [2:0] t2;
logic [2:0] t2_next;
logic [2:0] t3;
logic [2:0] t3_next;
logic [2:0] t4;
logic [2:0] t4_next;

// Next-state combinational logic
always_comb begin : concat_lhs_cast_comb     // test_cthread_concat.cpp:222:5
    concat_lhs_cast_func;
end
function void concat_lhs_cast_func;
    t1_next = t1;
    t2_next = t2;
    t3_next = t3;
    t4_next = t4;
    {t1_next, t2_next} = 32'({t1_next, t2_next});
    {t3_next, t4_next} = 5'({t3_next, t4_next});
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : concat_lhs_cast_ff
    if ( ~arstn ) begin
        t1 <= 0;
        t2 <= 3;
        t3 <= 2;
        t4 <= 0;
    end
    else begin
        t1 <= t1_next;
        t2 <= t2_next;
        t3 <= t3_next;
        t4 <= t4_next;
    end
end

endmodule


