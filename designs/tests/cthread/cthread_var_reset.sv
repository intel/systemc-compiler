//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.25
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk,
    input logic rst,
    input logic signed [31:0] in,
    output logic signed [31:0] out
);

// Variables generated for SystemC signals
logic signed [31:0] a;
logic signed [31:0] s1;
logic signed [31:0] s2;
logic signed [31:0] r1;
logic r2_a;
logic signed [31:0] r2_b;

//------------------------------------------------------------------------------
// Clocked THREAD: local_var1 (test_cthread_var_reset.cpp:51:5) 

// Thread-local variables
logic signed [31:0] v;
logic signed [31:0] v_next;
logic signed [31:0] w;
logic signed [31:0] w_next;
logic signed [31:0] wa[2];
logic signed [31:0] wa_next[2];
logic signed [31:0] va[2];
logic signed [31:0] va_next[2];
logic signed [31:0] s1_next;
logic local_var1_PROC_STATE;
logic local_var1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : local_var1_comb     // test_cthread_var_reset.cpp:51:5
    local_var1_func;
end
function void local_var1_func;
    s1_next = s1;
    v_next = v;
    va_next = va;
    w_next = w;
    wa_next = wa;
    local_var1_PROC_STATE_next = local_var1_PROC_STATE;
    
    case (local_var1_PROC_STATE)
        0: begin
            v_next = 2;
            va_next[0] = 1; va_next[1] = 2;
            local_var1_PROC_STATE_next = 1; return;    // test_cthread_var_reset.cpp:60:13;
        end
        1: begin
            s1_next = w_next + v_next + wa_next[a] + va_next[a];
            v_next = 2;
            va_next[0] = 1; va_next[1] = 2;
            local_var1_PROC_STATE_next = 1; return;    // test_cthread_var_reset.cpp:60:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : local_var1_ff
    if ( rst ) begin
        w <= '0;
        wa[0] <= 0; wa[1] <= 0;
        local_var1_PROC_STATE <= '0;    // test_cthread_var_reset.cpp:55:9;
        v <= '0;
        va[0] <= 0; va[1] <= 0;
    end
    else begin
        v <= v_next;
        w <= w_next;
        wa <= wa_next;
        va <= va_next;
        s1 <= s1_next;
        local_var1_PROC_STATE <= local_var1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: local_var2 (test_cthread_var_reset.cpp:76:5) 

// Thread-local variables
logic signed [31:0] par;
logic signed [31:0] par_next;
logic signed [31:0] w0;
logic signed [31:0] w_next0;
logic signed [31:0] par0;
logic signed [31:0] par_next0;
logic signed [31:0] s2_next;
logic [1:0] local_var2_PROC_STATE;
logic [1:0] local_var2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : local_var2_comb     // test_cthread_var_reset.cpp:76:5
    local_var2_func;
end
function void local_var2_func;
    integer v_1;
    integer TMP_0;
    integer TMP_1;
    par_next = par;
    par_next0 = par0;
    s2_next = s2;
    w_next0 = w0;
    local_var2_PROC_STATE_next = local_var2_PROC_STATE;
    
    case (local_var2_PROC_STATE)
        0: begin
            v_1 = a;
            par_next = v_1;
            // Call f1() begin
            if (|a)
            begin
                par_next = par_next + 2'sd1;
                local_var2_PROC_STATE_next = 1; return;    // test_cthread_var_reset.cpp:66:37;
            end
            TMP_0 = par_next;
            // Call f1() end
            s2_next = TMP_0;
            par_next0 = w_next0;
            // Call f2() begin
            if (|a)
            begin
                par_next0 = par_next0 + 2'sd1;
                local_var2_PROC_STATE_next = 2; return;    // test_cthread_var_reset.cpp:71:37;
            end
            TMP_1 = par_next0;
            // Call f2() end
            s2_next = TMP_1;
            local_var2_PROC_STATE_next = '0; return;    // test_cthread_var_reset.cpp:85:13;
        end
        1: begin
            // Call f1() begin
            if (|a)
            begin
                par_next = par_next + 2'sd1;
                local_var2_PROC_STATE_next = 1; return;    // test_cthread_var_reset.cpp:66:37;
            end
            TMP_0 = par_next;
            // Call f1() end
            s2_next = TMP_0;
            par_next0 = w_next0;
            // Call f2() begin
            if (|a)
            begin
                par_next0 = par_next0 + 2'sd1;
                local_var2_PROC_STATE_next = 2; return;    // test_cthread_var_reset.cpp:71:37;
            end
            TMP_1 = par_next0;
            // Call f2() end
            s2_next = TMP_1;
            local_var2_PROC_STATE_next = '0; return;    // test_cthread_var_reset.cpp:85:13;
        end
        2: begin
            // Call f2() begin
            if (|a)
            begin
                par_next0 = par_next0 + 2'sd1;
                local_var2_PROC_STATE_next = 2; return;    // test_cthread_var_reset.cpp:71:37;
            end
            TMP_1 = par_next0;
            // Call f2() end
            s2_next = TMP_1;
            local_var2_PROC_STATE_next = '0; return;    // test_cthread_var_reset.cpp:85:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : local_var2_ff
    if ( rst ) begin
        w0 <= '0;
        local_var2_PROC_STATE <= '0;    // test_cthread_var_reset.cpp:79:9;
        par <= '0;
        par0 <= '0;
    end
    else begin
        par <= par_next;
        w0 <= w_next0;
        par0 <= par_next0;
        s2 <= s2_next;
        local_var2_PROC_STATE <= local_var2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: local_rec_var1 (test_cthread_var_reset.cpp:90:5) 

// Thread-local variables
logic v_a;
logic v_a_next;
logic signed [31:0] w_b;
logic signed [31:0] w_b_next;
logic signed [31:0] v_b;
logic signed [31:0] v_b_next;
logic signed [31:0] wa_b[2];
logic signed [31:0] wa_b_next[2];
logic signed [31:0] va_b[2];
logic signed [31:0] va_b_next[2];
logic signed [31:0] r1_next;
logic local_rec_var1_PROC_STATE;
logic local_rec_var1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : local_rec_var1_comb     // test_cthread_var_reset.cpp:90:5
    local_rec_var1_func;
end
function void local_rec_var1_func;
    logic w_a;
    logic wa_a[2];
    logic va_a[2];
    r1_next = r1;
    v_a_next = v_a;
    v_b_next = v_b;
    va_b_next = va_b;
    w_b_next = w_b;
    wa_b_next = wa_b;
    local_rec_var1_PROC_STATE_next = local_rec_var1_PROC_STATE;
    
    case (local_rec_var1_PROC_STATE)
        0: begin
            v_a_next = |a;
            v_b_next = 42;
            va_b_next[0] = 43;
            va_b_next[1] = 44;
            local_rec_var1_PROC_STATE_next = 1; return;    // test_cthread_var_reset.cpp:99:13;
        end
        1: begin
            r1_next = (v_a_next ? w_b_next : v_b_next) + wa_b_next[a] + va_b_next[a];
            v_a_next = |a;
            v_b_next = 42;
            va_b_next[0] = 43;
            va_b_next[1] = 44;
            local_rec_var1_PROC_STATE_next = 1; return;    // test_cthread_var_reset.cpp:99:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : local_rec_var1_ff
    if ( rst ) begin
        logic w_a;
        logic wa_a[2];
        w_b <= '0;
        wa_b[0] <= '0;
        wa_b[1] <= '0;
        local_rec_var1_PROC_STATE <= '0;    // test_cthread_var_reset.cpp:94:9;
        v_a <= '0;
        v_b <= '0;
        va_b[0] <= 0; va_b[1] <= 0;
    end
    else begin
        v_a <= v_a_next;
        w_b <= w_b_next;
        v_b <= v_b_next;
        wa_b <= wa_b_next;
        va_b <= va_b_next;
        r1 <= r1_next;
        local_rec_var1_PROC_STATE <= local_rec_var1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: local_rec_var2 (test_cthread_var_reset.cpp:115:5) 

// Thread-local variables
logic signed [31:0] par_b;
logic signed [31:0] par_b_next;
logic par_a;
logic par_a_next;
logic w_a0;
logic w_a_next;
logic signed [31:0] w_b0;
logic signed [31:0] w_b_next0;
logic signed [31:0] par_b0;
logic signed [31:0] par_b_next0;
logic r2_a_next;
logic signed [31:0] r2_b_next;
logic par_a0;
logic par_a_next0;
logic [1:0] local_rec_var2_PROC_STATE;
logic [1:0] local_rec_var2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : local_rec_var2_comb     // test_cthread_var_reset.cpp:115:5
    local_rec_var2_func;
end
function void local_rec_var2_func;
    logic v_a_1;
    integer v_b_1;
    logic TMP_0_a;
    integer TMP_0_b;
    logic TMP_1_a;
    integer TMP_1_b;
    par_a_next = par_a;
    par_a_next0 = par_a0;
    par_b_next = par_b;
    par_b_next0 = par_b0;
    r2_a_next = r2_a;
    r2_b_next = r2_b;
    w_a_next = w_a0;
    w_b_next0 = w_b0;
    local_rec_var2_PROC_STATE_next = local_rec_var2_PROC_STATE;
    
    case (local_rec_var2_PROC_STATE)
        0: begin
            v_a_1 = |a;
            v_b_1 = 42;
            par_a_next = v_a_1; par_b_next = v_b_1;
            // Call g1() begin
            if (|a)
            begin
                par_b_next = par_b_next + 2'sd1;
                local_rec_var2_PROC_STATE_next = 1; return;    // test_cthread_var_reset.cpp:105:44;
            end
            TMP_0_a = par_a_next; TMP_0_b = par_b_next;
            // Call g1() end
            r2_a_next = TMP_0_a; r2_b_next = TMP_0_b;
            par_a_next0 = w_a_next; par_b_next0 = w_b_next0;
            // Call g2() begin
            if (|a)
            begin
                par_b_next0 = par_b_next0 + 2'sd1;
                local_rec_var2_PROC_STATE_next = 2; return;    // test_cthread_var_reset.cpp:110:44;
            end
            TMP_1_a = par_a_next0; TMP_1_b = par_b_next0;
            // Call g2() end
            r2_a_next = TMP_1_a; r2_b_next = TMP_1_b;
            local_rec_var2_PROC_STATE_next = '0; return;    // test_cthread_var_reset.cpp:124:13;
        end
        1: begin
            // Call g1() begin
            if (|a)
            begin
                par_b_next = par_b_next + 2'sd1;
                local_rec_var2_PROC_STATE_next = 1; return;    // test_cthread_var_reset.cpp:105:44;
            end
            TMP_0_a = par_a_next; TMP_0_b = par_b_next;
            // Call g1() end
            r2_a_next = TMP_0_a; r2_b_next = TMP_0_b;
            par_a_next0 = w_a_next; par_b_next0 = w_b_next0;
            // Call g2() begin
            if (|a)
            begin
                par_b_next0 = par_b_next0 + 2'sd1;
                local_rec_var2_PROC_STATE_next = 2; return;    // test_cthread_var_reset.cpp:110:44;
            end
            TMP_1_a = par_a_next0; TMP_1_b = par_b_next0;
            // Call g2() end
            r2_a_next = TMP_1_a; r2_b_next = TMP_1_b;
            local_rec_var2_PROC_STATE_next = '0; return;    // test_cthread_var_reset.cpp:124:13;
        end
        2: begin
            // Call g2() begin
            if (|a)
            begin
                par_b_next0 = par_b_next0 + 2'sd1;
                local_rec_var2_PROC_STATE_next = 2; return;    // test_cthread_var_reset.cpp:110:44;
            end
            TMP_1_a = par_a_next0; TMP_1_b = par_b_next0;
            // Call g2() end
            r2_a_next = TMP_1_a; r2_b_next = TMP_1_b;
            local_rec_var2_PROC_STATE_next = '0; return;    // test_cthread_var_reset.cpp:124:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : local_rec_var2_ff
    if ( rst ) begin
        w_b0 <= '0;
        local_rec_var2_PROC_STATE <= '0;    // test_cthread_var_reset.cpp:118:9;
        par_a <= '0;
        par_b <= '0;
        par_a0 <= '0;
        par_b0 <= '0;
    end
    else begin
        par_b <= par_b_next;
        par_a <= par_a_next;
        w_a0 <= w_a_next;
        w_b0 <= w_b_next0;
        par_b0 <= par_b_next0;
        r2_a <= r2_a_next;
        r2_b <= r2_b_next;
        par_a0 <= par_a_next0;
        local_rec_var2_PROC_STATE <= local_rec_var2_PROC_STATE_next;
    end
end

endmodule


