//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.14
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic s;
logic s1;
logic s2;
logic s3;
logic s4;
logic s5;
logic signed [31:0] s6;
logic signed [31:0] s6a;
logic signed [31:0] s6b;
logic signed [31:0] s7;
logic signed [31:0] s8;
logic signed [31:0] s9;
logic signed [31:0] s10;
logic signed [31:0] s11;

//------------------------------------------------------------------------------
// Clocked THREAD: const1 (test_do_while_const.cpp:67:5) 

// Thread-local variables
logic s1_next;

// Thread-local constants
logic B;

// Next-state combinational logic
always_comb begin : const1_comb     // test_do_while_const.cpp:67:5
    const1_func;
end
function void const1_func;
    s1_next = s1;
    do
    begin
        s1_next = 1;
    end
    while (B && s);
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const1_ff
    if ( ~rstn ) begin
        B = 1;
        s1 <= 0;
    end
    else begin
        s1 <= s1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const2 (test_do_while_const.cpp:84:5) 

// Thread-local variables
logic s2_next;

// Thread-local constants
logic A;

// Next-state combinational logic
always_comb begin : const2_comb     // test_do_while_const.cpp:84:5
    const2_func;
end
function void const2_func;
    s2_next = s2;
    do
    begin
        s2_next = 1;
    end
    while (s || A);
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const2_ff
    if ( ~rstn ) begin
        A = 0;
        s2 <= 0;
    end
    else begin
        s2 <= s2_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const3 (test_do_while_const.cpp:101:5) 

// Thread-local variables
logic s3_next;

// Thread-local constants
logic A0;
logic B0;

// Next-state combinational logic
always_comb begin : const3_comb     // test_do_while_const.cpp:101:5
    const3_func;
end
function void const3_func;
    s3_next = s3;
    do
    begin
        s3_next = 1;
    end
    while (0);
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const3_ff
    if ( ~rstn ) begin
        A0 = 0;
        B0 = 1;
        s3 <= 0;
    end
    else begin
        s3 <= s3_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const4 (test_do_while_const.cpp:118:5) 

// Thread-local variables
logic s4_next;

// Thread-local constants
logic A1;

// Next-state combinational logic
always_comb begin : const4_comb     // test_do_while_const.cpp:118:5
    const4_func;
end
function void const4_func;
    s4_next = s4;
    do
    begin
        s4_next = 1;
    end
    while (A1 || s && (s2 && A1) || s3);
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const4_ff
    if ( ~rstn ) begin
        A1 = 0;
        s4 <= 0;
    end
    else begin
        s4 <= s4_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait1 (test_do_while_const.cpp:138:5) 

// Thread-local variables
logic s5_next;
logic [1:0] const_wait1_PROC_STATE;
logic [1:0] const_wait1_PROC_STATE_next;

// Thread-local constants
logic A2;

// Next-state combinational logic
always_comb begin : const_wait1_comb     // test_do_while_const.cpp:138:5
    const_wait1_func;
end
function void const_wait1_func;
    s5_next = s5;
    const_wait1_PROC_STATE_next = const_wait1_PROC_STATE;
    
    case (const_wait1_PROC_STATE)
        0: begin
            s5_next = !s5;
            const_wait1_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:148:17;
        end
        1: begin
            if (s || A2)
            begin
                s5_next = !s5;
                const_wait1_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:148:17;
            end
            const_wait1_PROC_STATE_next = 0; return;    // test_do_while_const.cpp:150:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait1_ff
    if ( ~rstn ) begin
        A2 = 0;
        s5 <= 0;
        const_wait1_PROC_STATE <= 0;    // test_do_while_const.cpp:142:9;
    end
    else begin
        s5 <= s5_next;
        const_wait1_PROC_STATE <= const_wait1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait2 (test_do_while_const.cpp:157:5) 

// Thread-local variables
logic signed [31:0] s6_next;

// Thread-local constants
logic A3;

// Next-state combinational logic
always_comb begin : const_wait2_comb     // test_do_while_const.cpp:157:5
    const_wait2_func;
end
function void const_wait2_func;
    s6_next = s6;
    s6_next = 1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait2_ff
    if ( ~rstn ) begin
        A3 = 0;
        s6 <= 0;
    end
    else begin
        s6 <= s6_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait2a (test_do_while_const.cpp:173:5) 

// Thread-local variables
logic signed [31:0] s6a_next;

// Next-state combinational logic
always_comb begin : const_wait2a_comb     // test_do_while_const.cpp:173:5
    const_wait2a_func;
end
function void const_wait2a_func;
    s6a_next = s6a;
    s6a_next = 1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait2a_ff
    if ( ~rstn ) begin
        s6a <= 0;
    end
    else begin
        s6a <= s6a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait2b (test_do_while_const.cpp:188:5) 

// Thread-local variables
logic signed [31:0] s6b_next;
logic [1:0] const_wait2b_PROC_STATE;
logic [1:0] const_wait2b_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : const_wait2b_comb     // test_do_while_const.cpp:188:5
    const_wait2b_func;
end
function void const_wait2b_func;
    s6b_next = s6b;
    const_wait2b_PROC_STATE_next = const_wait2b_PROC_STATE;
    
    case (const_wait2b_PROC_STATE)
        0: begin
            const_wait2b_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:196:17;
        end
        1: begin
            s6b_next = 1;
            if (s)
            begin
                const_wait2b_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:196:17;
            end
            s6b_next = 2;
            const_wait2b_PROC_STATE_next = 0; return;    // test_do_while_const.cpp:205:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait2b_ff
    if ( ~rstn ) begin
        s6b <= 0;
        const_wait2b_PROC_STATE <= 0;    // test_do_while_const.cpp:191:9;
    end
    else begin
        s6b <= s6b_next;
        const_wait2b_PROC_STATE <= const_wait2b_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait3 (test_do_while_const.cpp:210:5) 

// Thread-local variables
logic signed [31:0] s7_next;

// Thread-local constants
logic A4;

// Next-state combinational logic
always_comb begin : const_wait3_comb     // test_do_while_const.cpp:210:5
    const_wait3_func;
end
function void const_wait3_func;
    s7_next = s7;
    do
    begin
        s7_next = 2;
    end
    while (0);
    s7_next = 3;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait3_ff
    if ( ~rstn ) begin
        A4 = 0;
        s7 <= 0;
    end
    else begin
        s7 <= s7_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait4 (test_do_while_const.cpp:229:5) 

// Thread-local variables
logic signed [31:0] s8_next;
logic [1:0] const_wait4_PROC_STATE;
logic [1:0] const_wait4_PROC_STATE_next;

// Thread-local constants
logic A5;

// Next-state combinational logic
always_comb begin : const_wait4_comb     // test_do_while_const.cpp:229:5
    const_wait4_func;
end
function void const_wait4_func;
    s8_next = s8;
    const_wait4_PROC_STATE_next = const_wait4_PROC_STATE;
    
    case (const_wait4_PROC_STATE)
        0: begin
            s8_next = 2;
            const_wait4_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:239:17;
        end
        1: begin
            s8_next = 3;
            const_wait4_PROC_STATE_next = 0; return;    // test_do_while_const.cpp:243:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait4_ff
    if ( ~rstn ) begin
        A5 = 0;
        s8 <= 0;
        const_wait4_PROC_STATE <= 0;    // test_do_while_const.cpp:233:9;
    end
    else begin
        s8 <= s8_next;
        const_wait4_PROC_STATE <= const_wait4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait5 (test_do_while_const.cpp:249:5) 

// Thread-local variables
logic signed [31:0] s9_next;
logic [1:0] const_wait5_PROC_STATE;
logic [1:0] const_wait5_PROC_STATE_next;

// Thread-local constants
logic A6;

// Next-state combinational logic
always_comb begin : const_wait5_comb     // test_do_while_const.cpp:249:5
    const_wait5_func;
end
function void const_wait5_func;
    s9_next = s9;
    const_wait5_PROC_STATE_next = const_wait5_PROC_STATE;
    
    case (const_wait5_PROC_STATE)
        0: begin
            s9_next = 1;
            const_wait5_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:259:17;
        end
        1: begin
            if (s)
            begin
                // break begin
                s9_next = 3;
                const_wait5_PROC_STATE_next = 0; return;    // test_do_while_const.cpp:266:13;
                // break end
            end
            s9_next = 2;
            s9_next = 3;
            const_wait5_PROC_STATE_next = 0; return;    // test_do_while_const.cpp:266:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait5_ff
    if ( ~rstn ) begin
        A6 = 0;
        s9 <= 0;
        const_wait5_PROC_STATE <= 0;    // test_do_while_const.cpp:253:9;
    end
    else begin
        s9 <= s9_next;
        const_wait5_PROC_STATE <= const_wait5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait6 (test_do_while_const.cpp:271:5) 

// Thread-local variables
logic signed [31:0] s10_next;
logic [2:0] const_wait6_PROC_STATE;
logic [2:0] const_wait6_PROC_STATE_next;

// Thread-local constants
logic A7;
logic B1;

// Next-state combinational logic
always_comb begin : const_wait6_comb     // test_do_while_const.cpp:271:5
    const_wait6_func;
end
function void const_wait6_func;
    s10_next = s10;
    const_wait6_PROC_STATE_next = const_wait6_PROC_STATE;
    
    case (const_wait6_PROC_STATE)
        0: begin
            if (s1)
            begin
                const_wait6_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:282:21;
            end
            const_wait6_PROC_STATE_next = 2; return;    // test_do_while_const.cpp:286:17;
        end
        1: begin
            s10_next = 1;
            // continue begin
            if (s3 && B1)
            begin
                if (s1)
                begin
                    const_wait6_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:282:21;
                end
                const_wait6_PROC_STATE_next = 2; return;    // test_do_while_const.cpp:286:17;
            end
            if (s4)
            begin
                s10_next = 4;
            end
            const_wait6_PROC_STATE_next = 0; return;    // test_do_while_const.cpp:295:13;
            // continue end
        end
        2: begin
            s10_next = 2;
            const_wait6_PROC_STATE_next = 3; return;    // test_do_while_const.cpp:290:21;
        end
        3: begin
            s10_next = 3;
            if (!s2 || 0)
            begin
                const_wait6_PROC_STATE_next = 3; return;    // test_do_while_const.cpp:290:21;
            end
            if (s3 && B1)
            begin
                if (s1)
                begin
                    const_wait6_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:282:21;
                end
                const_wait6_PROC_STATE_next = 2; return;    // test_do_while_const.cpp:286:17;
            end
            if (s4)
            begin
                s10_next = 4;
            end
            const_wait6_PROC_STATE_next = 0; return;    // test_do_while_const.cpp:295:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait6_ff
    if ( ~rstn ) begin
        A7 = 0;
        B1 = 1;
        s10 <= 0;
        const_wait6_PROC_STATE <= 0;    // test_do_while_const.cpp:276:9;
    end
    else begin
        s10 <= s10_next;
        const_wait6_PROC_STATE <= const_wait6_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait7 (test_do_while_const.cpp:300:5) 

// Thread-local variables
logic signed [31:0] s11_next;
logic [2:0] const_wait7_PROC_STATE;
logic [2:0] const_wait7_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : const_wait7_comb     // test_do_while_const.cpp:300:5
    const_wait7_func;
end
function void const_wait7_func;
    s11_next = s11;
    const_wait7_PROC_STATE_next = const_wait7_PROC_STATE;
    
    case (const_wait7_PROC_STATE)
        0: begin
            if (s1)
            begin
                const_wait7_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:309:21;
            end
            const_wait7_PROC_STATE_next = 2; return;    // test_do_while_const.cpp:313:17;
        end
        1: begin
            s11_next = 1;
            // continue begin
            const_wait7_PROC_STATE_next = 3; return;    // test_do_while_const.cpp:315:13;
            // continue end
        end
        2: begin
            const_wait7_PROC_STATE_next = 3; return;    // test_do_while_const.cpp:315:13;
        end
        3: begin
            const_wait7_PROC_STATE_next = 4; return;    // test_do_while_const.cpp:318:17;
        end
        4: begin
            s11_next = 2;
            if (s1)
            begin
                const_wait7_PROC_STATE_next = 1; return;    // test_do_while_const.cpp:309:21;
            end
            const_wait7_PROC_STATE_next = 2; return;    // test_do_while_const.cpp:313:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait7_ff
    if ( ~rstn ) begin
        s11 <= 0;
        const_wait7_PROC_STATE <= 0;    // test_do_while_const.cpp:303:9;
    end
    else begin
        s11 <= s11_next;
        const_wait7_PROC_STATE <= const_wait7_PROC_STATE_next;
    end
end

endmodule


