//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic read_fifo;
logic write_fifo;
logic [31:0] data_in;
logic reset;
logic [31:0] data_out;
logic full;
logic empty;


//------------------------------------------------------------------------------
// Child module instances

Circ_buf a_mod
(
  .clk(clk),
  .read_fifo(read_fifo),
  .write_fifo(write_fifo),
  .data_in(data_in),
  .reset(reset),
  .data_out(data_out),
  .full(full),
  .empty(empty)
);

endmodule



//==============================================================================
//
// Module: Circ_buf (test_bhv_fifo.cpp:100:5)
//
module Circ_buf // "b_mod.a_mod"
(
    input logic clk,
    input logic read_fifo,
    input logic write_fifo,
    input logic [31:0] data_in,
    input logic reset,
    output logic [31:0] data_out,
    output logic full,
    output logic empty
);

// Variables generated for SystemC signals
logic [31:0] buffer[4];

//------------------------------------------------------------------------------
// Clocked THREAD: fifo_rw (test_bhv_fifo.cpp:46:5) 

// Thread-local variables
logic full_next;
logic empty_next;
logic [31:0] data_out_next;
logic [31:0] buffer_next[4];
logic [2:0] num_in_buf;
logic [2:0] num_in_buf_next;
logic [1:0] tailp;
logic [1:0] tailp_next;
logic [1:0] headp;
logic [1:0] headp_next;

// Next-state combinational logic
always_comb begin : fifo_rw_comb     // test_bhv_fifo.cpp:46:5
    fifo_rw_func;
end
function void fifo_rw_func;
    buffer_next = buffer;
    data_out_next = data_out;
    empty_next = empty;
    full_next = full;
    headp_next = headp;
    num_in_buf_next = num_in_buf;
    tailp_next = tailp;
    if (read_fifo)
    begin
        if (num_in_buf_next != 1'd0)
        begin
            num_in_buf_next--;
            data_out_next = buffer[headp_next++];
            full_next = '0;
            if (num_in_buf_next == 1'd0)
            begin
                empty_next = 1;
            end
        end
    end else begin
        if (write_fifo)
        begin
            if (num_in_buf_next != 3'd4)
            begin
                buffer_next[tailp_next++] = data_in;
                num_in_buf_next++;
                empty_next = '0;
                if (num_in_buf_next == 3'd4)
                begin
                    full_next = 1;
                end
            end
        end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge reset) 
begin : fifo_rw_ff
    if ( reset ) begin
        headp <= '0;
        tailp <= '0;
        num_in_buf <= '0;
        full <= '0;
        empty <= 1;
        data_out <= '0;
        for (int i = 0; i < 4; i++)
        begin
            buffer[i] <= '0;
        end
    end
    else begin
        full <= full_next;
        empty <= empty_next;
        data_out <= data_out_next;
        buffer <= buffer_next;
        num_in_buf <= num_in_buf_next;
        tailp <= tailp_next;
        headp <= headp_next;
    end
end

endmodule


