//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;


//------------------------------------------------------------------------------
// Child module instances

A a_mod
(
  .clk(clk),
  .rst(rst)
);

endmodule



//==============================================================================
//
// Module: A (test_cthread_wait_states.cpp:141:5)
//
module A // "b_mod.a_mod"
(
    input logic clk,
    input logic rst
);

// Variables generated for SystemC signals
logic a;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;
logic signed [31:0] t3;
logic signed [31:0] t4;
logic signed [31:0] t5;

//------------------------------------------------------------------------------
// Clocked THREAD: single_state (test_cthread_wait_states.cpp:44:5) 

// Thread-local variables
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : single_state_comb     // test_cthread_wait_states.cpp:44:5
    single_state_func;
end
function void single_state_func;
    integer i;
    t0_next = t0;
    i = 2;
    t0_next = i;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : single_state_ff
    if ( rst ) begin
        integer i;
        i = '0;
    end
    else begin
        t0 <= t0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: not_single_state1 (test_cthread_wait_states.cpp:56:5) 

// Thread-local variables
logic signed [31:0] t1_next;
logic not_single_state1_PROC_STATE;
logic not_single_state1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : not_single_state1_comb     // test_cthread_wait_states.cpp:56:5
    not_single_state1_func;
end
function void not_single_state1_func;
    integer i;
    t1_next = t1;
    not_single_state1_PROC_STATE_next = not_single_state1_PROC_STATE;
    
    case (not_single_state1_PROC_STATE)
        0: begin
            i = 1;
            i = 2;
            t1_next = i;
            not_single_state1_PROC_STATE_next = 1; return;    // test_cthread_wait_states.cpp:65:13;
        end
        1: begin
            i = 2;
            t1_next = i;
            not_single_state1_PROC_STATE_next = 1; return;    // test_cthread_wait_states.cpp:65:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : not_single_state1_ff
    if ( rst ) begin
        integer i;
        i = '0;
        not_single_state1_PROC_STATE <= '0;    // test_cthread_wait_states.cpp:58:9;
    end
    else begin
        t1 <= t1_next;
        not_single_state1_PROC_STATE <= not_single_state1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: not_single_state2 (test_cthread_wait_states.cpp:70:5) 

// Thread-local variables
logic signed [31:0] t2_next;
logic [1:0] not_single_state2_PROC_STATE;
logic [1:0] not_single_state2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : not_single_state2_comb     // test_cthread_wait_states.cpp:70:5
    not_single_state2_func;
end
function void not_single_state2_func;
    integer i;
    t2_next = t2;
    not_single_state2_PROC_STATE_next = not_single_state2_PROC_STATE;
    
    case (not_single_state2_PROC_STATE)
        0: begin
            i = 1;
            not_single_state2_PROC_STATE_next = 1; return;    // test_cthread_wait_states.cpp:75:9;
        end
        1: begin
            i = 2;
            t2_next = i;
            not_single_state2_PROC_STATE_next = 1; return;    // test_cthread_wait_states.cpp:80:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : not_single_state2_ff
    if ( rst ) begin
        integer i;
        i = '0;
        not_single_state2_PROC_STATE <= '0;    // test_cthread_wait_states.cpp:72:9;
    end
    else begin
        t2 <= t2_next;
        not_single_state2_PROC_STATE <= not_single_state2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: not_single_state3 (test_cthread_wait_states.cpp:85:5) 

// Thread-local variables
logic signed [31:0] t3_next;
logic [1:0] not_single_state3_PROC_STATE;
logic [1:0] not_single_state3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : not_single_state3_comb     // test_cthread_wait_states.cpp:85:5
    not_single_state3_func;
end
function void not_single_state3_func;
    integer i;
    t3_next = t3;
    not_single_state3_PROC_STATE_next = not_single_state3_PROC_STATE;
    
    case (not_single_state3_PROC_STATE)
        0: begin
            if (a)
            begin
                i = 1;
                not_single_state3_PROC_STATE_next = 1; return;    // test_cthread_wait_states.cpp:91:13;
            end
            i = 2;
            t3_next = i;
            not_single_state3_PROC_STATE_next = 1; return;    // test_cthread_wait_states.cpp:97:13;
        end
        1: begin
            i = 2;
            t3_next = i;
            not_single_state3_PROC_STATE_next = 1; return;    // test_cthread_wait_states.cpp:97:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : not_single_state3_ff
    if ( rst ) begin
        integer i;
        i = '0;
        not_single_state3_PROC_STATE <= '0;    // test_cthread_wait_states.cpp:87:9;
    end
    else begin
        t3 <= t3_next;
        not_single_state3_PROC_STATE <= not_single_state3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: state_in_if (test_cthread_wait_states.cpp:102:5) 

// Thread-local variables
logic b;
logic b_next;
logic signed [31:0] t4_next;
logic [1:0] state_in_if_PROC_STATE;
logic [1:0] state_in_if_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : state_in_if_comb     // test_cthread_wait_states.cpp:102:5
    state_in_if_func;
end
function void state_in_if_func;
    b_next = b;
    t4_next = t4;
    state_in_if_PROC_STATE_next = state_in_if_PROC_STATE;
    
    case (state_in_if_PROC_STATE)
        0: begin
            b_next = !b_next;
            if (b_next)
            begin
                state_in_if_PROC_STATE_next = 1; return;    // test_cthread_wait_states.cpp:109:17;
            end
            t4_next = b_next;
            state_in_if_PROC_STATE_next = '0; return;    // test_cthread_wait_states.cpp:113:13;
        end
        1: begin
            t4_next = b_next;
            state_in_if_PROC_STATE_next = '0; return;    // test_cthread_wait_states.cpp:113:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : state_in_if_ff
    if ( rst ) begin
        b <= '0;
        state_in_if_PROC_STATE <= '0;    // test_cthread_wait_states.cpp:104:9;
    end
    else begin
        b <= b_next;
        t4 <= t4_next;
        state_in_if_PROC_STATE <= state_in_if_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: state_in_for (test_cthread_wait_states.cpp:118:5) 

// Thread-local variables
logic b0;
logic b_next0;
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic signed [31:0] t5_next;
logic [1:0] state_in_for_PROC_STATE;
logic [1:0] state_in_for_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : state_in_for_comb     // test_cthread_wait_states.cpp:118:5
    state_in_for_func;
end
function void state_in_for_func;
    b_next0 = b0;
    i_next = i0;
    t5_next = t5;
    state_in_for_PROC_STATE_next = state_in_for_PROC_STATE;
    
    case (state_in_for_PROC_STATE)
        0: begin
            i_next = '0;
            b_next0 = !b_next0;
            state_in_for_PROC_STATE_next = 1; return;    // test_cthread_wait_states.cpp:125:17;
        end
        1: begin
            if (a)
            begin
                // break begin
                t5_next = b_next0;
                state_in_for_PROC_STATE_next = '0; return;    // test_cthread_wait_states.cpp:130:13;
                // break end
            end
            i_next++;
            if (i_next < 3)
            begin
                b_next0 = !b_next0;
                state_in_for_PROC_STATE_next = 1; return;    // test_cthread_wait_states.cpp:125:17;
            end
            t5_next = b_next0;
            state_in_for_PROC_STATE_next = '0; return;    // test_cthread_wait_states.cpp:130:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : state_in_for_ff
    if ( rst ) begin
        b0 <= '0;
        state_in_for_PROC_STATE <= '0;    // test_cthread_wait_states.cpp:120:9;
    end
    else begin
        b0 <= b_next0;
        i0 <= i_next;
        t5 <= t5_next;
        state_in_for_PROC_STATE <= state_in_for_PROC_STATE_next;
    end
end

endmodule


