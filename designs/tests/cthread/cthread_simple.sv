//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.14
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic in;
logic out;
logic [31:0] a;
logic [31:0] b;


//------------------------------------------------------------------------------
// Child module instances

A a_mod
(
  .clk(clk),
  .rst(rst),
  .in(in),
  .out(out),
  .a(a),
  .b(b)
);

endmodule



//==============================================================================
//
// Module: A (test_cthread_simple.cpp:201:5)
//
module A // "b_mod.a_mod"
(
    input logic clk,
    input logic rst,
    input logic in,
    output logic out,
    input logic [31:0] a,
    output logic [31:0] b
);

// Variables generated for SystemC signals
logic d;
logic ps;
logic o;
logic signed [31:0] t0;
logic signed [31:0] t0a;
logic signed [31:0] t1;
logic signed [31:0] t1a;

//------------------------------------------------------------------------------
// Clocked THREAD: simple_thread (test_cthread_simple.cpp:59:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: simple_reg (test_cthread_simple.cpp:66:5) 

// Thread-local variables
logic o_next;

// Next-state combinational logic
always_comb begin : simple_reg_comb     // test_cthread_simple.cpp:66:5
    simple_reg_func;
end
function void simple_reg_func;
    logic [3:0] l;
    o_next = o;
    l = 1;
    o_next = |(l + d + 1);
    l = o;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : simple_reg_ff
    if ( ~rst ) begin
        logic [3:0] l;
        o <= 0;
        l = 0;
    end
    else begin
        o <= o_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple_thread_wo_reset1 (test_cthread_simple.cpp:80:5) 

// Thread-local variables
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : simple_thread_wo_reset1_comb     // test_cthread_simple.cpp:80:5
    simple_thread_wo_reset1_func;
end
function void simple_thread_wo_reset1_func;
    integer i;
    t0_next = t0;
    i = 0;
    t0_next = i;
endfunction

// Synchronous register update
always_ff @(posedge clk) 
begin : simple_thread_wo_reset1_ff
    begin
        t0 <= t0_next;
    end
end

//------------------------------------------------------------------------------
// Method process: concat_meth (test_cthread_simple.cpp:89:5) 

always_comb 
begin : concat_meth     // test_cthread_simple.cpp:89:5
    logic [1:0] c;
    c = {1'(ps), 1'd0};
    t0a = c;
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple_concat (test_cthread_simple.cpp:96:5) 

// Thread-local variables
logic signed [31:0] t1_next;

// Next-state combinational logic
always_comb begin : simple_concat_comb     // test_cthread_simple.cpp:96:5
    simple_concat_func;
end
function void simple_concat_func;
    logic [1:0] c;
    t1_next = t1;
    c = {1'(ps), 1'd0};
    t1_next = c;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : simple_concat_ff
    if ( ~rst ) begin
    end
    else begin
        t1 <= t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple_reg_ro (test_cthread_simple.cpp:107:5) 

// Thread-local variables
logic signed [31:0] t1a_next;

// Next-state combinational logic
always_comb begin : simple_reg_ro_comb     // test_cthread_simple.cpp:107:5
    simple_reg_ro_func;
end
function void simple_reg_ro_func;
    logic b_1;
    t1a_next = t1a;
    b_1 = d;
    t1a_next = b_1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : simple_reg_ro_ff
    if ( ~rst ) begin
    end
    else begin
        t1a <= t1a_next;
    end
end

endmodule


