//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.17
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
    input logic clk
);

// Variables generated for SystemC signals
logic arstn;
logic signed [31:0] out;
logic signed [31:0] in;
logic signed [31:0] out1;
logic signed [31:0] out2;
logic signed [31:0] out3;
logic signed [31:0] out4;
logic signed [31:0] out5;
logic signed [31:0] out6;
logic signed [31:0] out7;

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread0 (test_cthread_fcall.cpp:198:5) 

// Thread-local variables
logic signed [31:0] out_next;
logic test_thread0_PROC_STATE;
logic test_thread0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread0_comb     // test_cthread_fcall.cpp:198:5
    test_thread0_func;
end
function void test_thread0_func;
    integer k;
    out_next = out;
    test_thread0_PROC_STATE_next = test_thread0_PROC_STATE;
    
    case (test_thread0_PROC_STATE)
        0: begin
            out_next = 1;
            // Call f1() begin
            k = 0;
            test_thread0_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out_next = 2;
            out_next = 1;
            // Call f1() begin
            k = 0;
            test_thread0_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread0_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread0_PROC_STATE <= 0;    // test_cthread_fcall.cpp:201:9;
    end
    else begin
        out <= out_next;
        test_thread0_PROC_STATE <= test_thread0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_if1 (test_cthread_fcall.cpp:212:5) 

// Thread-local variables
logic signed [31:0] out1_next;
logic [1:0] test_thread_in_if1_PROC_STATE;
logic [1:0] test_thread_in_if1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_if1_comb     // test_cthread_fcall.cpp:212:5
    test_thread_in_if1_func;
end
function void test_thread_in_if1_func;
    integer k;
    out1_next = out1;
    test_thread_in_if1_PROC_STATE_next = test_thread_in_if1_PROC_STATE;
    
    case (test_thread_in_if1_PROC_STATE)
        0: begin
            out1_next = 1;
            if (in > 1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_if1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out1_next = 2;
            test_thread_in_if1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:225:13;
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out1_next = 2;
            test_thread_in_if1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:225:13;
        end
        2: begin
            out1_next = 3;
            out1_next = 1;
            if (in > 1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_if1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out1_next = 2;
            test_thread_in_if1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:225:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_if1_ff
    if ( ~arstn ) begin
        out1 <= 0;
        test_thread_in_if1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:215:9;
    end
    else begin
        out1 <= out1_next;
        test_thread_in_if1_PROC_STATE <= test_thread_in_if1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_if2 (test_cthread_fcall.cpp:233:5) 

// Thread-local variables
logic signed [31:0] out2_next;
logic [1:0] test_thread_in_if2_PROC_STATE;
logic [1:0] test_thread_in_if2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_if2_comb     // test_cthread_fcall.cpp:233:5
    test_thread_in_if2_func;
end
function void test_thread_in_if2_func;
    integer k;
    out2_next = out2;
    test_thread_in_if2_PROC_STATE_next = test_thread_in_if2_PROC_STATE;
    
    case (test_thread_in_if2_PROC_STATE)
        0: begin
            out2_next = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    // Call f1() begin
                    k = 0;
                    test_thread_in_if2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                    // Call f1() end
                end
            end
            out2_next = 2;
            test_thread_in_if2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:248:13;
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out2_next = 2;
            test_thread_in_if2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:248:13;
        end
        2: begin
            out2_next = 3;
            out2_next = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    // Call f1() begin
                    k = 0;
                    test_thread_in_if2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                    // Call f1() end
                end
            end
            out2_next = 2;
            test_thread_in_if2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:248:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_if2_ff
    if ( ~arstn ) begin
        out2 <= 0;
        test_thread_in_if2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:236:9;
    end
    else begin
        out2 <= out2_next;
        test_thread_in_if2_PROC_STATE <= test_thread_in_if2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_for1 (test_cthread_fcall.cpp:281:5) 

// Thread-local variables
logic signed [31:0] out4_next;
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [1:0] test_thread_in_for1_PROC_STATE;
logic [1:0] test_thread_in_for1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_for1_comb     // test_cthread_fcall.cpp:281:5
    test_thread_in_for1_func;
end
function void test_thread_in_for1_func;
    integer k;
    i_next = i;
    out4_next = out4;
    test_thread_in_for1_PROC_STATE_next = test_thread_in_for1_PROC_STATE;
    
    case (test_thread_in_for1_PROC_STATE)
        0: begin
            out4_next = 1;
            i_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            i_next++;
            if (i_next < 3)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_for1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out4_next = 2;
            test_thread_in_for1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:294:13;
        end
        2: begin
            out4_next = 3;
            out4_next = 1;
            i_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_for1_ff
    if ( ~arstn ) begin
        out4 <= 0;
        test_thread_in_for1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:284:9;
    end
    else begin
        out4 <= out4_next;
        i <= i_next;
        test_thread_in_for1_PROC_STATE <= test_thread_in_for1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_for2 (test_cthread_fcall.cpp:302:5) 

// Thread-local variables
logic signed [31:0] out5_next;
logic signed [31:0] j;
logic signed [31:0] j_next;
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic [1:0] test_thread_in_for2_PROC_STATE;
logic [1:0] test_thread_in_for2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_for2_comb     // test_cthread_fcall.cpp:302:5
    test_thread_in_for2_func;
end
function void test_thread_in_for2_func;
    integer k;
    i_next0 = i0;
    j_next = j;
    out5_next = out5;
    test_thread_in_for2_PROC_STATE_next = test_thread_in_for2_PROC_STATE;
    
    case (test_thread_in_for2_PROC_STATE)
        0: begin
            out5_next = 1;
            i_next0 = 0;
            j_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_next++;
            if (j_next < 3)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            i_next0++;
            if (i_next0 < 3)
            begin
                j_next = 0;
                // Call f1() begin
                k = 0;
                test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out5_next = 2;
            test_thread_in_for2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:317:13;
        end
        2: begin
            out5_next = 3;
            out5_next = 1;
            i_next0 = 0;
            j_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_for2_ff
    if ( ~arstn ) begin
        out5 <= 0;
        test_thread_in_for2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:305:9;
    end
    else begin
        out5 <= out5_next;
        j <= j_next;
        i0 <= i_next0;
        test_thread_in_for2_PROC_STATE <= test_thread_in_for2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_if3 (test_cthread_fcall.cpp:256:5) 

// Thread-local variables
logic signed [31:0] out3_next;
logic [1:0] test_thread_in_if3_PROC_STATE;
logic [1:0] test_thread_in_if3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_if3_comb     // test_cthread_fcall.cpp:256:5
    test_thread_in_if3_func;
end
function void test_thread_in_if3_func;
    integer k;
    out3_next = out3;
    test_thread_in_if3_PROC_STATE_next = test_thread_in_if3_PROC_STATE;
    
    case (test_thread_in_if3_PROC_STATE)
        0: begin
            out3_next = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    out3_next = 4;
                end
                // Call f1() begin
                k = 0;
                test_thread_in_if3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out3_next = 2;
            test_thread_in_if3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:273:13;
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out3_next = 2;
            test_thread_in_if3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:273:13;
        end
        2: begin
            out3_next = 3;
            out3_next = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    out3_next = 4;
                end
                // Call f1() begin
                k = 0;
                test_thread_in_if3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out3_next = 2;
            test_thread_in_if3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:273:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_if3_ff
    if ( ~arstn ) begin
        out3 <= 0;
        test_thread_in_if3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:259:9;
    end
    else begin
        out3 <= out3_next;
        test_thread_in_if3_PROC_STATE <= test_thread_in_if3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple1 (test_cthread_fcall.cpp:402:5) 

// Thread-local variables
logic [1:0] test_thread_multiple1_PROC_STATE;
logic [1:0] test_thread_multiple1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple1_comb     // test_cthread_fcall.cpp:402:5
    test_thread_multiple1_func;
end
function void test_thread_multiple1_func;
    integer j_1;
    integer k;
    test_thread_multiple1_PROC_STATE_next = test_thread_multiple1_PROC_STATE;
    
    case (test_thread_multiple1_PROC_STATE)
        0: begin
            j_1 = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_1 = 2;
            // Call f1() begin
            k = 0;
            test_thread_multiple1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        2: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_1 = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple1_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_multiple1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:405:9;
    end
    else begin
        test_thread_multiple1_PROC_STATE <= test_thread_multiple1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple2 (test_cthread_fcall.cpp:417:5) 

// Thread-local variables
logic signed [31:0] i1;
logic signed [31:0] i_next1;
logic [1:0] test_thread_multiple2_PROC_STATE;
logic [1:0] test_thread_multiple2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple2_comb     // test_cthread_fcall.cpp:417:5
    test_thread_multiple2_func;
end
function void test_thread_multiple2_func;
    integer j_1;
    integer k;
    i_next1 = i1;
    test_thread_multiple2_PROC_STATE_next = test_thread_multiple2_PROC_STATE;
    
    case (test_thread_multiple2_PROC_STATE)
        0: begin
            j_1 = 1;
            i_next1 = 1;
            // Call f2() begin
            k = i_next1;
            test_thread_multiple2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:110:9;
            // Call f2() end
        end
        1: begin
            // Call f2() begin
            k = i_next1 + 1;
            // Call f2() end
            j_1 = 2;
            i_next1 = 2;
            // Call f2() begin
            k = i_next1;
            test_thread_multiple2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:110:9;
            // Call f2() end
        end
        2: begin
            // Call f2() begin
            k = i_next1 + 1;
            // Call f2() end
            j_1 = 1;
            i_next1 = 1;
            // Call f2() begin
            k = i_next1;
            test_thread_multiple2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:110:9;
            // Call f2() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple2_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_multiple2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:420:9;
    end
    else begin
        i1 <= i_next1;
        test_thread_multiple2_PROC_STATE <= test_thread_multiple2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple3 (test_cthread_fcall.cpp:432:5) 

// Thread-local variables
logic signed [31:0] i2;
logic signed [31:0] i_next2;
logic [2:0] test_thread_multiple3_PROC_STATE;
logic [2:0] test_thread_multiple3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple3_comb     // test_cthread_fcall.cpp:432:5
    test_thread_multiple3_func;
end
function void test_thread_multiple3_func;
    integer j_1;
    integer k;
    integer k_1;
    i_next2 = i2;
    test_thread_multiple3_PROC_STATE_next = test_thread_multiple3_PROC_STATE;
    
    case (test_thread_multiple3_PROC_STATE)
        0: begin
            j_1 = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_1 = 2;
            i_next2 = 1;
            // Call f2() begin
            k_1 = i_next2;
            test_thread_multiple3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:110:9;
            // Call f2() end
        end
        2: begin
            // Call f2() begin
            k_1 = i_next2 + 1;
            // Call f2() end
            if (|in)
            begin
                // Call f1() begin
                k = 0;
                test_thread_multiple3_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 5; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        3: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            i_next2 = 2;
            // Call f2() begin
            k_1 = i_next2;
            test_thread_multiple3_PROC_STATE_next = 4; return;    // test_cthread_fcall.cpp:110:9;
            // Call f2() end
        end
        4: begin
            // Call f2() begin
            k_1 = i_next2 + 1;
            // Call f2() end
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 5; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        5: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_1 = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple3_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_multiple3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:435:9;
    end
    else begin
        i2 <= i_next2;
        test_thread_multiple3_PROC_STATE <= test_thread_multiple3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params1 (test_cthread_fcall.cpp:482:5) 

// Thread-local variables
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic signed [31:0] i3;
logic signed [31:0] i_next3;
logic [1:0] test_thread_params1_PROC_STATE;
logic [1:0] test_thread_params1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params1_comb     // test_cthread_fcall.cpp:482:5
    test_thread_params1_func;
end
function void test_thread_params1_func;
    integer TMP_0;
    i_next3 = i3;
    j_next0 = j0;
    test_thread_params1_PROC_STATE_next = test_thread_params1_PROC_STATE;
    
    case (test_thread_params1_PROC_STATE)
        0: begin
            i_next3 = j_next0;
            // Call f3() begin
            if (|i_next3)
            begin
                test_thread_params1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:117:13;
            end
            TMP_0 = i_next3 + 1;
            // Call f3() end
            j_next0 = TMP_0;
            test_thread_params1_PROC_STATE_next = 0; return;    // test_cthread_fcall.cpp:490:13;
        end
        2: begin
            // Call f3() begin
            TMP_0 = i_next3 + 1;
            // Call f3() end
            j_next0 = TMP_0;
            test_thread_params1_PROC_STATE_next = 0; return;    // test_cthread_fcall.cpp:490:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params1_ff
    if ( ~arstn ) begin
        j0 <= 0;
        test_thread_params1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:485:9;
    end
    else begin
        j0 <= j_next0;
        i3 <= i_next3;
        test_thread_params1_PROC_STATE <= test_thread_params1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params2 (test_cthread_fcall.cpp:495:5) 

// Thread-local variables
logic signed [31:0] i4;
logic signed [31:0] i_next4;
logic signed [31:0] N;
logic signed [31:0] N_next;
logic test_thread_params2_PROC_STATE;
logic test_thread_params2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params2_comb     // test_cthread_fcall.cpp:495:5
    test_thread_params2_func;
end
function void test_thread_params2_func;
    integer j_1;
    N_next = N;
    i_next4 = i4;
    test_thread_params2_PROC_STATE_next = test_thread_params2_PROC_STATE;
    
    case (test_thread_params2_PROC_STATE)
        0: begin
            j_1 = 1;
            N_next = 1;
            // Call f4() begin
            i_next4 = 0;
            test_thread_params2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:125:13;
            // Call f4() end
        end
        1: begin
            // Call f4() begin
            i_next4++;
            if (i_next4 < N_next)
            begin
                test_thread_params2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:125:13;
            end
            // Call f4() end
            j_1 = 2;
            j_1 = 1;
            N_next = 1;
            // Call f4() begin
            i_next4 = 0;
            test_thread_params2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:125:13;
            // Call f4() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params2_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_params2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:498:9;
    end
    else begin
        i4 <= i_next4;
        N <= N_next;
        test_thread_params2_PROC_STATE <= test_thread_params2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params3 (test_cthread_fcall.cpp:508:5) 

// Thread-local variables
logic signed [31:0] val;
logic signed [31:0] val_next;
logic [1:0] test_thread_params3_PROC_STATE;
logic [1:0] test_thread_params3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params3_comb     // test_cthread_fcall.cpp:508:5
    test_thread_params3_func;
end
function void test_thread_params3_func;
    integer j_1;
    integer TMP_0;
    val_next = val;
    test_thread_params3_PROC_STATE_next = test_thread_params3_PROC_STATE;
    
    case (test_thread_params3_PROC_STATE)
        0: begin
            test_thread_params3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:514:13;
        end
        1: begin
            val_next = 1;
            // Call f6() begin
            test_thread_params3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:155:9;
            // Call f6() end
        end
        2: begin
            // Call f6() begin
            TMP_0 = val_next - 1;
            // Call f6() end
            j_1 = TMP_0;
            test_thread_params3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:514:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params3_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_params3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:511:9;
    end
    else begin
        val <= val_next;
        test_thread_params3_PROC_STATE <= test_thread_params3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params4 (test_cthread_fcall.cpp:521:5) 

// Thread-local variables
logic signed [31:0] j1;
logic signed [31:0] j_next1;
logic b;
logic b_next;
logic signed [31:0] out6_next;
logic signed [2:0] val0;
logic signed [2:0] val_next0;
logic [1:0] test_thread_params4_PROC_STATE;
logic [1:0] test_thread_params4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params4_comb     // test_cthread_fcall.cpp:521:5
    test_thread_params4_func;
end
function void test_thread_params4_func;
    logic TMP_0;
    b_next = b;
    j_next1 = j1;
    out6_next = out6;
    val_next0 = val0;
    test_thread_params4_PROC_STATE_next = test_thread_params4_PROC_STATE;
    
    case (test_thread_params4_PROC_STATE)
        0: begin
            val_next0 = j_next1;
            // Call f6_() begin
            test_thread_params4_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:160:9;
            // Call f6_() end
        end
        1: begin
            // Call f6_() begin
            TMP_0 = |val_next0;
            // Call f6_() end
            b_next = TMP_0;
            test_thread_params4_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:528:13;
        end
        2: begin
            out6_next = b_next;
            val_next0 = j_next1;
            // Call f6_() begin
            test_thread_params4_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:160:9;
            // Call f6_() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params4_ff
    if ( ~arstn ) begin
        j1 <= 0;
        test_thread_params4_PROC_STATE <= 0;    // test_cthread_fcall.cpp:524:9;
    end
    else begin
        j1 <= j_next1;
        b <= b_next;
        out6 <= out6_next;
        val0 <= val_next0;
        test_thread_params4_PROC_STATE <= test_thread_params4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params5 (test_cthread_fcall.cpp:536:5) 

// Thread-local variables
logic signed [31:0] j2;
logic signed [31:0] j_next2;
logic [2:0] x;
logic [2:0] x_next;
logic signed [31:0] out7_next;
logic signed [31:0] val2;
logic signed [31:0] val2_next;
logic [1:0] test_thread_params5_PROC_STATE;
logic [1:0] test_thread_params5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params5_comb     // test_cthread_fcall.cpp:536:5
    test_thread_params5_func;
end
function void test_thread_params5_func;
    logic b_1;
    integer TMP_0;
    logic val1;
    j_next2 = j2;
    out7_next = out7;
    val2_next = val2;
    x_next = x;
    test_thread_params5_PROC_STATE_next = test_thread_params5_PROC_STATE;
    
    case (test_thread_params5_PROC_STATE)
        0: begin
            b_1 = |in;
            x_next = 5;
            val1 = b_1; val2_next = j_next2;
            // Call f6__() begin
            if (val1)
            begin
                test_thread_params5_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:167:13;
            end else begin
                x_next = x_next + val2_next;
                TMP_0 = val2_next + 2;
            end
            // Call f6__() end
            j_next2 = TMP_0;
            test_thread_params5_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:545:13;
        end
        1: begin
            // Call f6__() begin
            TMP_0 = val2_next + 1;
            // Call f6__() end
            j_next2 = TMP_0;
            test_thread_params5_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:545:13;
        end
        2: begin
            out7_next = x_next;
            b_1 = |in;
            x_next = 5;
            val1 = b_1; val2_next = j_next2;
            // Call f6__() begin
            if (val1)
            begin
                test_thread_params5_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:167:13;
            end else begin
                x_next = x_next + val2_next;
                TMP_0 = val2_next + 2;
            end
            // Call f6__() end
            j_next2 = TMP_0;
            test_thread_params5_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:545:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params5_ff
    if ( ~arstn ) begin
        j2 <= 1;
        test_thread_params5_PROC_STATE <= 0;    // test_cthread_fcall.cpp:539:9;
    end
    else begin
        j2 <= j_next2;
        x <= x_next;
        out7 <= out7_next;
        val2 <= val2_next;
        test_thread_params5_PROC_STATE <= test_thread_params5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple_wait1 (test_cthread_fcall.cpp:554:5) 

// Thread-local variables
logic [1:0] test_thread_multiple_wait1_PROC_STATE;
logic [1:0] test_thread_multiple_wait1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple_wait1_comb     // test_cthread_fcall.cpp:554:5
    test_thread_multiple_wait1_func;
end
function void test_thread_multiple_wait1_func;
    integer j_1;
    integer k;
    test_thread_multiple_wait1_PROC_STATE_next = test_thread_multiple_wait1_PROC_STATE;
    
    case (test_thread_multiple_wait1_PROC_STATE)
        0: begin
            j_1 = 1;
            // Call f5() begin
            k = 0;
            test_thread_multiple_wait1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
            // Call f5() end
        end
        1: begin
            // Call f5() begin
            k = 1;
            test_thread_multiple_wait1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:136:9;
            // Call f5() end
        end
        2: begin
            // Call f5() begin
            k = 2;
            // Call f5() end
            j_1 = 2;
            j_1 = 1;
            // Call f5() begin
            k = 0;
            test_thread_multiple_wait1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
            // Call f5() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple_wait1_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_multiple_wait1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:557:9;
    end
    else begin
        test_thread_multiple_wait1_PROC_STATE <= test_thread_multiple_wait1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple_wait2 (test_cthread_fcall.cpp:567:5) 

// Thread-local variables
logic [1:0] test_thread_multiple_wait2_PROC_STATE;
logic [1:0] test_thread_multiple_wait2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple_wait2_comb     // test_cthread_fcall.cpp:567:5
    test_thread_multiple_wait2_func;
end
function void test_thread_multiple_wait2_func;
    integer j_1;
    integer k;
    test_thread_multiple_wait2_PROC_STATE_next = test_thread_multiple_wait2_PROC_STATE;
    
    case (test_thread_multiple_wait2_PROC_STATE)
        0: begin
            j_1 = 1;
            // Call f5_() begin
            k = 0;
            test_thread_multiple_wait2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:144:9;
            // Call f5_() end
        end
        1: begin
            // Call f5_() begin
            if (|in)
            begin
                k = 1;
                test_thread_multiple_wait2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:148:13;
            end
            k = 2;
            // Call f5_() end
            j_1 = 2;
            j_1 = 1;
            // Call f5_() begin
            k = 0;
            test_thread_multiple_wait2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:144:9;
            // Call f5_() end
        end
        2: begin
            // Call f5_() begin
            k = 2;
            // Call f5_() end
            j_1 = 2;
            j_1 = 1;
            // Call f5_() begin
            k = 0;
            test_thread_multiple_wait2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:144:9;
            // Call f5_() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple_wait2_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_multiple_wait2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:570:9;
    end
    else begin
        test_thread_multiple_wait2_PROC_STATE <= test_thread_multiple_wait2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_inside_call1 (test_cthread_fcall.cpp:454:5) 

// Thread-local variables
logic test_thread_inside_call1_PROC_STATE;
logic test_thread_inside_call1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_inside_call1_comb     // test_cthread_fcall.cpp:454:5
    test_thread_inside_call1_func;
end
function void test_thread_inside_call1_func;
    integer j_1;
    integer l;
    integer k;
    test_thread_inside_call1_PROC_STATE_next = test_thread_inside_call1_PROC_STATE;
    
    case (test_thread_inside_call1_PROC_STATE)
        0: begin
            j_1 = 1;
            // Call f7() begin
            l = 0;
            // Call f1() begin
            k = 0;
            test_thread_inside_call1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
            // Call f7() end
        end
        1: begin
            // Call f7() begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            l = 1;
            // Call f7() end
            j_1 = 2;
            j_1 = 1;
            // Call f7() begin
            l = 0;
            // Call f1() begin
            k = 0;
            test_thread_inside_call1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
            // Call f7() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_inside_call1_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_inside_call1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:457:9;
    end
    else begin
        test_thread_inside_call1_PROC_STATE <= test_thread_inside_call1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_inside_call2 (test_cthread_fcall.cpp:467:5) 

// Thread-local variables
logic [1:0] test_thread_inside_call2_PROC_STATE;
logic [1:0] test_thread_inside_call2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_inside_call2_comb     // test_cthread_fcall.cpp:467:5
    test_thread_inside_call2_func;
end
function void test_thread_inside_call2_func;
    integer j_1;
    integer val_1;
    integer l;
    integer k;
    test_thread_inside_call2_PROC_STATE_next = test_thread_inside_call2_PROC_STATE;
    
    case (test_thread_inside_call2_PROC_STATE)
        0: begin
            j_1 = 1;
            val_1 = j_1;
            // Call f7_() begin
            l = 0;
            if (1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_inside_call2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            // Call f7_() end
        end
        1: begin
            // Call f7_() begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            l = 1;
            test_thread_inside_call2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:188:9;
            // Call f7_() end
        end
        2: begin
            // Call f7_() begin
            // Call f7_() end
            j_1 = 2;
            j_1 = 1;
            val_1 = j_1;
            // Call f7_() begin
            l = 0;
            if (1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_inside_call2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            // Call f7_() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_inside_call2_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_inside_call2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:470:9;
    end
    else begin
        test_thread_inside_call2_PROC_STATE <= test_thread_inside_call2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_while1 (test_cthread_fcall.cpp:324:5) 

// Thread-local variables
logic signed [31:0] i5;
logic signed [31:0] i_next5;
logic signed [31:0] N0;
logic signed [31:0] N_next0;
logic signed [31:0] j3;
logic signed [31:0] j_next3;
logic [1:0] test_thread_in_while1_PROC_STATE;
logic [1:0] test_thread_in_while1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_while1_comb     // test_cthread_fcall.cpp:324:5
    test_thread_in_while1_func;
end
function void test_thread_in_while1_func;
    N_next0 = N0;
    i_next5 = i5;
    j_next3 = j3;
    test_thread_in_while1_PROC_STATE_next = test_thread_in_while1_PROC_STATE;
    
    case (test_thread_in_while1_PROC_STATE)
        0: begin
            j_next3 = 0;
            N_next0 = j_next3;
            // Call f4() begin
            i_next5 = 0;
            if (i_next5 < N_next0)
            begin
                test_thread_in_while1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:125:13;
            end
            // Call f4() end
            test_thread_in_while1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:333:17;
        end
        1: begin
            j_next3++;
            if (j_next3 < 3)
            begin
                N_next0 = j_next3;
                // Call f4() begin
                i_next5 = 0;
                if (i_next5 < N_next0)
                begin
                    test_thread_in_while1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:125:13;
                end
                // Call f4() end
                test_thread_in_while1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:333:17;
            end
            test_thread_in_while1_PROC_STATE_next = 0; return;    // test_cthread_fcall.cpp:337:13;
        end
        2: begin
            // Call f4() begin
            i_next5++;
            if (i_next5 < N_next0)
            begin
                test_thread_in_while1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:125:13;
            end
            // Call f4() end
            test_thread_in_while1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:333:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_while1_ff
    if ( ~arstn ) begin
        test_thread_in_while1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:326:9;
    end
    else begin
        i5 <= i_next5;
        N0 <= N_next0;
        j3 <= j_next3;
        test_thread_in_while1_PROC_STATE <= test_thread_in_while1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_with_break1 (test_cthread_fcall.cpp:341:5) 

// Thread-local variables
logic signed [31:0] j4;
logic signed [31:0] j_next4;
logic [1:0] test_thread_with_break1_PROC_STATE;
logic [1:0] test_thread_with_break1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_with_break1_comb     // test_cthread_fcall.cpp:341:5
    test_thread_with_break1_func;
end
function void test_thread_with_break1_func;
    integer k;
    j_next4 = j4;
    test_thread_with_break1_PROC_STATE_next = test_thread_with_break1_PROC_STATE;
    
    case (test_thread_with_break1_PROC_STATE)
        0: begin
            j_next4 = 0;
            if (|in)
            begin
                // Call f5() begin
                k = 0;
                test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
                // Call f5() end
            end
            test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:354:17;
        end
        1: begin
            // Call f5() begin
            k = 1;
            test_thread_with_break1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:136:9;
            // Call f5() end
        end
        2: begin
            // Call f5() begin
            k = 2;
            // Call f5() end
            // break begin
            j_next4 = 0;
            if (|in)
            begin
                // Call f5() begin
                k = 0;
                test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
                // Call f5() end
            end
            test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:354:17;
            // break end
        end
        3: begin
            j_next4++;
            if (j_next4 < 3)
            begin
                if (|in)
                begin
                    // Call f5() begin
                    k = 0;
                    test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
                    // Call f5() end
                end
                test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:354:17;
            end
            j_next4 = 0;
            if (|in)
            begin
                // Call f5() begin
                k = 0;
                test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
                // Call f5() end
            end
            test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:354:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_with_break1_ff
    if ( ~arstn ) begin
        test_thread_with_break1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:343:9;
    end
    else begin
        j4 <= j_next4;
        test_thread_with_break1_PROC_STATE <= test_thread_with_break1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_with_break2 (test_cthread_fcall.cpp:360:5) 

// Thread-local variables
logic signed [31:0] j5;
logic signed [31:0] j_next5;
logic signed [31:0] i6;
logic signed [31:0] i_next6;
logic [1:0] test_thread_with_break2_PROC_STATE;
logic [1:0] test_thread_with_break2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_with_break2_comb     // test_cthread_fcall.cpp:360:5
    test_thread_with_break2_func;
end
function void test_thread_with_break2_func;
    integer TMP_0;
    i_next6 = i6;
    j_next5 = j5;
    test_thread_with_break2_PROC_STATE_next = test_thread_with_break2_PROC_STATE;
    
    case (test_thread_with_break2_PROC_STATE)
        0: begin
            j_next5 = 0;
            test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:368:17;
        end
        1: begin
            if (|in)
            begin
                // break begin
                j_next5 = 0;
                test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:368:17;
                // break end
            end
            i_next6 = j_next5;
            // Call f3() begin
            if (|i_next6)
            begin
                test_thread_with_break2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:117:13;
            end
            TMP_0 = i_next6 + 1;
            // Call f3() end
            j_next5++;
            if (j_next5 < 3)
            begin
                test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:368:17;
            end
            j_next5 = 0;
            test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:368:17;
        end
        2: begin
            // Call f3() begin
            TMP_0 = i_next6 + 1;
            // Call f3() end
            j_next5++;
            if (j_next5 < 3)
            begin
                test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:368:17;
            end
            j_next5 = 0;
            test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:368:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_with_break2_ff
    if ( ~arstn ) begin
        test_thread_with_break2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:362:9;
    end
    else begin
        j5 <= j_next5;
        i6 <= i_next6;
        test_thread_with_break2_PROC_STATE <= test_thread_with_break2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_with_break3 (test_cthread_fcall.cpp:381:5) 

// Thread-local variables
logic signed [31:0] j6;
logic signed [31:0] j_next6;
logic test_thread_with_break3_PROC_STATE;
logic test_thread_with_break3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_with_break3_comb     // test_cthread_fcall.cpp:381:5
    test_thread_with_break3_func;
end
function void test_thread_with_break3_func;
    j_next6 = j6;
    test_thread_with_break3_PROC_STATE_next = test_thread_with_break3_PROC_STATE;
    
    case (test_thread_with_break3_PROC_STATE)
        0: begin
            j_next6 = 0;
            test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:389:17;
        end
        1: begin
            if (|in)
            begin
                // break begin
                j_next6 = 0;
                test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:389:17;
                // break end
            end
            j_next6++;
            if (j_next6 < 3)
            begin
                test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:389:17;
            end
            j_next6 = 0;
            test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:389:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_with_break3_ff
    if ( ~arstn ) begin
        test_thread_with_break3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:383:9;
    end
    else begin
        j6 <= j_next6;
        test_thread_with_break3_PROC_STATE <= test_thread_with_break3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_reg_arg (test_cthread_fcall.cpp:607:5) 

// Thread-local variables
logic signed [31:0] i7;
logic signed [31:0] i_next7;
logic test_thread_reg_arg_PROC_STATE;
logic test_thread_reg_arg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_reg_arg_comb     // test_cthread_fcall.cpp:607:5
    test_thread_reg_arg_func;
end
function void test_thread_reg_arg_func;
    integer TMP_0;
    integer val_1;
    i_next7 = i7;
    test_thread_reg_arg_PROC_STATE_next = test_thread_reg_arg_PROC_STATE;
    
    case (test_thread_reg_arg_PROC_STATE)
        0: begin
            val_1 = i_next7;
            // Call f0() begin
            TMP_0 = val_1 - 1;
            // Call f0() end
            test_thread_reg_arg_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:613:13;
        end
        1: begin
            i_next7 = i_next7 + 1;
            val_1 = i_next7;
            // Call f0() begin
            TMP_0 = val_1 - 1;
            // Call f0() end
            test_thread_reg_arg_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:613:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_reg_arg_ff
    if ( ~arstn ) begin
        i7 <= 0;
        test_thread_reg_arg_PROC_STATE <= 0;    // test_cthread_fcall.cpp:610:9;
    end
    else begin
        i7 <= i_next7;
        test_thread_reg_arg_PROC_STATE <= test_thread_reg_arg_PROC_STATE_next;
    end
end

endmodule


