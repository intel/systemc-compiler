//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.20
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
    input logic clk
);

// Variables generated for SystemC signals
logic arstn;
logic signed [31:0] in;
logic signed [31:0] out;
logic [3:0] s;
logic signed [31:0] out2;
logic signed [31:0] out3;
logic signed [31:0] out4;
logic signed [31:0] out5;
logic signed [31:0] t0;
logic signed [31:0] t1;

// Local parameters generated for C++ constants
localparam logic [6:0] e = '0;

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_use_def (test_cthread_sel_range.cpp:68:5) 

// Thread-local variables
logic [4:0] z;
logic [4:0] z_next;

// Next-state combinational logic
always_comb begin : range_select_use_def_comb     // test_cthread_sel_range.cpp:68:5
    range_select_use_def_func;
end
function void range_select_use_def_func;
    z_next = z;
    z_next[2 : 1] = 1;
    z_next[4 : 0] = 1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_use_def_ff
    if ( ~arstn ) begin
        z <= 0;
    end
    else begin
        z <= z_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_lhs1 (test_cthread_sel_range.cpp:85:5) 

// Thread-local variables
logic signed [31:0] out2_next;
logic [2:0] x;
logic [2:0] x_next;
logic [2:0] a;
logic [2:0] a_next;

// Next-state combinational logic
always_comb begin : range_select_lhs1_comb     // test_cthread_sel_range.cpp:85:5
    range_select_lhs1_func;
end
function void range_select_lhs1_func;
    a_next = a;
    out2_next = out2;
    x_next = x;
    x_next[1 : 0] = 2;
    a_next[2 : 1] = x_next[1 : 0];
    out2_next = x_next[1 : 0] + a_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_lhs1_ff
    if ( ~arstn ) begin
        out2 <= 0;
        x <= 0;
        a <= 3;
    end
    else begin
        out2 <= out2_next;
        x <= x_next;
        a <= a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_lhs1a (test_cthread_sel_range.cpp:103:5) 

// Thread-local variables
logic signed [31:0] out3_next;
logic [2:0] x0;
logic [2:0] x_next0;

// Next-state combinational logic
always_comb begin : range_select_lhs1a_comb     // test_cthread_sel_range.cpp:103:5
    range_select_lhs1a_func;
end
function void range_select_lhs1a_func;
    out3_next = out3;
    x_next0 = x0;
    x_next0[1 : 0] = 1;
    x_next0[2 : 0] = 5;
    x_next0[2 : 1] = x_next0[1 : 0] <<< 1;
    out3_next = (x_next0[2 : 1] == in) ? x_next0[2 : 0] + 1 : x_next0[1 : 1] * 2;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_lhs1a_ff
    if ( ~arstn ) begin
        out3 <= 0;
        x0 <= 0;
    end
    else begin
        out3 <= out3_next;
        x0 <= x_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_lhs2 (test_cthread_sel_range.cpp:119:5) 

// Thread-local variables
logic signed [31:0] out4_next;
logic [3:0] b;
logic [3:0] b_next;

// Next-state combinational logic
always_comb begin : range_select_lhs2_comb     // test_cthread_sel_range.cpp:119:5
    range_select_lhs2_func;
end
function void range_select_lhs2_func;
    b_next = b;
    out4_next = out4;
    b_next[2 : 1] = 1;
    out4_next = b_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_lhs2_ff
    if ( ~arstn ) begin
        out4 <= 0;
    end
    else begin
        out4 <= out4_next;
        b <= b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_lhs3 (test_cthread_sel_range.cpp:132:5) 

// Thread-local variables
logic [4:0] c;

// Next-state combinational logic
always_comb begin : range_select_lhs3_comb     // test_cthread_sel_range.cpp:132:5
    range_select_lhs3_func;
end
function void range_select_lhs3_func;
    c = 3;
    c[3 : 0] = 1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_lhs3_ff
    if ( ~arstn ) begin
        logic [4:0] c;
        c = 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_lhs4 (test_cthread_sel_range.cpp:145:5) 

// Thread-local variables
logic [5:0] d;
logic [5:0] d_next;

// Next-state combinational logic
always_comb begin : range_select_lhs4_comb     // test_cthread_sel_range.cpp:145:5
    range_select_lhs4_func;
end
function void range_select_lhs4_func;
    d_next = d;
    d_next[3 : 2] = 1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_lhs4_ff
    if ( ~arstn ) begin
    end
    else begin
        d <= d_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_lhs4a (test_cthread_sel_range.cpp:157:5) 

// Thread-local variables
logic signed [31:0] out5_next;

// Next-state combinational logic
always_comb begin : range_select_lhs4a_comb     // test_cthread_sel_range.cpp:157:5
    range_select_lhs4a_func;
end
function void range_select_lhs4a_func;
    out5_next = out5;
    out5_next = e[2 : 0];
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_lhs4a_ff
    if ( ~arstn ) begin
        out <= 1;
    end
    else begin
        out5 <= out5_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_logic (test_cthread_sel_range.cpp:169:5) 

// Thread-local variables
logic signed [31:0] j;
logic signed [31:0] j_next;
logic [6:0] x1;
logic [6:0] x_next1;

// Next-state combinational logic
always_comb begin : range_select_logic_comb     // test_cthread_sel_range.cpp:169:5
    range_select_logic_func;
end
function void range_select_logic_func;
    logic b_1;
    j_next = j;
    x_next1 = x1;
    x_next1[j_next - 1 +: 2] = 1;
    b_1 = |x_next1[1 : 0] || x_next1[2 : 1] == 1 && x_next1[3 : 0] > 0;
    b_1 = |x_next1[1 : 0] || 1 && b_1 && !(0 || |x_next1[3 : 2] || x_next1[3 : 1] == x_next1[2 : 0]);
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_logic_ff
    if ( ~arstn ) begin
        j <= s;
        x1 <= 0;
    end
    else begin
        j <= j_next;
        x1 <= x_next1;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_comp_logic (test_cthread_sel_range.cpp:195:5) 

// Thread-local variables
logic [9:0] x2;
logic [9:0] x_next2;
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : range_select_comp_logic_comb     // test_cthread_sel_range.cpp:195:5
    range_select_comp_logic_func;
end
function void range_select_comp_logic_func;
    integer k;
    t0_next = t0;
    x_next2 = x2;
    k = 0;
    if (1 && |x_next2[1 : 0])
    begin
        k = 1;
    end
    k = 2;
    if (0 || |x_next2[4 : 2])
    begin
        k = 4;
    end
    if (0 || 1 && |x_next2[5 : 1] || 0)
    begin
        k = 5;
    end
    k = 6;
    t0_next = k;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_comp_logic_ff
    if ( ~arstn ) begin
        x2 <= 0;
        x2[5 : 0] = s;
    end
    else begin
        x2 <= x_next2;
        t0 <= t0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_arithm (test_cthread_sel_range.cpp:217:5) 

// Thread-local variables
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic [19:0] y;
logic [19:0] y_next;
logic [39:0] z0;
logic [39:0] z_next0;
logic signed [31:0] t1_next;

// Next-state combinational logic
always_comb begin : range_select_arithm_comb     // test_cthread_sel_range.cpp:217:5
    range_select_arithm_func;
end
function void range_select_arithm_func;
    logic [15:0] yy;
    logic [15:0] zz;
    j_next0 = j0;
    t1_next = t1;
    y_next = y;
    z_next0 = z0;
    yy = y_next[j_next0 +: 3] + 1;
    yy = y_next[3 : 0] * yy;
    yy = y_next[10 : 7] / y_next[2 : 1] + y_next[5 : 4];
    yy = 6'(y_next[12 : 10] - y_next[14 : 10]) >>> y_next[7 : 4];
    zz = 0;
    zz = y_next[3 : 0] % z_next0[3 : 0];
    zz = z_next0[10 : 7] / y_next[2 : 1] + z_next0[5 : 4];
    zz = z_next0[14 : 10] >>> j_next0;
    zz = 7'(signed'({1'b0, z_next0[14 : 10]}) * 3) >>> z_next0[5 : 0];
    zz = z_next0[30 : 10] % z_next0[5 : 0];
    t1_next = zz + yy;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_arithm_ff
    if ( ~arstn ) begin
        j0 <= s;
        y <= j0 + 1;
        z0 <= j0 + 2;
    end
    else begin
        j0 <= j_next0;
        y <= y_next;
        z0 <= z_next0;
        t1 <= t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: range_select_lhs_misc (test_cthread_sel_range.cpp:242:5) 

// Next-state combinational logic
always_comb begin : range_select_lhs_misc_comb     // test_cthread_sel_range.cpp:242:5
    range_select_lhs_misc_func;
end
function void range_select_lhs_misc_func;
    logic [2:0] x_1;
    x_1 = in;
    if (x_1[1 : 1])
    begin
        x_1[2 : 1] = x_1[1 : 0];
    end
    for (integer i = 0; i < 3; i++)
    begin
        x_1[i +: 2] = i % 2;
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : range_select_lhs_misc_ff
    if ( ~arstn ) begin
        logic [2:0] x_1;
        x_1 = 0;
    end
    else begin
    end
end

endmodule


