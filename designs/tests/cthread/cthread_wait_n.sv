//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: test_mod ()
//
module test_mod // "tmod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic a;
logic signed [31:0] t2;
logic signed [31:0] t3;
logic signed [31:0] t4;
logic [3:0] usig;
logic [3:0] usig1;
logic [3:0] usig2;
logic [3:0] usig3;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic [2:0] cntr_name_conflict_WAIT_N_COUNTER_next;

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_reset_decl (test_cthread_wait_n.cpp:92:5) 

// Thread-local variables
logic [1:0] wait_n_reset_decl_WAIT_N_COUNTER;
logic [1:0] wait_n_reset_decl_WAIT_N_COUNTER_next;
logic [31:0] k;
logic [31:0] k_next;
logic signed [31:0] t2_next;
logic wait_n_reset_decl_PROC_STATE;
logic wait_n_reset_decl_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_reset_decl_comb     // test_cthread_wait_n.cpp:92:5
    wait_n_reset_decl_func;
end
function void wait_n_reset_decl_func;
    k_next = k;
    t2_next = t2;
    wait_n_reset_decl_WAIT_N_COUNTER_next = wait_n_reset_decl_WAIT_N_COUNTER;
    wait_n_reset_decl_PROC_STATE_next = wait_n_reset_decl_PROC_STATE;
    
    case (wait_n_reset_decl_PROC_STATE)
        0: begin
            t2_next = k_next;
            wait_n_reset_decl_WAIT_N_COUNTER_next = 2;
            wait_n_reset_decl_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:100:13;
        end
        1: begin
            if (wait_n_reset_decl_WAIT_N_COUNTER != 1) begin
                wait_n_reset_decl_WAIT_N_COUNTER_next = wait_n_reset_decl_WAIT_N_COUNTER - 1;
                wait_n_reset_decl_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:100:13;
            end;
            t2_next = k_next;
            wait_n_reset_decl_WAIT_N_COUNTER_next = 2;
            wait_n_reset_decl_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:100:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_reset_decl_ff
    if ( ~rstn ) begin
        k <= 1'd1;
        wait_n_reset_decl_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:96:9;
        wait_n_reset_decl_WAIT_N_COUNTER <= '0;
    end
    else begin
        wait_n_reset_decl_WAIT_N_COUNTER <= wait_n_reset_decl_WAIT_N_COUNTER_next;
        k <= k_next;
        t2 <= t2_next;
        wait_n_reset_decl_PROC_STATE <= wait_n_reset_decl_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: one_wait_n (test_cthread_wait_n.cpp:105:5) 

// Thread-local variables
logic [1:0] one_wait_n_WAIT_N_COUNTER;
logic [1:0] one_wait_n_WAIT_N_COUNTER_next;
logic [1:0] i;
logic [1:0] i_next;
logic signed [31:0] t3_next;
logic [1:0] one_wait_n_PROC_STATE;
logic [1:0] one_wait_n_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : one_wait_n_comb     // test_cthread_wait_n.cpp:105:5
    one_wait_n_func;
end
function void one_wait_n_func;
    i_next = i;
    t3_next = t3;
    one_wait_n_WAIT_N_COUNTER_next = one_wait_n_WAIT_N_COUNTER;
    one_wait_n_PROC_STATE_next = one_wait_n_PROC_STATE;
    
    case (one_wait_n_PROC_STATE)
        0: begin
            one_wait_n_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:109:13;
        end
        1: begin
            t3_next = i_next++;
            one_wait_n_WAIT_N_COUNTER_next = 2;
            one_wait_n_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:111:13;
        end
        2: begin
            if (one_wait_n_WAIT_N_COUNTER != 1) begin
                one_wait_n_WAIT_N_COUNTER_next = one_wait_n_WAIT_N_COUNTER - 1;
                one_wait_n_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:111:13;
            end;
            one_wait_n_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:109:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : one_wait_n_ff
    if ( ~rstn ) begin
        i <= '0;
        one_wait_n_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:107:9;
        one_wait_n_WAIT_N_COUNTER <= '0;
    end
    else begin
        one_wait_n_WAIT_N_COUNTER <= one_wait_n_WAIT_N_COUNTER_next;
        i <= i_next;
        t3 <= t3_next;
        one_wait_n_PROC_STATE <= one_wait_n_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread0 (test_cthread_wait_n.cpp:116:5) 

// Thread-local variables
logic [1:0] thread0_WAIT_N_COUNTER;
logic [1:0] thread0_WAIT_N_COUNTER_next;
logic signed [31:0] t4_next;
logic [1:0] thread0_PROC_STATE;
logic [1:0] thread0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread0_comb     // test_cthread_wait_n.cpp:116:5
    thread0_func;
end
function void thread0_func;
    t4_next = t4;
    thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER;
    thread0_PROC_STATE_next = thread0_PROC_STATE;
    
    case (thread0_PROC_STATE)
        0: begin
            thread0_WAIT_N_COUNTER_next = 1;
            thread0_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:119:13;
        end
        1: begin
            if (thread0_WAIT_N_COUNTER != 1) begin
                thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER - 1;
                thread0_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:119:13;
            end;
            thread0_WAIT_N_COUNTER_next = 2;
            thread0_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:120:13;
        end
        2: begin
            if (thread0_WAIT_N_COUNTER != 1) begin
                thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER - 1;
                thread0_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:120:13;
            end;
            t4_next = 1;
            thread0_WAIT_N_COUNTER_next = 3;
            thread0_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:122:13;
        end
        3: begin
            if (thread0_WAIT_N_COUNTER != 1) begin
                thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER - 1;
                thread0_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:122:13;
            end;
            thread0_PROC_STATE_next = '0; return;    // test_cthread_wait_n.cpp:118:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread0_ff
    if ( ~rstn ) begin
        thread0_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:118:13;
        thread0_WAIT_N_COUNTER <= '0;
    end
    else begin
        thread0_WAIT_N_COUNTER <= thread0_WAIT_N_COUNTER_next;
        t4 <= t4_next;
        thread0_PROC_STATE <= thread0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_waitn_first (test_cthread_wait_n.cpp:128:5) 

// Thread-local variables
logic [1:0] thread_waitn_first_WAIT_N_COUNTER;
logic [1:0] thread_waitn_first_WAIT_N_COUNTER_next;
logic [3:0] usig_next;
logic thread_waitn_first_PROC_STATE;
logic thread_waitn_first_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread_waitn_first_comb     // test_cthread_wait_n.cpp:128:5
    thread_waitn_first_func;
end
function void thread_waitn_first_func;
    usig_next = usig;
    thread_waitn_first_WAIT_N_COUNTER_next = thread_waitn_first_WAIT_N_COUNTER;
    thread_waitn_first_PROC_STATE_next = thread_waitn_first_PROC_STATE;
    
    case (thread_waitn_first_PROC_STATE)
        0: begin
            if (thread_waitn_first_WAIT_N_COUNTER != 1) begin
                thread_waitn_first_WAIT_N_COUNTER_next = thread_waitn_first_WAIT_N_COUNTER - 1;
                thread_waitn_first_PROC_STATE_next = '0; return;    // test_cthread_wait_n.cpp:131:13;
            end;
            usig_next = 1'd1;
            thread_waitn_first_WAIT_N_COUNTER_next = 3;
            thread_waitn_first_PROC_STATE_next = '0; return;    // test_cthread_wait_n.cpp:131:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread_waitn_first_ff
    if ( ~rstn ) begin
        usig <= '0;
        thread_waitn_first_WAIT_N_COUNTER <= 3;
        thread_waitn_first_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:131:13;
    end
    else begin
        thread_waitn_first_WAIT_N_COUNTER <= thread_waitn_first_WAIT_N_COUNTER_next;
        usig <= usig_next;
        thread_waitn_first_PROC_STATE <= thread_waitn_first_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_waitn_no_reset (test_cthread_wait_n.cpp:137:5) 

// Thread-local variables
logic [3:0] usig1_next;

// Next-state combinational logic
always_comb begin : thread_waitn_no_reset_comb     // test_cthread_wait_n.cpp:137:5
    thread_waitn_no_reset_func;
end
function void thread_waitn_no_reset_func;
    usig1_next = usig1;
    usig1_next = 1'd1;
endfunction

// Synchronous register update
always_ff @(posedge clk) 
begin : thread_waitn_no_reset_ff
    begin
        usig1 <= usig1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_waitn_first_cond (test_cthread_wait_n.cpp:146:5) 

// Thread-local variables
logic [2:0] thread_waitn_first_cond_WAIT_N_COUNTER;
logic [2:0] thread_waitn_first_cond_WAIT_N_COUNTER_next;
logic signed [31:0] m;
logic signed [31:0] m_next;
logic [3:0] usig2_next;
logic thread_waitn_first_cond_PROC_STATE;
logic thread_waitn_first_cond_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread_waitn_first_cond_comb     // test_cthread_wait_n.cpp:146:5
    thread_waitn_first_cond_func;
end
function void thread_waitn_first_cond_func;
    m_next = m;
    usig2_next = usig2;
    thread_waitn_first_cond_WAIT_N_COUNTER_next = thread_waitn_first_cond_WAIT_N_COUNTER;
    thread_waitn_first_cond_PROC_STATE_next = thread_waitn_first_cond_PROC_STATE;
    
    case (thread_waitn_first_cond_PROC_STATE)
        0: begin
            if (thread_waitn_first_cond_WAIT_N_COUNTER != 1) begin
                thread_waitn_first_cond_WAIT_N_COUNTER_next = thread_waitn_first_cond_WAIT_N_COUNTER - 1;
                thread_waitn_first_cond_PROC_STATE_next = '0; return;    // test_cthread_wait_n.cpp:153:17;
            end;
            usig2_next = 1'd1;
            thread_waitn_first_cond_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:156:13;
        end
        1: begin
            thread_waitn_first_cond_WAIT_N_COUNTER_next = 5;
            thread_waitn_first_cond_PROC_STATE_next = '0; return;    // test_cthread_wait_n.cpp:153:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread_waitn_first_cond_ff
    if ( ~rstn ) begin
        m <= '0;
        usig2 <= '0;
        thread_waitn_first_cond_WAIT_N_COUNTER <= 5;
        thread_waitn_first_cond_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:153:17;
    end
    else begin
        thread_waitn_first_cond_WAIT_N_COUNTER <= thread_waitn_first_cond_WAIT_N_COUNTER_next;
        m <= m_next;
        usig2 <= usig2_next;
        thread_waitn_first_cond_PROC_STATE <= thread_waitn_first_cond_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_waitn_cond (test_cthread_wait_n.cpp:161:5) 

// Thread-local variables
logic [2:0] thread_waitn_cond_WAIT_N_COUNTER;
logic [2:0] thread_waitn_cond_WAIT_N_COUNTER_next;
logic [3:0] usig3_next;
logic [1:0] thread_waitn_cond_PROC_STATE;
logic [1:0] thread_waitn_cond_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread_waitn_cond_comb     // test_cthread_wait_n.cpp:161:5
    thread_waitn_cond_func;
end
function void thread_waitn_cond_func;
    usig3_next = usig3;
    thread_waitn_cond_WAIT_N_COUNTER_next = thread_waitn_cond_WAIT_N_COUNTER;
    thread_waitn_cond_PROC_STATE_next = thread_waitn_cond_PROC_STATE;
    
    case (thread_waitn_cond_PROC_STATE)
        0: begin
            usig3_next = 1'd1;
            if (a)
            begin
                thread_waitn_cond_WAIT_N_COUNTER_next = 3;
                thread_waitn_cond_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:167:17;
            end else begin
                thread_waitn_cond_WAIT_N_COUNTER_next = 5;
                thread_waitn_cond_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:169:17;
            end
        end
        1: begin
            if (thread_waitn_cond_WAIT_N_COUNTER != 1) begin
                thread_waitn_cond_WAIT_N_COUNTER_next = thread_waitn_cond_WAIT_N_COUNTER - 1;
                thread_waitn_cond_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:167:17;
            end;
            thread_waitn_cond_PROC_STATE_next = '0; return;    // test_cthread_wait_n.cpp:164:13;
        end
        2: begin
            if (thread_waitn_cond_WAIT_N_COUNTER != 1) begin
                thread_waitn_cond_WAIT_N_COUNTER_next = thread_waitn_cond_WAIT_N_COUNTER - 1;
                thread_waitn_cond_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:169:17;
            end;
            usig3_next = 2'd2;
            thread_waitn_cond_WAIT_N_COUNTER_next = 2;
            thread_waitn_cond_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:171:17;
        end
        3: begin
            if (thread_waitn_cond_WAIT_N_COUNTER != 1) begin
                thread_waitn_cond_WAIT_N_COUNTER_next = thread_waitn_cond_WAIT_N_COUNTER - 1;
                thread_waitn_cond_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:171:17;
            end;
            thread_waitn_cond_PROC_STATE_next = '0; return;    // test_cthread_wait_n.cpp:164:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread_waitn_cond_ff
    if ( ~rstn ) begin
        usig3 <= '0;
        thread_waitn_cond_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:164:13;
        thread_waitn_cond_WAIT_N_COUNTER <= '0;
    end
    else begin
        thread_waitn_cond_WAIT_N_COUNTER <= thread_waitn_cond_WAIT_N_COUNTER_next;
        usig3 <= usig3_next;
        thread_waitn_cond_PROC_STATE <= thread_waitn_cond_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1a (test_cthread_wait_n.cpp:176:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: thread1b (test_cthread_wait_n.cpp:184:5) 

// Thread-local variables
logic [1:0] thread1b_WAIT_N_COUNTER;
logic [1:0] thread1b_WAIT_N_COUNTER_next;
logic signed [31:0] t0_next;
logic thread1b_PROC_STATE;
logic thread1b_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1b_comb     // test_cthread_wait_n.cpp:184:5
    thread1b_func;
end
function void thread1b_func;
    integer i_1;
    t0_next = t0;
    thread1b_WAIT_N_COUNTER_next = thread1b_WAIT_N_COUNTER;
    thread1b_PROC_STATE_next = thread1b_PROC_STATE;
    
    case (thread1b_PROC_STATE)
        0: begin
            i_1 = '0;
            t0_next = i_1;
            thread1b_WAIT_N_COUNTER_next = 3;
            thread1b_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:189:13;
        end
        1: begin
            if (thread1b_WAIT_N_COUNTER != 1) begin
                thread1b_WAIT_N_COUNTER_next = thread1b_WAIT_N_COUNTER - 1;
                thread1b_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:189:13;
            end;
            i_1 = '0;
            t0_next = i_1;
            thread1b_WAIT_N_COUNTER_next = 3;
            thread1b_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:189:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1b_ff
    if ( ~rstn ) begin
        thread1b_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:185:9;
        thread1b_WAIT_N_COUNTER <= '0;
    end
    else begin
        thread1b_WAIT_N_COUNTER <= thread1b_WAIT_N_COUNTER_next;
        t0 <= t0_next;
        thread1b_PROC_STATE <= thread1b_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1c (test_cthread_wait_n.cpp:194:5) 

// Thread-local variables
logic [1:0] thread1c_WAIT_N_COUNTER;
logic [1:0] thread1c_WAIT_N_COUNTER_next;
logic signed [31:0] t1_next;
logic thread1c_PROC_STATE;
logic thread1c_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1c_comb     // test_cthread_wait_n.cpp:194:5
    thread1c_func;
end
function void thread1c_func;
    integer i_1;
    t1_next = t1;
    thread1c_WAIT_N_COUNTER_next = thread1c_WAIT_N_COUNTER;
    thread1c_PROC_STATE_next = thread1c_PROC_STATE;
    
    case (thread1c_PROC_STATE)
        0: begin
            thread1c_WAIT_N_COUNTER_next = 3;
            thread1c_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:197:13;
        end
        1: begin
            if (thread1c_WAIT_N_COUNTER != 1) begin
                thread1c_WAIT_N_COUNTER_next = thread1c_WAIT_N_COUNTER - 1;
                thread1c_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:197:13;
            end;
            i_1 = '0;
            t1_next = i_1;
            thread1c_WAIT_N_COUNTER_next = 3;
            thread1c_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:197:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1c_ff
    if ( ~rstn ) begin
        thread1c_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:195:9;
        thread1c_WAIT_N_COUNTER <= '0;
    end
    else begin
        thread1c_WAIT_N_COUNTER <= thread1c_WAIT_N_COUNTER_next;
        t1 <= t1_next;
        thread1c_PROC_STATE <= thread1c_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1d (test_cthread_wait_n.cpp:203:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: thread2 (test_cthread_wait_n.cpp:211:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: thread3 (test_cthread_wait_n.cpp:218:5) 

// Thread-local variables
logic [1:0] thread3_WAIT_N_COUNTER;
logic [1:0] thread3_WAIT_N_COUNTER_next;
logic signed [31:0] n;
logic signed [31:0] n_next;
logic [1:0] thread3_PROC_STATE;
logic [1:0] thread3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread3_comb     // test_cthread_wait_n.cpp:218:5
    thread3_func;
end
function void thread3_func;
    n_next = n;
    thread3_WAIT_N_COUNTER_next = thread3_WAIT_N_COUNTER;
    thread3_PROC_STATE_next = thread3_PROC_STATE;
    
    case (thread3_PROC_STATE)
        0: begin
            n_next = 2;
            thread3_WAIT_N_COUNTER_next = n_next;
            thread3_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:225:13;
        end
        1: begin
            if (thread3_WAIT_N_COUNTER != 1) begin
                thread3_WAIT_N_COUNTER_next = thread3_WAIT_N_COUNTER - 1;
                thread3_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:225:13;
            end;
            thread3_WAIT_N_COUNTER_next = n_next + 2'sd1;
            thread3_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:226:13;
        end
        2: begin
            if (thread3_WAIT_N_COUNTER != 1) begin
                thread3_WAIT_N_COUNTER_next = thread3_WAIT_N_COUNTER - 1;
                thread3_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:226:13;
            end;
            thread3_PROC_STATE_next = '0; return;    // test_cthread_wait_n.cpp:223:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread3_ff
    if ( ~rstn ) begin
        thread3_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:223:13;
        thread3_WAIT_N_COUNTER <= '0;
    end
    else begin
        thread3_WAIT_N_COUNTER <= thread3_WAIT_N_COUNTER_next;
        n <= n_next;
        thread3_PROC_STATE <= thread3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread4_no_waitn (test_cthread_wait_n.cpp:230:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_const (test_cthread_wait_n.cpp:239:5) 

// Thread-local variables
logic [1:0] wait_n_const_WAIT_N_COUNTER;
logic [1:0] wait_n_const_WAIT_N_COUNTER_next;
logic wait_n_const_PROC_STATE;
logic wait_n_const_PROC_STATE_next;

// Thread-local constants
logic [31:0] n0;

// Next-state combinational logic
always_comb begin : wait_n_const_comb     // test_cthread_wait_n.cpp:239:5
    wait_n_const_func;
end
function void wait_n_const_func;
    wait_n_const_WAIT_N_COUNTER_next = wait_n_const_WAIT_N_COUNTER;
    wait_n_const_PROC_STATE_next = wait_n_const_PROC_STATE;
    
    case (wait_n_const_PROC_STATE)
        0: begin
            wait_n_const_WAIT_N_COUNTER_next = n0;
            wait_n_const_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:244:13;
        end
        1: begin
            if (wait_n_const_WAIT_N_COUNTER != 1) begin
                wait_n_const_WAIT_N_COUNTER_next = wait_n_const_WAIT_N_COUNTER - 1;
                wait_n_const_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:244:13;
            end;
            wait_n_const_WAIT_N_COUNTER_next = n0;
            wait_n_const_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:244:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_const_ff
    if ( ~rstn ) begin
        n0 = 2'd2;
        wait_n_const_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:241:9;
        wait_n_const_WAIT_N_COUNTER <= '0;
    end
    else begin
        wait_n_const_WAIT_N_COUNTER <= wait_n_const_WAIT_N_COUNTER_next;
        wait_n_const_PROC_STATE <= wait_n_const_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_var (test_cthread_wait_n.cpp:248:5) 

// Thread-local variables
logic [1:0] wait_n_var_WAIT_N_COUNTER;
logic [1:0] wait_n_var_WAIT_N_COUNTER_next;
logic wait_n_var_PROC_STATE;
logic wait_n_var_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_var_comb     // test_cthread_wait_n.cpp:248:5
    wait_n_var_func;
end
function void wait_n_var_func;
    integer unsigned n_1;
    wait_n_var_WAIT_N_COUNTER_next = wait_n_var_WAIT_N_COUNTER;
    wait_n_var_PROC_STATE_next = wait_n_var_PROC_STATE;
    
    case (wait_n_var_PROC_STATE)
        0: begin
            n_1 = 2'd2;
            wait_n_var_WAIT_N_COUNTER_next = n_1;
            wait_n_var_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:254:13;
        end
        1: begin
            if (wait_n_var_WAIT_N_COUNTER != 1) begin
                wait_n_var_WAIT_N_COUNTER_next = wait_n_var_WAIT_N_COUNTER - 1;
                wait_n_var_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:254:13;
            end;
            n_1 = 2'd2;
            wait_n_var_WAIT_N_COUNTER_next = n_1;
            wait_n_var_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:254:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_var_ff
    if ( ~rstn ) begin
        integer unsigned n_1;
        n_1 = '0;
        wait_n_var_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:250:9;
        wait_n_var_WAIT_N_COUNTER <= '0;
    end
    else begin
        wait_n_var_WAIT_N_COUNTER <= wait_n_var_WAIT_N_COUNTER_next;
        wait_n_var_PROC_STATE <= wait_n_var_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_calc (test_cthread_wait_n.cpp:258:5) 

// Thread-local variables
logic [2:0] wait_n_calc_WAIT_N_COUNTER;
logic [2:0] wait_n_calc_WAIT_N_COUNTER_next;
logic [31:0] n1;
logic [31:0] n_next0;
logic [1:0] wait_n_calc_PROC_STATE;
logic [1:0] wait_n_calc_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_calc_comb     // test_cthread_wait_n.cpp:258:5
    wait_n_calc_func;
end
function void wait_n_calc_func;
    integer unsigned m_1;
    n_next0 = n1;
    wait_n_calc_WAIT_N_COUNTER_next = wait_n_calc_WAIT_N_COUNTER;
    wait_n_calc_PROC_STATE_next = wait_n_calc_PROC_STATE;
    
    case (wait_n_calc_PROC_STATE)
        0: begin
            n_next0 = 2'd2;
            wait_n_calc_WAIT_N_COUNTER_next = n_next0 - 1;
            wait_n_calc_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:265:13;
        end
        1: begin
            if (wait_n_calc_WAIT_N_COUNTER != 1) begin
                wait_n_calc_WAIT_N_COUNTER_next = wait_n_calc_WAIT_N_COUNTER - 1;
                wait_n_calc_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:265:13;
            end;
            n_next0++;
            m_1 = 1'd1;
            wait_n_calc_WAIT_N_COUNTER_next = n_next0 + m_1;
            wait_n_calc_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:268:13;
        end
        2: begin
            if (wait_n_calc_WAIT_N_COUNTER != 1) begin
                wait_n_calc_WAIT_N_COUNTER_next = wait_n_calc_WAIT_N_COUNTER - 1;
                wait_n_calc_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:268:13;
            end;
            n_next0 = 2'd2;
            wait_n_calc_WAIT_N_COUNTER_next = n_next0 - 1;
            wait_n_calc_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:265:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_calc_ff
    if ( ~rstn ) begin
        wait_n_calc_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:261:9;
        wait_n_calc_WAIT_N_COUNTER <= '0;
    end
    else begin
        wait_n_calc_WAIT_N_COUNTER <= wait_n_calc_WAIT_N_COUNTER_next;
        n1 <= n_next0;
        wait_n_calc_PROC_STATE <= wait_n_calc_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_calc_if (test_cthread_wait_n.cpp:273:5) 

// Thread-local variables
logic [1:0] wait_n_calc_if_WAIT_N_COUNTER;
logic [1:0] wait_n_calc_if_WAIT_N_COUNTER_next;
logic [1:0] wait_n_calc_if_PROC_STATE;
logic [1:0] wait_n_calc_if_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_calc_if_comb     // test_cthread_wait_n.cpp:273:5
    wait_n_calc_if_func;
end
function void wait_n_calc_if_func;
    integer unsigned n_1;
    wait_n_calc_if_WAIT_N_COUNTER_next = wait_n_calc_if_WAIT_N_COUNTER;
    wait_n_calc_if_PROC_STATE_next = wait_n_calc_if_PROC_STATE;
    
    case (wait_n_calc_if_PROC_STATE)
        0: begin
            n_1 = 2'd2;
            if (a)
            begin
                wait_n_calc_if_WAIT_N_COUNTER_next = n_1++;
                wait_n_calc_if_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:280:27;
            end
            wait_n_calc_if_PROC_STATE_next = '0; return;    // test_cthread_wait_n.cpp:282:13;
        end
        1: begin
            if (wait_n_calc_if_WAIT_N_COUNTER != 1) begin
                wait_n_calc_if_WAIT_N_COUNTER_next = wait_n_calc_if_WAIT_N_COUNTER - 1;
                wait_n_calc_if_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:280:27;
            end;
            wait_n_calc_if_PROC_STATE_next = '0; return;    // test_cthread_wait_n.cpp:282:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_calc_if_ff
    if ( ~rstn ) begin
        wait_n_calc_if_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:276:9;
        wait_n_calc_if_WAIT_N_COUNTER <= '0;
    end
    else begin
        wait_n_calc_if_WAIT_N_COUNTER <= wait_n_calc_if_WAIT_N_COUNTER_next;
        wait_n_calc_if_PROC_STATE <= wait_n_calc_if_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_calc_for (test_cthread_wait_n.cpp:287:5) 

// Thread-local variables
logic [1:0] wait_n_calc_for_WAIT_N_COUNTER;
logic [1:0] wait_n_calc_for_WAIT_N_COUNTER_next;
logic [31:0] n2;
logic [31:0] n_next1;
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic wait_n_calc_for_PROC_STATE;
logic wait_n_calc_for_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_calc_for_comb     // test_cthread_wait_n.cpp:287:5
    wait_n_calc_for_func;
end
function void wait_n_calc_for_func;
    i_next0 = i0;
    n_next1 = n2;
    wait_n_calc_for_WAIT_N_COUNTER_next = wait_n_calc_for_WAIT_N_COUNTER;
    wait_n_calc_for_PROC_STATE_next = wait_n_calc_for_PROC_STATE;
    
    case (wait_n_calc_for_PROC_STATE)
        0: begin
            i_next0 = '0;
            wait_n_calc_for_WAIT_N_COUNTER_next = n_next1;
            wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:294:17;
        end
        1: begin
            if (wait_n_calc_for_WAIT_N_COUNTER != 1) begin
                wait_n_calc_for_WAIT_N_COUNTER_next = wait_n_calc_for_WAIT_N_COUNTER - 1;
                wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:294:17;
            end;
            i_next0++;
            if (i_next0 < 2)
            begin
                wait_n_calc_for_WAIT_N_COUNTER_next = n_next1;
                wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:294:17;
            end
            i_next0 = '0;
            wait_n_calc_for_WAIT_N_COUNTER_next = n_next1;
            wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:294:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_calc_for_ff
    if ( ~rstn ) begin
        n2 <= 2'd3;
        wait_n_calc_for_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:290:9;
        wait_n_calc_for_WAIT_N_COUNTER <= '0;
    end
    else begin
        wait_n_calc_for_WAIT_N_COUNTER <= wait_n_calc_for_WAIT_N_COUNTER_next;
        n2 <= n_next1;
        i0 <= i_next0;
        wait_n_calc_for_PROC_STATE <= wait_n_calc_for_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: three_wait (test_cthread_wait_n.cpp:299:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: four_wait (test_cthread_wait_n.cpp:311:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: cntr_name_conflict (test_cthread_wait_n.cpp:326:5) 

// Thread-local variables
logic [1:0] cntr_name_conflict_WAIT_N_COUNTER0;
logic [1:0] cntr_name_conflict_WAIT_N_COUNTER_next0;
logic [2:0] cntr_name_conflict_WAIT_N_COUNTER_next_next;
logic cntr_name_conflict_WAIT_N_COUNTER;
logic cntr_name_conflict_WAIT_N_COUNTER_next1;
logic cntr_name_conflict_PROC_STATE;
logic cntr_name_conflict_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : cntr_name_conflict_comb     // test_cthread_wait_n.cpp:326:5
    cntr_name_conflict_func;
end
function void cntr_name_conflict_func;
    cntr_name_conflict_WAIT_N_COUNTER_next1 = cntr_name_conflict_WAIT_N_COUNTER;
    cntr_name_conflict_WAIT_N_COUNTER_next_next = cntr_name_conflict_WAIT_N_COUNTER_next;
    cntr_name_conflict_WAIT_N_COUNTER_next0 = cntr_name_conflict_WAIT_N_COUNTER0;
    cntr_name_conflict_PROC_STATE_next = cntr_name_conflict_PROC_STATE;
    
    case (cntr_name_conflict_PROC_STATE)
        0: begin
            cntr_name_conflict_WAIT_N_COUNTER_next1 = !cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next_next = cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next0 = 3;
            cntr_name_conflict_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:335:13;
        end
        1: begin
            if (cntr_name_conflict_WAIT_N_COUNTER0 != 1) begin
                cntr_name_conflict_WAIT_N_COUNTER_next0 = cntr_name_conflict_WAIT_N_COUNTER0 - 1;
                cntr_name_conflict_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:335:13;
            end;
            cntr_name_conflict_WAIT_N_COUNTER_next1 = !cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next_next = cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next0 = 3;
            cntr_name_conflict_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:335:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : cntr_name_conflict_ff
    if ( ~rstn ) begin
        cntr_name_conflict_WAIT_N_COUNTER <= '0;
        cntr_name_conflict_WAIT_N_COUNTER_next <= cntr_name_conflict_WAIT_N_COUNTER;
        cntr_name_conflict_PROC_STATE <= '0;    // test_cthread_wait_n.cpp:330:9;
        cntr_name_conflict_WAIT_N_COUNTER0 <= '0;
    end
    else begin
        cntr_name_conflict_WAIT_N_COUNTER0 <= cntr_name_conflict_WAIT_N_COUNTER_next0;
        cntr_name_conflict_WAIT_N_COUNTER_next <= cntr_name_conflict_WAIT_N_COUNTER_next_next;
        cntr_name_conflict_WAIT_N_COUNTER <= cntr_name_conflict_WAIT_N_COUNTER_next1;
        cntr_name_conflict_PROC_STATE <= cntr_name_conflict_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: while_wait (test_cthread_wait_n.cpp:339:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: wait_1 (test_cthread_wait_n.cpp:350:5) 

// Thread-local variables
logic [31:0] nn;
logic [31:0] nn_next;

// Next-state combinational logic
always_comb begin : wait_1_comb     // test_cthread_wait_n.cpp:350:5
    wait_1_func;
end
function void wait_1_func;
    nn_next = nn;
    cntr_name_conflict_WAIT_N_COUNTER_next0 = nn_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_1_ff
    if ( ~rstn ) begin
        nn <= 1'd1;
    end
    else begin
        nn <= nn_next;
    end
end

endmodule


