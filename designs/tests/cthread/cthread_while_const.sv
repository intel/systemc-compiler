//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.15
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic s;
logic signed [31:0] s1;
logic signed [31:0] s2;
logic signed [31:0] s3;
logic signed [31:0] s4;
logic signed [31:0] s4a;
logic signed [31:0] s4b;
logic s5;
logic signed [31:0] s6;
logic signed [31:0] s7;
logic signed [31:0] s8;

//------------------------------------------------------------------------------
// Clocked THREAD: const1 (test_while_const.cpp:123:5) 

// Thread-local variables
logic signed [31:0] s1_next;

// Thread-local constants
logic A;

// Next-state combinational logic
always_comb begin : const1_comb     // test_while_const.cpp:123:5
    const1_func;
end
function void const1_func;
    s1_next = s1;
    while (A || s)
    begin
        s1_next = 1;
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const1_ff
    if ( ~rstn ) begin
        A = 0;
        s1 <= 0;
    end
    else begin
        s1 <= s1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const2 (test_while_const.cpp:139:5) 

// Thread-local variables
logic signed [31:0] s2_next;

// Thread-local constants
logic A0;

// Next-state combinational logic
always_comb begin : const2_comb     // test_while_const.cpp:139:5
    const2_func;
end
function void const2_func;
    s2_next = s2;
    while (s || A0)
    begin
        s2_next = 1;
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const2_ff
    if ( ~rstn ) begin
        A0 = 0;
        s2 <= 0;
    end
    else begin
        s2 <= s2_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const3 (test_while_const.cpp:155:5) 

// Thread-local variables
logic signed [31:0] s3_next;

// Thread-local constants
logic A1;
logic B;

// Next-state combinational logic
always_comb begin : const3_comb     // test_while_const.cpp:155:5
    const3_func;
end
function void const3_func;
    s3_next = s3;
    while (A1 || B && s || A1)
    begin
        s3_next = 1;
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const3_ff
    if ( ~rstn ) begin
        A1 = 0;
        B = 1;
        s3 <= 0;
    end
    else begin
        s3 <= s3_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const4 (test_while_const.cpp:172:5) 

// Thread-local variables
logic signed [31:0] s4_next;

// Thread-local constants
logic B0;
logic A2;

// Next-state combinational logic
always_comb begin : const4_comb     // test_while_const.cpp:172:5
    const4_func;
end
function void const4_func;
    s4_next = s4;
    while (B0 && s && (|s2 || A2) && (!(|s3) && B0))
    begin
        s4_next = 1;
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const4_ff
    if ( ~rstn ) begin
        A2 = 0;
        B0 = 1;
        s4 <= 0;
    end
    else begin
        s4 <= s4_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const4a (test_while_const.cpp:190:5) 

// Thread-local variables
logic signed [31:0] s4a_next;

// Thread-local constants
logic A3;

// Next-state combinational logic
always_comb begin : const4a_comb     // test_while_const.cpp:190:5
    const4a_func;
end
function void const4a_func;
    s4a_next = s4a;
    s4a_next = 1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const4a_ff
    if ( ~rstn ) begin
        A3 = 0;
        s4a <= 0;
    end
    else begin
        s4a <= s4a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const4b (test_while_const.cpp:206:5) 

// Thread-local variables
logic signed [31:0] s4b_next;
logic [1:0] const4b_PROC_STATE;
logic [1:0] const4b_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : const4b_comb     // test_while_const.cpp:206:5
    const4b_func;
end
function void const4b_func;
    logic A_1;
    s4b_next = s4b;
    const4b_PROC_STATE_next = const4b_PROC_STATE;
    
    case (const4b_PROC_STATE)
        0: begin
            if (|s1)
            begin
                s4b_next = 1;
                const4b_PROC_STATE_next = 1; return;    // test_while_const.cpp:218:17;
            end
            s4b_next = 2;
            const4b_PROC_STATE_next = 2; return;    // test_while_const.cpp:221:13;
        end
        1: begin
            if (|s1)
            begin
                s4b_next = 1;
                const4b_PROC_STATE_next = 1; return;    // test_while_const.cpp:218:17;
            end
            s4b_next = 2;
            const4b_PROC_STATE_next = 2; return;    // test_while_const.cpp:221:13;
        end
        2: begin
            if (|s1)
            begin
                s4b_next = 1;
                const4b_PROC_STATE_next = 1; return;    // test_while_const.cpp:218:17;
            end
            s4b_next = 2;
            const4b_PROC_STATE_next = 2; return;    // test_while_const.cpp:221:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const4b_ff
    if ( ~rstn ) begin
        logic A_1;
        A_1 = 0;
        s4b <= 0;
        const4b_PROC_STATE <= 0;    // test_while_const.cpp:210:9;
    end
    else begin
        s4b <= s4b_next;
        const4b_PROC_STATE <= const4b_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait1 (test_while_const.cpp:229:5) 

// Thread-local variables
logic s5_next;
logic [1:0] const_wait1_PROC_STATE;
logic [1:0] const_wait1_PROC_STATE_next;

// Thread-local constants
logic A4;

// Next-state combinational logic
always_comb begin : const_wait1_comb     // test_while_const.cpp:229:5
    const_wait1_func;
end
function void const_wait1_func;
    s5_next = s5;
    const_wait1_PROC_STATE_next = const_wait1_PROC_STATE;
    
    case (const_wait1_PROC_STATE)
        0: begin
            if (s || A4)
            begin
                s5_next = !s5;
                const_wait1_PROC_STATE_next = 1; return;    // test_while_const.cpp:239:17;
            end
            const_wait1_PROC_STATE_next = 2; return;    // test_while_const.cpp:241:13;
        end
        1: begin
            if (s || A4)
            begin
                s5_next = !s5;
                const_wait1_PROC_STATE_next = 1; return;    // test_while_const.cpp:239:17;
            end
            const_wait1_PROC_STATE_next = 2; return;    // test_while_const.cpp:241:13;
        end
        2: begin
            if (s || A4)
            begin
                s5_next = !s5;
                const_wait1_PROC_STATE_next = 1; return;    // test_while_const.cpp:239:17;
            end
            const_wait1_PROC_STATE_next = 2; return;    // test_while_const.cpp:241:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait1_ff
    if ( ~rstn ) begin
        A4 = 0;
        s5 <= 0;
        const_wait1_PROC_STATE <= 0;    // test_while_const.cpp:233:9;
    end
    else begin
        s5 <= s5_next;
        const_wait1_PROC_STATE <= const_wait1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait2 (test_while_const.cpp:247:5) 

// Thread-local variables
logic signed [31:0] s6_next;
logic A5;
logic A_next;
logic [1:0] const_wait2_PROC_STATE;
logic [1:0] const_wait2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : const_wait2_comb     // test_while_const.cpp:247:5
    const_wait2_func;
end
function void const_wait2_func;
    A_next = A5;
    s6_next = s6;
    const_wait2_PROC_STATE_next = const_wait2_PROC_STATE;
    
    case (const_wait2_PROC_STATE)
        0: begin
            s6_next = 1;
            const_wait2_PROC_STATE_next = 1; return;    // test_while_const.cpp:257:17;
        end
        1: begin
            if (s)
            begin
                // break begin
                s6_next = 3;
                const_wait2_PROC_STATE_next = 2; return;    // test_while_const.cpp:263:13;
                // break end
            end
            s6_next = 2;
            if (1)
            begin
                s6_next = 1;
                const_wait2_PROC_STATE_next = 1; return;    // test_while_const.cpp:257:17;
            end
            s6_next = 3;
            const_wait2_PROC_STATE_next = 2; return;    // test_while_const.cpp:263:13;
        end
        2: begin
            s6_next = 1;
            const_wait2_PROC_STATE_next = 1; return;    // test_while_const.cpp:257:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait2_ff
    if ( ~rstn ) begin
        A5 <= 1;
        s6 <= 0;
        const_wait2_PROC_STATE <= 0;    // test_while_const.cpp:251:9;
    end
    else begin
        s6 <= s6_next;
        A5 <= A_next;
        const_wait2_PROC_STATE <= const_wait2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait3 (test_while_const.cpp:268:5) 

// Thread-local variables
logic signed [31:0] s7_next;
logic [2:0] const_wait3_PROC_STATE;
logic [2:0] const_wait3_PROC_STATE_next;

// Thread-local constants
logic B1;
logic A6;

// Next-state combinational logic
always_comb begin : const_wait3_comb     // test_while_const.cpp:268:5
    const_wait3_func;
end
function void const_wait3_func;
    s7_next = s7;
    const_wait3_PROC_STATE_next = const_wait3_PROC_STATE;
    
    case (const_wait3_PROC_STATE)
        0: begin
            if (s && B1)
            begin
                if (s)
                begin
                    const_wait3_PROC_STATE_next = 1; return;    // test_while_const.cpp:279:21;
                end
                const_wait3_PROC_STATE_next = 2; return;    // test_while_const.cpp:283:17;
            end
            if (s)
            begin
                s7_next = 4;
            end
            const_wait3_PROC_STATE_next = 4; return;    // test_while_const.cpp:292:13;
        end
        1: begin
            s7_next = 1;
            // continue begin
            if (s && B1)
            begin
                if (s)
                begin
                    const_wait3_PROC_STATE_next = 1; return;    // test_while_const.cpp:279:21;
                end
                const_wait3_PROC_STATE_next = 2; return;    // test_while_const.cpp:283:17;
            end
            if (s)
            begin
                s7_next = 4;
            end
            const_wait3_PROC_STATE_next = 4; return;    // test_while_const.cpp:292:13;
            // continue end
        end
        2: begin
            s7_next = 2;
            if (!s || 0)
            begin
                const_wait3_PROC_STATE_next = 3; return;    // test_while_const.cpp:287:21;
            end
            if (s && B1)
            begin
                if (s)
                begin
                    const_wait3_PROC_STATE_next = 1; return;    // test_while_const.cpp:279:21;
                end
                const_wait3_PROC_STATE_next = 2; return;    // test_while_const.cpp:283:17;
            end
            if (s)
            begin
                s7_next = 4;
            end
            const_wait3_PROC_STATE_next = 4; return;    // test_while_const.cpp:292:13;
        end
        3: begin
            s7_next = 3;
            if (!s || 0)
            begin
                const_wait3_PROC_STATE_next = 3; return;    // test_while_const.cpp:287:21;
            end
            if (s && B1)
            begin
                if (s)
                begin
                    const_wait3_PROC_STATE_next = 1; return;    // test_while_const.cpp:279:21;
                end
                const_wait3_PROC_STATE_next = 2; return;    // test_while_const.cpp:283:17;
            end
            if (s)
            begin
                s7_next = 4;
            end
            const_wait3_PROC_STATE_next = 4; return;    // test_while_const.cpp:292:13;
        end
        4: begin
            if (s && B1)
            begin
                if (s)
                begin
                    const_wait3_PROC_STATE_next = 1; return;    // test_while_const.cpp:279:21;
                end
                const_wait3_PROC_STATE_next = 2; return;    // test_while_const.cpp:283:17;
            end
            if (s)
            begin
                s7_next = 4;
            end
            const_wait3_PROC_STATE_next = 4; return;    // test_while_const.cpp:292:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait3_ff
    if ( ~rstn ) begin
        A6 = 0;
        B1 = 1;
        s7 <= 0;
        const_wait3_PROC_STATE <= 0;    // test_while_const.cpp:273:9;
    end
    else begin
        s7 <= s7_next;
        const_wait3_PROC_STATE <= const_wait3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_wait4 (test_while_const.cpp:297:5) 

// Thread-local variables
logic const_wait4_PROC_STATE;
logic const_wait4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : const_wait4_comb     // test_while_const.cpp:297:5
    const_wait4_func;
end
function void const_wait4_func;
    const_wait4_PROC_STATE_next = const_wait4_PROC_STATE;
    
    case (const_wait4_PROC_STATE)
        0: begin
            const_wait4_PROC_STATE_next = 1; return;    // test_while_const.cpp:312:13;
        end
        1: begin
            const_wait4_PROC_STATE_next = 1; return;    // test_while_const.cpp:312:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : const_wait4_ff
    if ( ~rstn ) begin
        s8 <= 0;
        const_wait4_PROC_STATE <= 0;    // test_while_const.cpp:300:9;
    end
    else begin
        const_wait4_PROC_STATE <= const_wait4_PROC_STATE_next;
    end
end

endmodule


