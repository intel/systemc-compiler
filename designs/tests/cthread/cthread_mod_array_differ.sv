//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);


//------------------------------------------------------------------------------
// Child module instances

A ar1_0
(
  .clk(clk)
);

A0 ar1_1
(
  .clk(clk)
);

B br1_0
(
  .clk(clk)
);

B0 br1_1
(
  .clk(clk)
);

A ar2_0
(
  .clk(clk)
);

A0 ar2_1
(
  .clk(clk)
);

B br2_0
(
  .clk(clk)
);

B0 br2_1
(
  .clk(clk)
);

A1 ar3_0
(
  .clk(clk)
);

A2 ar3_1
(
  .clk(clk)
);

B br3_0
(
  .clk(clk)
);

B0 br3_1
(
  .clk(clk)
);

endmodule



//==============================================================================
//
// Module: A ()
//
module A // "top.ar2_0"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] t0;

// Local parameters generated for C++ constants
localparam logic [31:0] V = 1;
localparam logic [31:0] C = 1;

//------------------------------------------------------------------------------
// Clocked THREAD: proc (test_mod_array_differ.cpp:34:5) 

// Thread-local variables
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : proc_comb     // test_mod_array_differ.cpp:34:5
    proc_func;
end
function void proc_func;
    integer unsigned l;
    t0_next = t0;
    l = V + C;
    t0_next = l;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : proc_ff
    if ( ~nrst ) begin
        integer unsigned l;
        l = V;
    end
    else begin
        t0 <= t0_next;
    end
end

endmodule



//==============================================================================
//
// Module: A ()
//
module A0 // "top.ar2_1"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] t0;

// Local parameters generated for C++ constants
localparam logic [31:0] V = 2;
localparam logic [31:0] C = 2;

//------------------------------------------------------------------------------
// Clocked THREAD: proc (test_mod_array_differ.cpp:34:5) 

// Thread-local variables
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : proc_comb     // test_mod_array_differ.cpp:34:5
    proc_func;
end
function void proc_func;
    integer unsigned l;
    t0_next = t0;
    l = V + C;
    t0_next = l;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : proc_ff
    if ( ~nrst ) begin
        integer unsigned l;
        l = V;
    end
    else begin
        t0 <= t0_next;
    end
end

endmodule



//==============================================================================
//
// Module: B ()
//
module B // "top.br2_0"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] t0;

// Local parameters generated for C++ constants
localparam logic [31:0] V = 1;

//------------------------------------------------------------------------------
// Clocked THREAD: proc (test_mod_array_differ.cpp:61:5) 

// Thread-local variables
logic signed [31:0] t0_next;
logic proc_PROC_STATE;
logic proc_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : proc_comb     // test_mod_array_differ.cpp:61:5
    proc_func;
end
function void proc_func;
    integer unsigned l;
    t0_next = t0;
    proc_PROC_STATE_next = proc_PROC_STATE;
    
    case (proc_PROC_STATE)
        0: begin
            l = V;
            proc_PROC_STATE_next = 1; return;    // test_mod_array_differ.cpp:66:13;
        end
        1: begin
            l = V + 1'd1;
            t0_next = l;
            l = V;
            proc_PROC_STATE_next = 1; return;    // test_mod_array_differ.cpp:66:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : proc_ff
    if ( ~nrst ) begin
        proc_PROC_STATE <= '0;    // test_mod_array_differ.cpp:63:9;
    end
    else begin
        t0 <= t0_next;
        proc_PROC_STATE <= proc_PROC_STATE_next;
    end
end

endmodule



//==============================================================================
//
// Module: B ()
//
module B0 // "top.br2_1"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] t0;

// Local parameters generated for C++ constants
localparam logic [31:0] V = 2;

//------------------------------------------------------------------------------
// Clocked THREAD: proc (test_mod_array_differ.cpp:61:5) 

// Thread-local variables
logic signed [31:0] t0_next;
logic proc_PROC_STATE;
logic proc_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : proc_comb     // test_mod_array_differ.cpp:61:5
    proc_func;
end
function void proc_func;
    integer unsigned l;
    t0_next = t0;
    proc_PROC_STATE_next = proc_PROC_STATE;
    
    case (proc_PROC_STATE)
        0: begin
            l = V;
            proc_PROC_STATE_next = 1; return;    // test_mod_array_differ.cpp:66:13;
        end
        1: begin
            l = V + 1'd1;
            t0_next = l;
            l = V;
            proc_PROC_STATE_next = 1; return;    // test_mod_array_differ.cpp:66:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : proc_ff
    if ( ~nrst ) begin
        proc_PROC_STATE <= '0;    // test_mod_array_differ.cpp:63:9;
    end
    else begin
        t0 <= t0_next;
        proc_PROC_STATE <= proc_PROC_STATE_next;
    end
end

endmodule



//==============================================================================
//
// Module: A ()
//
module A1 // "top.ar3_0"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] t0;

// Local parameters generated for C++ constants
localparam logic [31:0] V = 1;
localparam logic [31:0] C = '0;

//------------------------------------------------------------------------------
// Clocked THREAD: proc (test_mod_array_differ.cpp:34:5) 

// Thread-local variables
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : proc_comb     // test_mod_array_differ.cpp:34:5
    proc_func;
end
function void proc_func;
    integer unsigned l;
    t0_next = t0;
    l = V + C;
    t0_next = l;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : proc_ff
    if ( ~nrst ) begin
        integer unsigned l;
        l = V;
    end
    else begin
        t0 <= t0_next;
    end
end

endmodule



//==============================================================================
//
// Module: A ()
//
module A2 // "top.ar3_1"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] t0;

// Local parameters generated for C++ constants
localparam logic [31:0] V = 2;
localparam logic [31:0] C = '0;

//------------------------------------------------------------------------------
// Clocked THREAD: proc (test_mod_array_differ.cpp:34:5) 

// Thread-local variables
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : proc_comb     // test_mod_array_differ.cpp:34:5
    proc_func;
end
function void proc_func;
    integer unsigned l;
    t0_next = t0;
    l = V + C;
    t0_next = l;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : proc_ff
    if ( ~nrst ) begin
        integer unsigned l;
        l = V;
    end
    else begin
        t0 <= t0_next;
    end
end

endmodule


