//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.24
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
);

// Variables generated for SystemC signals
logic a;
logic b;
logic clk;
logic nrst;


//------------------------------------------------------------------------------
// Child module instances

A a_mod
(
  .clk(clk),
  .nrst(nrst),
  .a(a),
  .b(b)
);

endmodule



//==============================================================================
//
// Module: A (test_cthread_simple2.cpp:175:5)
//
module A // "b_mod.a_mod"
(
    input logic clk,
    input logic nrst,
    input logic a,
    output logic b
);

// Variables generated for SystemC signals
logic c;
logic signed [31:0] ss;
logic signed [31:0] tt;
logic signed [31:0] tt1;
logic signed [31:0] t0;
logic e;

//------------------------------------------------------------------------------
// Clocked THREAD: latch_issue (test_cthread_simple2.cpp:57:5) 

// Thread-local variables
logic signed [31:0] tt_next;
logic [1:0] latch_issue_PROC_STATE;
logic [1:0] latch_issue_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : latch_issue_comb     // test_cthread_simple2.cpp:57:5
    latch_issue_func;
end
function void latch_issue_func;
    integer unsigned par;
    integer loc;
    loc = '0;
    par = '0;
    tt_next = tt;
    latch_issue_PROC_STATE_next = latch_issue_PROC_STATE;
    
    case (latch_issue_PROC_STATE)
        0: begin
            loc = ss;
            par = loc;
            // Call f() begin
            tt_next = par;
            // Call f() end
            latch_issue_PROC_STATE_next = 1; return;    // test_cthread_simple2.cpp:66:13;
        end
        1: begin
            tt_next = '0;
            latch_issue_PROC_STATE_next = '0; return;    // test_cthread_simple2.cpp:68:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : latch_issue_ff
    if ( ~nrst ) begin
        integer unsigned par;
        tt <= '0;
        par = 1'd0;
        // Call f() begin
        tt <= par;
        // Call f() end
        latch_issue_PROC_STATE <= '0;    // test_cthread_simple2.cpp:60:9;
    end
    else begin
        tt <= tt_next;
        latch_issue_PROC_STATE <= latch_issue_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Method process: latch_issue_meth (test_cthread_simple2.cpp:79:5) 

always_comb 
begin : latch_issue_meth     // test_cthread_simple2.cpp:79:5
    integer unsigned par;
    par = '0;
    tt1 = '0;
    if (|ss)
    begin
        par = ss;
        // Call f1() begin
        tt1 = par;
        // Call f1() end
    end else begin
        par = ss;
        // Call f1() begin
        tt1 = par;
        // Call f1() end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: read_only_reg (test_cthread_simple2.cpp:96:5) 

// Thread-local variables
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : read_only_reg_comb     // test_cthread_simple2.cpp:96:5
    read_only_reg_func;
end
function void read_only_reg_func;
    logic b_1;
    t0_next = t0;
    b_1 = c;
    t0_next = b_1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : read_only_reg_ff
    if ( ~nrst ) begin
    end
    else begin
        t0 <= t0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple1 (test_cthread_simple2.cpp:107:5) 

// Thread-local variables
logic signed [31:0] m;
logic signed [31:0] m_next;

// Next-state combinational logic
always_comb begin : simple1_comb     // test_cthread_simple2.cpp:107:5
    simple1_func;
end
function void simple1_func;
    integer i;
    m_next = m;
    i = m_next + 2'sd1;
    m_next = i;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge nrst) 
begin : simple1_ff
    if ( nrst ) begin
        integer i;
        m <= 1;
        i = '0;
    end
    else begin
        m <= m_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple2 (test_cthread_simple2.cpp:120:5) 

// Thread-local variables
logic signed [31:0] x;
logic signed [31:0] x_next;

// Next-state combinational logic
always_comb begin : simple2_comb     // test_cthread_simple2.cpp:120:5
    simple2_func;
end
function void simple2_func;
    integer i;
    x_next = x;
    i = x_next + 2'sd1;
    x_next = i;
endfunction

// Synchronous register update
always_ff @(negedge clk or negedge nrst) 
begin : simple2_ff
    if ( ~nrst ) begin
        x <= 1;
    end
    else begin
        x <= x_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple3 (test_cthread_simple2.cpp:132:5) 

// Thread-local variables
logic b_next;
logic c_next;
logic [1:0] simple3_PROC_STATE;
logic [1:0] simple3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : simple3_comb     // test_cthread_simple2.cpp:132:5
    simple3_func;
end
function void simple3_func;
    b_next = b;
    c_next = c;
    simple3_PROC_STATE_next = simple3_PROC_STATE;
    
    case (simple3_PROC_STATE)
        0: begin
            c_next = |2'(a + b);
            simple3_PROC_STATE_next = 1; return;    // test_cthread_simple2.cpp:139:13;
        end
        1: begin
            b_next = c;
            simple3_PROC_STATE_next = '0; return;    // test_cthread_simple2.cpp:141:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : simple3_ff
    if ( ~nrst ) begin
        b <= 1'd1;
        simple3_PROC_STATE <= '0;    // test_cthread_simple2.cpp:135:9;
    end
    else begin
        b <= b_next;
        c <= c_next;
        simple3_PROC_STATE <= simple3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple_pres (test_cthread_simple2.cpp:146:5) 

// Thread-local variables
logic e_next;
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic [1:0] simple_pres_PROC_STATE;
logic [1:0] simple_pres_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : simple_pres_comb     // test_cthread_simple2.cpp:146:5
    simple_pres_func;
end
function void simple_pres_func;
    e_next = e;
    i_next = i0;
    simple_pres_PROC_STATE_next = simple_pres_PROC_STATE;
    
    case (simple_pres_PROC_STATE)
        0: begin
            e_next = |32'(a + i_next);
            simple_pres_PROC_STATE_next = 1; return;    // test_cthread_simple2.cpp:154:13;
        end
        1: begin
            i_next = e;
            simple_pres_PROC_STATE_next = '0; return;    // test_cthread_simple2.cpp:156:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : simple_pres_ff
    if ( ~nrst ) begin
        e <= '0;
        i0 <= 1;
        simple_pres_PROC_STATE <= '0;    // test_cthread_simple2.cpp:150:9;
    end
    else begin
        e <= e_next;
        i0 <= i_next;
        simple_pres_PROC_STATE <= simple_pres_PROC_STATE_next;
    end
end

endmodule


