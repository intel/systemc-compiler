//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.18
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: simple_test ()
//
module simple_test // "test_top.dut"
(
    input logic clk,
    input logic nrst
);

// Variables generated for SystemC signals
logic run_put_req;
logic run_put_req_d;
logic run_core_req_d;
logic resp_get_req;
logic resp_get_req_d;
logic resp_core_req_d;
logic [170:0] resp_core_data_d;
logic [170:0] resp_core_data_out;
logic flip;
logic run_clk;
logic run_nrst;
logic run_core_ready;
logic run_core_req;
logic [170:0] run_core_data;
logic resp_clk;
logic resp_nrst;
logic resp_core_ready;
logic resp_core_req;
logic [170:0] resp_core_data;

// Local parameters generated for C++ constants
localparam logic run_chan_sync = 0;
localparam logic run_cthread = 1;
localparam logic run_always_ready = 0;
localparam logic resp_cthread = 1;
localparam logic resp_always_ready = 0;

// Assignments generated for C++ channel arrays
assign run_clk = clk;
assign run_nrst = nrst;
assign resp_clk = clk;
assign resp_nrst = nrst;

//------------------------------------------------------------------------------
// Clocked THREAD: run_sync_thread (sct_initiator.h:223:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: run_core_thread (sct_initiator.h:266:5) 

// Thread-local variables
logic run_put_req_d_next;
logic run_core_req_d_next;

// Next-state combinational logic
always_comb begin : run_core_thread_comb     // sct_initiator.h:266:5
    run_core_thread_func;
end
function void run_core_thread_func;
    run_core_req_d_next = run_core_req_d;
    run_put_req_d_next = run_put_req_d;
    run_put_req_d_next = run_put_req;
    run_core_req_d_next = !run_core_ready && run_core_req;
endfunction

// Synchronous register update
always_ff @(posedge run_clk or negedge run_nrst) 
begin : run_core_thread_ff
    if ( ~run_nrst ) begin
        run_put_req_d <= 0;
        run_core_req_d <= 0;
    end
    else begin
        run_put_req_d <= run_put_req_d_next;
        run_core_req_d <= run_core_req_d_next;
    end
end

//------------------------------------------------------------------------------
// Method process: run_req_control (sct_initiator.h:253:5) 

always_comb 
begin : run_req_control     // sct_initiator.h:253:5
    logic A;
    A = run_put_req != run_put_req_d;
    if (A)
    begin
        run_core_req = 1;
    end else begin
        run_core_req = run_core_req_d;
    end
end

//------------------------------------------------------------------------------
// Method process: resp_ready_control (sct_target.h:238:5) 

always_comb 
begin : resp_ready_control     // sct_target.h:238:5
    logic A;
    A = resp_get_req != resp_get_req_d;
    if (A)
    begin
        resp_core_ready = 1;
    end else begin
        resp_core_ready = !resp_core_req_d;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: resp_core_thread (sct_target.h:247:5) 

// Thread-local variables
logic resp_get_req_d_next;
logic resp_core_req_d_next;
logic [170:0] resp_core_data_d_next;

// Next-state combinational logic
always_comb begin : resp_core_thread_comb     // sct_target.h:247:5
    resp_core_thread_func;
end
function void resp_core_thread_func;
    resp_core_data_d_next = resp_core_data_d;
    resp_core_req_d_next = resp_core_req_d;
    resp_get_req_d_next = resp_get_req_d;
    resp_get_req_d_next = resp_get_req;
    resp_core_req_d_next = !resp_core_ready || resp_core_req;
    if (resp_core_req && resp_core_ready)
    begin
        resp_core_data_d_next = resp_core_data;
    end
endfunction

// Synchronous register update
always_ff @(posedge resp_clk or negedge resp_nrst) 
begin : resp_core_thread_ff
    if ( ~resp_nrst ) begin
        resp_get_req_d <= 0;
        resp_core_req_d <= 0;
        resp_core_data_d <= 0;
    end
    else begin
        resp_get_req_d <= resp_get_req_d_next;
        resp_core_req_d <= resp_core_req_d_next;
        resp_core_data_d <= resp_core_data_d_next;
    end
end

//------------------------------------------------------------------------------
// Method process: resp_put_to_fifo (sct_target.h:224:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Method process: resp_core_data_mux (sct_target.h:213:5) 

always_comb 
begin : resp_core_data_mux     // sct_target.h:213:5
    if (resp_core_ready)
    begin
        resp_core_data_out = resp_core_data;
    end else begin
        resp_core_data_out = resp_core_data_d;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: init_thread (single_test.h:92:5) 

// Next-state combinational logic
always_comb begin : init_thread_comb     // single_test.h:92:5
    init_thread_func;
end
function void init_thread_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : init_thread_ff
    if ( ~nrst ) begin
        flip <= 0;
        // Call reset_put() begin
        run_put_req <= 0;
        run_core_data <= 0;
        // Call reset_put() end
        // Call reset_get() begin
        resp_get_req <= 0;
        // Call reset_get() end
    end
    else begin
    end
end


//------------------------------------------------------------------------------
// Child module instances

A a
(
  .run_core_ready_s(run_core_ready),
  .run_core_req_s(run_core_req),
  .run_core_data_s(run_core_data),
  .resp_core_ready_s(resp_core_ready),
  .resp_core_req_s(resp_core_req),
  .resp_core_data_s(resp_core_data),
  .clk(clk),
  .nrst(nrst),
  .run_clk(clk),
  .run_nrst(nrst),
  .resp_clk(clk),
  .resp_nrst(nrst)
);

endmodule



//==============================================================================
//
// Module: A (single_test.h:71:5)
//
module A // "test_top.dut.a"
(
    output logic run_core_ready_s,
    input logic run_core_req_s,
    input logic [170:0] run_core_data_s,
    input logic resp_core_ready_s,
    output logic resp_core_req_s,
    output logic [170:0] resp_core_data_s,
    input logic clk,
    input logic nrst,
    input logic run_clk,
    input logic run_nrst,
    input logic resp_clk,
    input logic resp_nrst
);

// Variables generated for SystemC signals
logic run_get_req;
logic run_get_req_d;
logic run_core_req_d;
logic [170:0] run_core_data_d;
logic [170:0] run_core_data_out;
logic resp_put_req;
logic pipe_put_req;
logic pipe_get_req;
logic pipe_ready_push;
logic pipe_out_valid;
logic [2:0] pipe_enable;
logic [170:0] pipe_data_in;
logic [170:0] pipe_data_out;
logic pipe_reg_full;
logic pipe_reg_full_d;
logic [170:0] pipe_data_reg;
logic [170:0] pipe_data_reg_d;
logic pipe_busy_reg[3];
logic pipe_busy_reg_d[3];
logic run_core_ready;
logic run_core_req;
logic [170:0] run_core_data;
logic resp_core_ready;
logic resp_core_req;
logic [170:0] resp_core_data;
logic pipe_clk;
logic pipe_nrst;

// Local parameters generated for C++ constants
localparam logic run_cthread = 0;
localparam logic run_always_ready = 0;
localparam logic resp_chan_sync = 0;
localparam logic resp_cthread = 0;
localparam logic resp_always_ready = 0;
localparam logic pipe_cthread_put = 0;
localparam logic pipe_cthread_get = 0;

// Assignments generated for C++ channel arrays
assign run_core_ready_s = run_core_ready;
assign run_core_req = run_core_req_s;
assign run_core_data = run_core_data_s;
assign resp_core_ready = resp_core_ready_s;
assign resp_core_req_s = resp_core_req;
assign resp_core_data_s = resp_core_data;
assign pipe_clk = clk;
assign pipe_nrst = nrst;

//------------------------------------------------------------------------------
// Method process: run_ready_control (sct_target.h:238:5) 

always_comb 
begin : run_ready_control     // sct_target.h:238:5
    logic A;
    A = run_get_req_d;
    if (A)
    begin
        run_core_ready = 1;
    end else begin
        run_core_ready = !run_core_req_d;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: run_core_thread (sct_target.h:247:5) 

// Thread-local variables
logic run_get_req_d_next;
logic run_core_req_d_next;
logic [170:0] run_core_data_d_next;

// Next-state combinational logic
always_comb begin : run_core_thread_comb     // sct_target.h:247:5
    run_core_thread_func;
end
function void run_core_thread_func;
    run_core_data_d_next = run_core_data_d;
    run_core_req_d_next = run_core_req_d;
    run_get_req_d_next = run_get_req_d;
    run_get_req_d_next = run_get_req;
    run_core_req_d_next = !run_core_ready || run_core_req;
    if (run_core_req && run_core_ready)
    begin
        run_core_data_d_next = run_core_data;
    end
endfunction

// Synchronous register update
always_ff @(posedge run_clk or negedge run_nrst) 
begin : run_core_thread_ff
    if ( ~run_nrst ) begin
        run_get_req_d <= 0;
        run_core_req_d <= 0;
        run_core_data_d <= 0;
    end
    else begin
        run_get_req_d <= run_get_req_d_next;
        run_core_req_d <= run_core_req_d_next;
        run_core_data_d <= run_core_data_d_next;
    end
end

//------------------------------------------------------------------------------
// Method process: run_put_to_fifo (sct_target.h:224:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Method process: run_core_data_mux (sct_target.h:213:5) 

always_comb 
begin : run_core_data_mux     // sct_target.h:213:5
    if (run_core_ready)
    begin
        run_core_data_out = run_core_data;
    end else begin
        run_core_data_out = run_core_data_d;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: resp_sync_thread (sct_initiator.h:223:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: resp_core_thread (sct_initiator.h:266:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Method process: resp_req_control (sct_initiator.h:253:5) 

always_comb 
begin : resp_req_control     // sct_initiator.h:253:5
    logic A;
    A = resp_put_req;
    if (A)
    begin
        resp_core_req = 1;
    end else begin
        resp_core_req = 0;
    end
end

//------------------------------------------------------------------------------
// Method process: pipe_asyncProc (sct_pipe.h:352:5) 

always_comb 
begin : pipe_asyncProc     // sct_pipe.h:352:5
    logic push;
    logic pop;
    logic busyRegs[3];
    logic regFull;
    logic [170:0] dataReg;
    logic [2:0] enableRegs;
    push = pipe_put_req;
    pop = pipe_get_req;
    for (integer unsigned i = 0; i != 3; ++i)
    begin
        busyRegs[i] = pipe_busy_reg_d[i];
    end
    regFull = pipe_reg_full_d;
    dataReg = pipe_data_reg_d;
    if (!regFull && busyRegs[3 - 1])
    begin
        busyRegs[3 - 1] = 0;
        regFull = 1;
        dataReg = pipe_data_out;
    end
    enableRegs = 0;
    for (integer unsigned i_1 = 3 - 1; i_1 != 0; --i_1)
    begin
        if (!busyRegs[i_1] && busyRegs[i_1 - 1])
        begin
            busyRegs[i_1] = 1;
            busyRegs[i_1 - 1] = 0;
            enableRegs[i_1] = 1;
        end
    end
    pipe_ready_push = !busyRegs[0];
    pipe_out_valid = regFull;
    if (push && !busyRegs[0])
    begin
        busyRegs[0] = 1;
        enableRegs[0] = 1;
    end
    if (!pipe_cthread_get && pop)
    begin
        regFull = 0;
    end
    for (integer unsigned i_2 = 0; i_2 != 3; ++i_2)
    begin
        pipe_busy_reg[i_2] = busyRegs[i_2];
    end
    pipe_enable = enableRegs;
    pipe_reg_full = regFull;
    pipe_data_reg = dataReg;
end

//------------------------------------------------------------------------------
// Clocked THREAD: pipe_syncProc (sct_pipe.h:396:5) 

// Thread-local variables
logic pipe_busy_reg_d_next[3];
logic pipe_reg_full_d_next;
logic [170:0] pipe_data_reg_d_next;

// Next-state combinational logic
always_comb begin : pipe_syncProc_comb     // sct_pipe.h:396:5
    pipe_syncProc_func;
end
function void pipe_syncProc_func;
    pipe_busy_reg_d_next = pipe_busy_reg_d;
    pipe_data_reg_d_next = pipe_data_reg_d;
    pipe_reg_full_d_next = pipe_reg_full_d;
    for (integer unsigned i_1 = 0; i_1 != 3; ++i_1)
    begin
        pipe_busy_reg_d_next[i_1] = pipe_busy_reg[i_1];
    end
    pipe_reg_full_d_next = pipe_reg_full;
    pipe_data_reg_d_next = pipe_data_reg;
endfunction

// Synchronous register update
always_ff @(posedge pipe_clk or negedge pipe_nrst) 
begin : pipe_syncProc_ff
    if ( ~pipe_nrst ) begin
        for (integer unsigned i = 0; i != 3; ++i)
        begin
            pipe_busy_reg_d[i] <= 0;
        end
        pipe_reg_full_d <= 0;
        pipe_data_reg_d <= 0;
    end
    else begin
        pipe_busy_reg_d <= pipe_busy_reg_d_next;
        pipe_reg_full_d <= pipe_reg_full_d_next;
        pipe_data_reg_d <= pipe_data_reg_d_next;
    end
end

//------------------------------------------------------------------------------
// Method process: methProc (single_test.h:41:5) 

always_comb 
begin : methProc     // single_test.h:41:5
    logic TMP_0;
    logic TMP_1;
    logic [170:0] TMP_2;
    logic A;
    logic [170:0] data;
    logic TMP_4;
    logic TMP_5;
    logic TMP_6;
    logic [170:0] TMP_7;
    logic [170:0] data_1;
    logic TMP_9;
    // Call reset_get() begin
    run_get_req = 0;
    // Call reset_get() end
    // Call reset_put() begin
    resp_put_req = 0;
    resp_core_data = 0;
    // Call reset_put() end
    // Call reset() begin
    // Call reset_get() begin
    pipe_get_req = 0;
    // Call reset_get() end
    // Call reset_put() begin
    pipe_put_req = 0;
    pipe_data_in = 0;
    // Call reset_put() end
    // Call reset() end
    // Call ready() begin
    TMP_0 = pipe_ready_push;
    // Call ready() end
    // Call request() begin
    TMP_1 = !run_core_ready || run_core_req;
    // Call request() end
    if (TMP_0 && TMP_1)
    begin
        // Call get() begin
        A = (!run_core_ready || run_core_req);
        if (A)
        begin
            run_get_req = 1;
        end else begin
            run_get_req = 0;
        end
        TMP_2 = run_core_data_out;
        // Call get() end
        data = TMP_2;
        // Call put() begin
        if (pipe_ready_push)
        begin
            pipe_put_req = 1;
            pipe_data_in = data;
            TMP_4 = 1;
        end else begin
            pipe_put_req = 0;
            pipe_data_in = 0;
            TMP_4 = 0;
        end
        // Call put() end
    end
    // Call request() begin
    TMP_5 = pipe_out_valid;
    // Call request() end
    // Call ready() begin
    TMP_6 = resp_core_ready;
    // Call ready() end
    if (TMP_5 && TMP_6)
    begin
        // Call get() begin
        if (pipe_out_valid)
        begin
            pipe_get_req = 1;
        end else begin
            pipe_get_req = 0;
        end
        TMP_7 = pipe_data_reg;
        // Call get() end
        data_1 = TMP_7;
        // Call put() begin
        if (resp_always_ready || resp_core_ready)
        begin
            resp_put_req = 1;
            resp_core_data = data_1;
            TMP_9 = 1;
        end else begin
            resp_put_req = 0;
            resp_core_data = 0;
            TMP_9 = 0;
        end
        // Call put() end
    end
end


//------------------------------------------------------------------------------
// Child module instances

My_SV_pipe_reg #(171, 0, 4, 0, 0) pipe_reg
(
  .clk(pipe_clk),
  .rst_n(pipe_nrst),
  .enable(pipe_enable),
  .data_in(pipe_data_in),
  .data_out(pipe_data_out)
);

endmodule


