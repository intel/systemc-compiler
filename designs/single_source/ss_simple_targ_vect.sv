//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.18
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B ()
//
module B // "test_top.dut.a"
(
    input logic clk,
    input logic nrst,
    output logic run_core_ready[10],
    input logic run_core_req[10],
    input logic [15:0] run_core_data[10],
    input logic resp_core_ready,
    output logic resp_core_req,
    output logic [15:0] resp_core_data
);

// Variables generated for SystemC signals
logic run_get_req[10];
logic run_get_req_d[10];
logic run_core_req_d[10];
logic [15:0] run_core_data_d[10];
logic [15:0] run_core_data_out[10];
logic resp_put_req;
logic run_clk[10];
logic run_nrst[10];

// Local parameters generated for C++ constants
localparam logic run_cthread[10] = '{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
localparam logic run_always_ready[10] = '{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
localparam logic resp_chan_sync = 0;
localparam logic resp_cthread = 0;
localparam logic resp_always_ready = 0;

// Assignments generated for C++ channel arrays
assign run_clk[0] = clk;
assign run_clk[1] = clk;
assign run_clk[2] = clk;
assign run_clk[3] = clk;
assign run_clk[4] = clk;
assign run_clk[5] = clk;
assign run_clk[6] = clk;
assign run_clk[7] = clk;
assign run_clk[8] = clk;
assign run_clk[9] = clk;
assign run_nrst[0] = nrst;
assign run_nrst[1] = nrst;
assign run_nrst[2] = nrst;
assign run_nrst[3] = nrst;
assign run_nrst[4] = nrst;
assign run_nrst[5] = nrst;
assign run_nrst[6] = nrst;
assign run_nrst[7] = nrst;
assign run_nrst[8] = nrst;
assign run_nrst[9] = nrst;

//------------------------------------------------------------------------------
// Method process: run_ready_control (sct_target.h:238:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 10; sct_i = sct_i + 1) 
begin : run_ready_control_sct_i 

    always_comb 
    begin : run_ready_control     // sct_target.h:238:5
        logic A;
        A = run_get_req_d[sct_i];
        if (A)
        begin
            run_core_ready[sct_i] = 1;
        end else begin
            run_core_ready[sct_i] = !run_core_req_d[sct_i];
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: run_core_thread (sct_target.h:247:5) 

// Thread-local variables
logic run_get_req_d_next[10];
logic run_core_req_d_next[10];
logic [15:0] run_core_data_d_next[10];

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 10; sct_i = sct_i + 1) 
begin : run_core_thread_sct_i 

    // Next-state combinational logic
    always_comb begin : run_core_thread_comb     // sct_target.h:247:5
        run_core_thread_func;
    end
    function void run_core_thread_func;
        run_core_data_d_next[sct_i] = run_core_data_d[sct_i];
        run_core_req_d_next[sct_i] = run_core_req_d[sct_i];
        run_get_req_d_next[sct_i] = run_get_req_d[sct_i];
        run_get_req_d_next[sct_i] = run_get_req[sct_i];
        run_core_req_d_next[sct_i] = !run_core_ready[sct_i] || run_core_req[sct_i];
        if (run_core_req[sct_i] && run_core_ready[sct_i])
        begin
            run_core_data_d_next[sct_i] = run_core_data[sct_i];
        end
    endfunction

    // Synchronous register update
    always_ff @(posedge run_clk[sct_i] or negedge run_nrst[sct_i]) 
    begin : run_core_thread_ff
        if ( ~run_nrst[sct_i] ) begin
            run_get_req_d[sct_i] <= 0;
            run_core_req_d[sct_i] <= 0;
            run_core_data_d[sct_i] <= 0;
        end
        else begin
            run_get_req_d[sct_i] <= run_get_req_d_next[sct_i];
            run_core_req_d[sct_i] <= run_core_req_d_next[sct_i];
            run_core_data_d[sct_i] <= run_core_data_d_next[sct_i];
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Method process: run_put_to_fifo (sct_target.h:224:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Method process: run_core_data_mux (sct_target.h:213:5) 

// Modular interfaces array generate block
generate 
for (genvar sct_i = 0; sct_i != 10; sct_i = sct_i + 1) 
begin : run_core_data_mux_sct_i 

    always_comb 
    begin : run_core_data_mux     // sct_target.h:213:5
        if (run_core_ready[sct_i])
        begin
            run_core_data_out[sct_i] = run_core_data[sct_i];
        end else begin
            run_core_data_out[sct_i] = run_core_data_d[sct_i];
        end
    end

end
endgenerate

//------------------------------------------------------------------------------
// Clocked THREAD: resp_sync_thread (sct_initiator.h:223:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: resp_core_thread (sct_initiator.h:266:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Method process: resp_req_control (sct_initiator.h:253:5) 

always_comb 
begin : resp_req_control     // sct_initiator.h:253:5
    logic A;
    A = resp_put_req;
    if (A)
    begin
        resp_core_req = 1;
    end else begin
        resp_core_req = 0;
    end
end

//------------------------------------------------------------------------------
// Method process: methProc (targ_vect.h:41:5) 

always_comb 
begin : methProc     // targ_vect.h:41:5
    logic TMP_0;
    for (integer unsigned i = 0; i < 10; ++i)
    begin
        // Call reset_get() begin
        run_get_req[i] = 0;
        // Call reset_get() end
    end
    // Call reset_put() begin
    resp_put_req = 0;
    resp_core_data = 0;
    // Call reset_put() end
    for (integer i_1 = 0; i_1 < 10; ++i_1)
    begin
        // Call request() begin
        TMP_0 = !run_core_ready[i_1] || run_core_req[i_1];
        // Call request() end
    end
end

endmodule


