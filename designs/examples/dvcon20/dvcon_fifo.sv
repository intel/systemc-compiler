//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.25
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Dut ()
//
module Dut // "tb.dut"
(
    input logic clk,
    input logic nrst,
    input logic [31:0] in,
    output logic [31:0] out
);

// Variables generated for SystemC signals
logic fifo_push_sig;
logic [31:0] fifo_data_in_sig;
logic fifo_ready_sig;
logic fifo_pop_sig;
logic [31:0] fifo_data_out_sig;
logic fifo_valid_sig;
logic fifo_full_sig;
logic fifo_clk;
logic fifo_nrst;

// Assignments generated for C++ channel arrays
assign fifo_clk = clk;
assign fifo_nrst = nrst;

//------------------------------------------------------------------------------
// Method process: reqProc (test_fifo.cpp:29:5) 

always_comb 
begin : reqProc     // test_fifo.cpp:29:5
    logic TMP_0;
    logic TMP_1;
    logic push;
    logic TMP_2;
    logic [31:0] data;
    // Call ready() begin
    TMP_0 = fifo_ready_sig;
    // Call ready() end
    if (TMP_0)
    begin
        push = 1;
        // Call push() begin
        fifo_data_in_sig = in;
        fifo_push_sig = push;
        TMP_1 = fifo_ready_sig;
        // Call push() end
    end else begin
        data = 1'd0; push = 1'd0;
        // Call push() begin
        fifo_data_in_sig = data;
        fifo_push_sig = push;
        TMP_2 = fifo_ready_sig;
        // Call push() end
    end
end

//------------------------------------------------------------------------------
// Method process: respProc (test_fifo.cpp:38:5) 

always_comb 
begin : respProc     // test_fifo.cpp:38:5
    logic TMP_0;
    logic [31:0] TMP_1;
    logic pop;
    logic [31:0] data;
    logic [31:0] TMP_3;
    // Call valid() begin
    TMP_0 = fifo_valid_sig;
    // Call valid() end
    if (TMP_0)
    begin
        pop = 1;
        // Call pop() begin
        fifo_pop_sig = pop;
        TMP_1 = 32'(fifo_data_out_sig);
        // Call pop() end
        data = TMP_1;
        out = data;
    end else begin
        pop = 1'd0;
        // Call pop() begin
        fifo_pop_sig = pop;
        TMP_3 = 32'(fifo_data_out_sig);
        // Call pop() end
        out = '0;
    end
end


//------------------------------------------------------------------------------
// Child module instances

adv_fifo fifo_fifo
(
  .clk(fifo_clk),
  .nrst(fifo_nrst),
  .push(fifo_push_sig),
  .data_in(fifo_data_in_sig),
  .ready_to_push(fifo_ready_sig),
  .pop(fifo_pop_sig),
  .data_out(fifo_data_out_sig),
  .out_valid(fifo_valid_sig),
  .almost_full(fifo_full_sig)
);

endmodule



//==============================================================================
//
// Module: adv_fifo (AdvFifo.h:424:5)
//
module adv_fifo // "tb.dut.fifo.fifofifo"
(
    input logic clk,
    input logic nrst,
    input logic push,
    input logic [31:0] data_in,
    output logic ready_to_push,
    input logic pop,
    output logic [31:0] data_out,
    output logic out_valid,
    output logic almost_full
);

// Variables generated for SystemC signals
logic [31:0] pop_data;
logic [3:0] element_num;
logic [3:0] element_num_d;
logic push_sig;
logic pop_enable;
logic push_enable;
logic pop_enable_sig;
logic push_enable_sig;
logic [31:0] mcp_data_reg;
logic mcp_valid_reg;
logic out_valid_reg;
logic ready_push_reg;
logic almost_full_reg;

//------------------------------------------------------------------------------
// Method process: asyncProc (AdvFifo.h:176:5) 

always_comb 
begin : asyncProc     // AdvFifo.h:176:5
    out_valid = out_valid_reg;
    data_out = pop_data;
    push_sig = push;
    ready_to_push = ready_push_reg;
    almost_full = almost_full_reg;
end

//------------------------------------------------------------------------------
// Clocked THREAD: syncProc (AdvFifo.h:260:5) 

// Thread-local variables
logic [3:0] element_num_next;
logic [3:0] element_num_d_next;
logic out_valid_reg_next;
logic almost_full_reg_next;
logic ready_push_reg_next;
logic pop_enable_sig_next;
logic push_enable_sig_next;
logic mcp_valid_reg_next;
logic [31:0] mcp_data_reg_next;
logic [31:0] pop_data_next;
logic [2:0] popIndx;
logic [2:0] popIndx_next;
logic [3:0] elementNum;
logic [3:0] elementNum_next;
logic [2:0] pushIndx;
logic [2:0] pushIndx_next;
logic [31:0] fifo_buffer_flat[6];
logic [31:0] fifo_buffer_flat_next[6];

// Next-state combinational logic
always_comb begin : syncProc_comb     // AdvFifo.h:260:5
    syncProc_func;
end
function void syncProc_func;
    almost_full_reg_next = almost_full_reg;
    elementNum_next = elementNum;
    element_num_d_next = element_num_d;
    element_num_next = element_num;
    fifo_buffer_flat_next = fifo_buffer_flat;
    mcp_data_reg_next = mcp_data_reg;
    mcp_valid_reg_next = mcp_valid_reg;
    out_valid_reg_next = out_valid_reg;
    popIndx_next = popIndx;
    pop_data_next = pop_data;
    pop_enable_sig_next = pop_enable_sig;
    pushIndx_next = pushIndx;
    push_enable_sig_next = push_enable_sig;
    ready_push_reg_next = ready_push_reg;
    pop_enable_sig_next = pop_enable;
    push_enable_sig_next = push_enable;
    mcp_valid_reg_next = out_valid;
    mcp_data_reg_next = data_out;
    ready_push_reg_next = ready_to_push;
    if (pop && pop_enable && out_valid_reg)
    begin
        if (popIndx_next == 4'(3'd6 - 1'd1))
        begin
            popIndx_next = '0;
        end else begin
            popIndx_next = popIndx_next + 1'd1;
        end
        elementNum_next = elementNum_next - 1'd1;
    end
    if (push_sig && ready_to_push)
    begin
        fifo_buffer_flat_next[pushIndx_next] = data_in;
        if (pushIndx_next == 4'(3'd6 - 1'd1))
        begin
            pushIndx_next = '0;
        end else begin
            pushIndx_next = pushIndx_next + 1'd1;
        end
        elementNum_next = elementNum_next + 1'd1;
    end
    pop_data_next = fifo_buffer_flat_next[popIndx_next];
    if (push_enable)
    begin
        almost_full_reg_next = elementNum_next > 5'(3'd6 - 2'd3 - 1'd1);
        ready_push_reg_next = elementNum_next != 3'd6;
    end
    if (pop_enable)
    begin
        out_valid_reg_next = elementNum_next != 1'd0;
    end
    element_num_d_next = element_num;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : syncProc_ff
    if ( ~nrst ) begin
        element_num <= '0;
        element_num_d <= '0;
        out_valid_reg <= '0;
        almost_full_reg <= '0;
        ready_push_reg <= '0;
        pop_enable_sig <= 1'd1;
        push_enable_sig <= 1'd1;
        mcp_valid_reg <= '0;
        mcp_data_reg <= '0;
        elementNum <= '0;
        popIndx <= '0;
        pushIndx <= '0;
        pop_data <= '0;
        fifo_buffer_flat[0] <= 32'd0;
        for (int i = 1; i < 6; i++)
        begin
            fifo_buffer_flat[i] <= 32'd0;
        end
    end
    else begin
        element_num <= element_num_next;
        element_num_d <= element_num_d_next;
        out_valid_reg <= out_valid_reg_next;
        almost_full_reg <= almost_full_reg_next;
        ready_push_reg <= ready_push_reg_next;
        pop_enable_sig <= pop_enable_sig_next;
        push_enable_sig <= push_enable_sig_next;
        mcp_valid_reg <= mcp_valid_reg_next;
        mcp_data_reg <= mcp_data_reg_next;
        pop_data <= pop_data_next;
        popIndx <= popIndx_next;
        elementNum <= elementNum_next;
        pushIndx <= pushIndx_next;
        fifo_buffer_flat <= fifo_buffer_flat_next;
    end
end

//------------------------------------------------------------------------------
// Method process: setEnableProc (AdvFifo.h:400:5) 

assign pop_enable = 1'd1;
assign push_enable = 1'd1;

`ifndef INTEL_SVA_OFF
sctAssertLine165 : assert property (
    @(posedge clk) push && !ready_to_push && (!pop || !out_valid) |=> ready_to_push );
sctAssertLine168 : assert property (
    @(posedge clk) element_num == 3'd6 |-> almost_full && !ready_to_push );
sctAssertLine171 : assert property (
    @(posedge clk) push && ready_to_push && pop && out_valid |=> element_num == element_num_d );
sctAssertLine174 : assert property (
    @(posedge clk) (!push || !ready_to_push) && pop && out_valid |=> element_num == 5'(element_num_d - 1'd1) );
`endif // INTEL_SVA_OFF

endmodule


